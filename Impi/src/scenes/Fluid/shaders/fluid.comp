#version 430


//workgroup settings : 
layout(local_size_x = 1) in; //workgroup sizes : how many threads per workgroup

struct Blob
{
	vec2 pos;
	vec2 vel;
	float r;
	float mass;
	float pad;
}; //std430

struct GPUBox
{
	mat4 model;
	mat4 modelInverse;
	vec4 halfSizes;
	vec4 paddington; // CPU struct holds mesh pointer, we hold this so we can stream the updated model. 160 bytes.
};

layout(std430, binding = 1) buffer BlobBuffer
{
	Blob blobs[];
};

layout(std430, binding = 2) buffer BoxBuffer
{
	GPUBox box;
};


uniform float dt;
uniform float gravity;


void resolveBoxCollisions(inout Blob b)
{
	
	vec3 worldPos = vec3(b.pos, 0.0);
	vec3 localPos = (box.modelInverse * vec4(worldPos, 1.0)).xyz;

	vec3 h = box.halfSizes.xyz;
    bool collided = false;

    // ---- X walls ----
    if (localPos.x < -h.x) { localPos.x = -h.x; b.vel.x *= -0.8; collided = true; }
    if (localPos.x >  h.x) { localPos.x =  h.x; b.vel.x *= -0.8; collided = true; }

    // ---- Y walls ----
    if (localPos.y < -h.y) { localPos.y = -h.y; b.vel.y *= -0.8; collided = true; }
    if (localPos.y >  h.y) { localPos.y =  h.y; b.vel.y *= -0.8; collided = true; }

	if (collided)
    {
        vec3 newWorld = (box.model * vec4(localPos, 1.0)).xyz;
        b.pos = newWorld.xy;
    }

}


void main()
{
    uint id = gl_GlobalInvocationID.x;


	if (id >= 2) return;
	Blob b = blobs[id];

	// integrate
    b.vel.y += gravity * dt;
    b.pos += b.vel * dt;

	resolveBoxCollisions(b);

	//write back to ssbo
	blobs[id] = b;

}