#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\Impi\\src\\rendering\\assets\\SphereMesh.cpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\Impi\\headers\\rendering\\assets\\SphereMesh.h"
#pragma once
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"







#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"













#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

























































































































































































































































































































































































































































































































#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"







#pragma once






















#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"

#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"






    
    

#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        
            
        

#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
    #line 55 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"













#pragma once







































































































































#line 151 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"



#line 155 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"





























#line 185 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"


#line 188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"

#line 190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"





#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"



#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"






#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"











#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"








#line 228 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
#line 229 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"






























#line 1586 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
























#line 1611 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"












#line 1624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"






































#line 1663 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"















































































































#line 1775 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"






































































































#line 1878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"








































































































































































#line 2047 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"





































































































#line 2149 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"



















































































































































































































#line 2361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
extern "C" {




#line 2367 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"



































































































































































































































#line 2595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"









































































































































































































































#line 2868 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"









#line 2878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"



    
    


#line 2886 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
#line 2887 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"






#line 2894 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
#line 2895 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"






#line 2902 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
#line 2903 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"











#line 2915 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"

































#line 2949 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"






















}
#line 2973 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"











































































































































































































































































#line 292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"



#line 296 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"
















































#line 345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"











































#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"


}
#line 393 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"

#line 395 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\concurrencysal.h"
#pragma external_header(pop)
#line 2975 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\sal.h"
#pragma external_header(pop)
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)



    


        
    #line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"




    


        
    #line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"



    
#line 40 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"




    
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C" {
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"



#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"


    


#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"





#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"



#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"
    
    
#line 94 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"











#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"







#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"











#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"





#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"










#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"










#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"


} 
#line 169 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 

    





#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vadefs.h"

#pragma warning(pop) 
#pragma pack(pop)
#pragma external_header(pop)
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )






    



    





















#line 95 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
















    

#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"

#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        
    #line 130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    

#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        
    #line 138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"





#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
    
    
#line 148 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"




    
#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"










#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
    
#line 167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"




    
#line 173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    
        
        
    

#line 181 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 182 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"



    
#line 211 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    
#line 215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    
#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"








    
        
    

#line 232 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    


#line 239 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"



#line 243 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 255 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"



#line 259 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    
        
    

#line 266 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


#line 269 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    

#line 274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        
    #line 276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    

#line 282 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        
    #line 284 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    

#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        
    #line 292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 293 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    

#line 298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        
    #line 300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"





#line 307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"



#line 311 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"



#line 315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"



    


        
    

#line 325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    


#line 332 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"









    
        
    

#line 346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 347 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"







    
#line 356 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"






#line 363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    


        




    #line 374 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 375 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"



#line 379 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    
        
    


#line 387 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    


#line 396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"


#line 399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    #line 402 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#line 403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime.h"
#pragma external_header(pop)
#line 524 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"




























#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 90 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 120 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 150 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 198 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 204 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 210 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 222 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 228 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 270 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 282 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"






#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 313 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 337 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 343 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 367 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 373 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 379 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 385 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 391 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 409 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 415 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 421 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 427 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 433 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 439 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 445 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 451 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 457 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 463 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 469 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 475 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 481 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 487 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 493 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 499 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 505 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 511 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"






#line 518 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 524 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 530 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 536 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"






#line 543 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 549 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 555 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"







#line 563 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 569 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 575 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"





#line 581 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"



#line 585 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"

#line 587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"
#line 588 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xkeycheck.h"
#pragma external_header(pop)
#line 525 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"














#line 540 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 542 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 543 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 547 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 551 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





#line 557 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 559 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"













#line 573 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 584 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"














































































#line 663 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

































#line 697 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 705 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 713 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 721 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 726 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





#line 732 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"














#line 747 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"






#line 754 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"






#line 761 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 765 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"















































#line 813 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

























#line 839 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 840 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"






#line 847 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 848 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"














#line 863 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 864 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"






#line 871 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 872 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"











#line 884 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 885 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 893 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 894 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 905 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 907 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 911 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"


#line 914 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"


#line 917 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 918 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 926 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 934 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 936 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 941 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 943 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 948 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 950 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 960 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 965 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 967 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 972 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 977 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 981 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 986 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 991 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 999 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 1004 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"













#line 1018 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 1019 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"






#line 1026 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 1036 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 1047 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1056 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 1057 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"












#line 1071 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1073 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 1082 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1084 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 1095 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1097 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 1109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1111 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 1122 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1124 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"











#line 1137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 1150 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1164 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 1187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1189 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"













#line 1204 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"














#line 1234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
















#line 1254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 1268 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1270 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"













#line 1285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 1298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"












#line 1314 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 1349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1351 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 1360 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 1374 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1376 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1386 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 1408 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1410 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 1421 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
















#line 1439 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 1450 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1452 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"










#line 1463 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"












#line 1476 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1486 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1498 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"









#line 1508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"








#line 1517 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1521 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1525 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1529 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1537 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1541 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1545 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1549 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1553 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1557 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"











#line 1569 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





#line 1575 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1579 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 1584 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

































#line 1618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





























































#line 1680 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





















































































#line 1766 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



















































#line 1818 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 1823 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1825 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1829 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1831 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1833 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1837 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1839 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1843 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1845 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 1850 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1852 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 1853 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1857 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1859 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1861 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 1866 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1868 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1872 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1874 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1880 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1884 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 1886 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

























#line 1912 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"




#line 1917 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"


#line 1920 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

































#line 1954 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1958 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 1962 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"











#line 1974 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"


#line 1977 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"


#line 1980 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 1981 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





#line 1987 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 1995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





#line 2001 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"







#line 2009 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 2013 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"



#line 2017 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"





#line 2023 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"

#line 2025 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#line 2026 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals_core.h"
#pragma external_header(pop)
#line 9 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\climits"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits.h"







#pragma once




#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {







    
    



#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits.h"
































    
    
        
    

#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits.h"
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits.h"


    
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\climits"

#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\climits"
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\climits"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )










 namespace std {
 template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    [[nodiscard]] constexpr value_type operator()() const noexcept {
        return value;
    }
};

 template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

 using true_type  = bool_constant<true>;
 using false_type = bool_constant<false>;

 template <bool _Test, class _Ty = void>
struct enable_if {}; 

template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};

 template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

 template <bool _Test, class _Ty1, class _Ty2>
struct conditional { 
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

 template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;








 template <class, class>
constexpr bool is_same_v = false; 
template <class _Ty>
constexpr bool is_same_v<_Ty, _Ty> = true;

 template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"

 template <class _Ty>
struct remove_const { 
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

 template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

 template <class _Ty>
struct remove_cv { 
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; 
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

 template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { 
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<static_cast<bool>(_Next::value), _Next, _Rest...>::type;
};

 template <class... _Traits>
struct disjunction : false_type {}; 

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<static_cast<bool>(_First::value), _First, _Rest...>::type {
    
};

 template <class... _Traits>
constexpr bool disjunction_v = disjunction<_Traits...>::value;

template <class _Ty, class... _Types>
constexpr bool _Is_any_of_v = 


#line 174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
    disjunction_v<is_same<_Ty, _Types>...>;
#line 176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"

[[nodiscard]] constexpr bool _Is_constant_evaluated() noexcept { 
    return __builtin_is_constant_evaluated();
}





#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"

 template <class _Ty>
constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char, wchar_t,



    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

 template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

 template <class _Ty>
constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

 template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

 template <class _Ty>
constexpr bool is_arithmetic_v = 
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

 template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

 template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

 template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t [[msvc::known_semantics]] = remove_cv_t<remove_reference_t<_Ty>>;









#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"

} 







#pragma warning(pop)
#pragma pack(pop)
#line 258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
#line 259 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xtr1common"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.h"












#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"













#pragma once





#pragma warning(push)
#pragma warning(disable:   4514 4820 )



#pragma warning(disable: 28251)


extern "C" {
#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"

































#line 64 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"


#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"






#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 79 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 89 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"






#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 101 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 111 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 116 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"




#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"









unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _bittest(long const *, long);




long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedand64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long  _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);



long  _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
__int64 _InterlockedDecrement64(__int64 volatile * _Addend);
__int64 _interlockeddecrement64(__int64 volatile * _Addend);
long  _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);
__int64 _interlockedexchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long  _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);
__int64 _interlockedexchangeadd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long  _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
__int64 _InterlockedIncrement64(__int64 volatile * _Addend);
__int64 _interlockedincrement64(__int64 volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedxor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16 *);
__int32 __iso_volatile_load32(const volatile __int32 *);
__int64 __iso_volatile_load64(const volatile __int64 *);
__int8 __iso_volatile_load8(const volatile __int8 *);
void __iso_volatile_store16(volatile __int16 *, __int16);
void __iso_volatile_store32(volatile __int32 *, __int32);
void __iso_volatile_store64(volatile __int64 *, __int64);
void __iso_volatile_store8(volatile __int8 *, __int8);


void _mm_pause(void);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);

unsigned int _tzcnt_u32(unsigned int);
unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);
unsigned __int64 __umulh(unsigned __int64, unsigned __int64);

unsigned __int64 __cdecl _udiv128(unsigned __int64 _HighDividend, unsigned __int64 _LowDividend, unsigned __int64 _Divisor, unsigned __int64* _Remainder);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
double __ceil(double);
float __ceilf(float);
double __floor(double);
float __floorf(float);
double __round(double);
float __roundf(float);
double __trunc(double);
float __truncf(float);
double __copysign(double, double);
float __copysignf(float, float);
unsigned __signbitvalue(double);
unsigned __signbitvaluef(float);















constexpr void * __cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept;


#line 338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
#line 339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"








}
#line 349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
#pragma warning(pop) 
#line 351 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.inl.h"
#pragma external_header(pop)
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.h"
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin0.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {
extern "C" {
extern int __isa_available;
}

 constexpr int _Stl_isa_available_sse42 = 2; 
 constexpr int _Stl_isa_available_avx2  = 5; 

template <class _UInt>
constexpr int _Unsigned_integer_digits = sizeof(_UInt) * 8;




template <class _Ty>
[[nodiscard]] constexpr int _Countl_zero_fallback(_Ty _Val) noexcept {
    _Ty _Yx = 0;

    unsigned int _Nx = _Unsigned_integer_digits<_Ty>;
    unsigned int _Cx = _Unsigned_integer_digits<_Ty> / 2;
    do {
        _Yx = static_cast<_Ty>(_Val >> _Cx);
        if (_Yx != 0) {
            _Nx -= _Cx;
            _Val = _Yx;
        }
        _Cx >>= 1;
    } while (_Cx != 0);
    return static_cast<int>(_Nx) - static_cast<int>(_Val);
}





#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"



template <class _Ty>
[[nodiscard]] int _Countl_zero_lzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;

    if constexpr (_Digits <= 16) {
        return static_cast<int>(__lzcnt16(_Val) - (16 - _Digits));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__lzcnt(_Val));
    } else {









        return static_cast<int>(__lzcnt64(_Val));
#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    }
}

template <class _Ty>
[[nodiscard]] int _Countl_zero_bsr(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        if (!_BitScanReverse(&_Result, _Val)) {
            return _Digits;
        }
    } else {











        if (!_BitScanReverse64(&_Result, _Val)) {
            return _Digits;
        }
#line 110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    }
    return static_cast<int>(_Digits - 1 - _Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countl_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_lzcnt = __isa_available >= _Stl_isa_available_avx2;
    if (_Definitely_have_lzcnt) {
        return _Countl_zero_lzcnt(_Val);
    } else {
        return _Countl_zero_bsr(_Val);
    }
#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
}
#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"















#line 144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"




template <class _Ty>
[[nodiscard]] constexpr int _Countr_zero_fallback(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    return _Digits - _Countl_zero_fallback(static_cast<_Ty>(static_cast<_Ty>(~_Val) & static_cast<_Ty>(_Val - 1)));
}



template <class _Ty>
[[nodiscard]] constexpr int _Popcount_fallback(_Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;







#line 168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    {
        
        _Val = static_cast<_Ty>(_Val - ((_Val >> 1) & static_cast<_Ty>(0x5555'5555'5555'5555ull)));
        _Val = static_cast<_Ty>((_Val & static_cast<_Ty>(0x3333'3333'3333'3333ull))
                                + ((_Val >> 2) & static_cast<_Ty>(0x3333'3333'3333'3333ull)));
        _Val = static_cast<_Ty>((_Val + (_Val >> 4)) & static_cast<_Ty>(0x0F0F'0F0F'0F0F'0F0Full));
        
        _Val = static_cast<_Ty>(_Val * static_cast<_Ty>(0x0101'0101'0101'0101ull));
        
        return static_cast<int>(_Val >> (_Digits - 8));
    }
}





#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"








#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"

template <class _Ty>
[[nodiscard]] int _Countr_zero_tzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    constexpr _Ty _Max    = static_cast<_Ty>(-1); 

    if constexpr (_Digits <= 32) {
        
        
        
        return static_cast<int>(_tzcnt_u32(static_cast<unsigned int>(~_Max | _Val)));
    } else {









        return static_cast<int>(_tzcnt_u64(_Val));
#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    }
}




template <class _Ty>
[[nodiscard]] int _Countr_zero_bsf(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    constexpr _Ty _Max    = static_cast<_Ty>(-1); 

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        
        
        
        if (!_BitScanForward(&_Result, static_cast<unsigned int>(~_Max | _Val))) {
            return _Digits;
        }
    } else {













        if (!_BitScanForward64(&_Result, _Val)) {
            return _Digits;
        }
#line 256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    }
    return static_cast<int>(_Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countr_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_tzcnt = __isa_available >= _Stl_isa_available_avx2;
    if (_Definitely_have_tzcnt) {
        return _Countr_zero_tzcnt(_Val);
    } else {
        return _Countr_zero_bsf(_Val);
    }
#line 272 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
}

#line 275 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"





#line 281 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"

#line 283 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"


#line 286 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"


template <class _Ty>
[[nodiscard]] int _Unchecked_popcount(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    if constexpr (_Digits <= 16) {
        return static_cast<int>(__popcnt16(_Val));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__popcnt(_Val));
    } else {



        return static_cast<int>(__popcnt64(_Val));
#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    }
}

template <class _Ty>
[[nodiscard]] int _Checked_popcount(const _Ty _Val) noexcept {

    const bool _Definitely_have_popcnt = __isa_available >= _Stl_isa_available_sse42;
    if (!_Definitely_have_popcnt) {
        return _Popcount_fallback(_Val);
    }
#line 312 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    return _Unchecked_popcount(_Val);
}
#line 315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"

template <class _Ty>
constexpr bool _Is_standard_unsigned_integer =
    _Is_any_of_v<remove_cv_t<_Ty>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] inline int _Countr_zero(const _Ty _Val) noexcept {



#line 326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    {
        return _Checked_x86_x64_countr_zero(_Val);
    }
#line 330 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    return _Countr_zero_fallback(_Val);
}

template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_countr_zero_impl(_Fn _Callback) {
    













#line 350 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    
    return _Callback([](_Ty _Val)  { return _Countr_zero_fallback(_Val); });
}

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] inline int _Popcount(const _Ty _Val) noexcept {



#line 360 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    {
        return _Checked_popcount(_Val);
    }
#line 364 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    return _Popcount_fallback(_Val);
}

template <class _Ty, class _Fn>
inline decltype(auto) _Select_popcount_impl(_Fn _Callback) {
    



#line 374 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    {

        const bool _Definitely_have_popcnt = __isa_available >= _Stl_isa_available_sse42;
        if (!_Definitely_have_popcnt) {
            return _Callback([](_Ty _Val)  { return _Popcount_fallback(_Val); });
        }
#line 381 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
        return _Callback([](_Ty _Val)  { return _Unchecked_popcount(_Val); });
    }
#line 384 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
    return _Callback([](_Ty _Val)  { return _Popcount_fallback(_Val); });
}





} 



#pragma warning(pop)
#pragma pack(pop)
#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
#line 399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_bit_utils.hpp"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )



















#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"

#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"













































#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"




















#pragma detect_mismatch("annotate_string", "0")
#line 104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"

#pragma detect_mismatch("annotate_vector", "0")
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"













extern "C" {







} 








































#line 170 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"



#pragma warning(pop)
#pragma pack(pop)

#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"
#line 178 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_sanitizer_annotate_container.hpp"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdint"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdint.h"







#pragma once






#pragma warning(push)
#pragma warning(disable:   4514 4820 )

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdint.h"







































#pragma warning(pop) 

#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\stdint.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdint"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {
 using :: int8_t;
 using :: int16_t;
 using :: int32_t;
 using :: int64_t;
 using :: uint8_t;
 using :: uint16_t;
 using :: uint32_t;
 using :: uint64_t;

 using :: int_least8_t;
 using :: int_least16_t;
 using :: int_least32_t;
 using :: int_least64_t;
 using :: uint_least8_t;
 using :: uint_least16_t;
 using :: uint_least32_t;
 using :: uint_least64_t;

 using :: int_fast8_t;
 using :: int_fast16_t;
 using :: int_fast32_t;
 using :: int_fast64_t;
 using :: uint_fast8_t;
 using :: uint_fast16_t;
 using :: uint_fast32_t;
 using :: uint_fast64_t;

 using :: intmax_t;
 using :: intptr_t;
 using :: uintmax_t;
 using :: uintptr_t;


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 {
    using :: int8_t;
    using :: int16_t;
    using :: int32_t;
    using :: int64_t;
    using :: uint8_t;
    using :: uint16_t;
    using :: uint32_t;
    using :: uint64_t;

    using :: int_least8_t;
    using :: int_least16_t;
    using :: int_least32_t;
    using :: int_least64_t;
    using :: uint_least8_t;
    using :: uint_least16_t;
    using :: uint_least32_t;
    using :: uint_least64_t;

    using :: int_fast8_t;
    using :: int_fast16_t;
    using :: int_fast32_t;
    using :: int_fast64_t;
    using :: uint_fast8_t;
    using :: uint_fast16_t;
    using :: uint_fast32_t;
    using :: uint_fast64_t;

    using :: intmax_t;
    using :: intptr_t;
    using :: uintmax_t;
    using :: uintptr_t;
} 
#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdint"
} 



#pragma warning(pop)
#pragma pack(pop)

#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdint"
#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdint"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdlib"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\math.h"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"







#pragma once









    

















        
    #line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    
        
    

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

















    


        
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



    
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"














    
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    











        
    #line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    


        
    #line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    

#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
        
    

#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"




    
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    

#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
        
    

#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    


#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



    


#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"









    
#line 201 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"













    


        
    #line 219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 224 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 230 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    
#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    
        
    

#line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"








extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"










    
        
    #line 289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"








#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



















    

#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
        
    #line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    
#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


 
  

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
   
  #line 339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
 





#line 346 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


 

#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
   
 #line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"







    __declspec(dllimport) void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );
#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    
        

    













#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"












    


#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    


        


    #line 432 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"









    






        
    #line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 452 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    


        
    #line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"













#line 478 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"















#line 494 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"





    
#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 505 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    

#line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    


        


            
        #line 521 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    #line 522 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 527 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"





#line 533 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    


        



    #line 543 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 544 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    
        
    



#line 553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

    
        
              
        

#line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    



#line 575 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

    
        
    



#line 583 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

    
        
    



#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    
#line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 636 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"



    
#line 653 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        












        












        
















    














#line 827 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"












































































    













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
    #line 2070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"
#line 2071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt.h"

} __pragma(pack(pop))


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
    #line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"










#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"





#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"


    
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"




#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"






#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"





#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"












































































void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;
































extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {


#line 317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
        return _fdtest(&_X);
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
    }

      inline int fpclassify(  double _X) throw()
    {


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
        return _dtest(&_X);
#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
    }

      inline int fpclassify(  long double _X) throw()
    {


#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
        return _ldtest(&_X);
#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 495 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

      __declspec(dllimport) double    __cdecl acosh(  double _X);
      __declspec(dllimport) double    __cdecl asinh(  double _X);
      __declspec(dllimport) double    __cdecl atanh(  double _X);
      __declspec(dllimport)  double    __cdecl atof(  char const* _String);
      __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
      __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
      __declspec(dllimport) double    __cdecl cbrt(  double _X);
      __declspec(dllimport) double    __cdecl ceil(  double _X);
      __declspec(dllimport) double    __cdecl _chgsign(  double _X);
      __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl erf(  double _X);
      __declspec(dllimport) double    __cdecl erfc(  double _X);
      __declspec(dllimport) double    __cdecl exp2(  double _X);
      __declspec(dllimport) double    __cdecl expm1(  double _X);
      __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl floor(  double _X);
      __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
      __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
      __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
      __declspec(dllimport) int       __cdecl ilogb(  double _X);
      __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
      __declspec(dllimport) double    __cdecl lgamma(  double _X);
      __declspec(dllimport) long long __cdecl llrint(  double _X);
      __declspec(dllimport) long long __cdecl llround(  double _X);
      __declspec(dllimport) double    __cdecl log1p(  double _X);
      __declspec(dllimport) double    __cdecl log2(  double _X);
      __declspec(dllimport) double    __cdecl logb(  double _X);
      __declspec(dllimport) long      __cdecl lrint(  double _X);
      __declspec(dllimport) long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

      __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
      __declspec(dllimport) double __cdecl nan(  char const* _X);
      __declspec(dllimport) double __cdecl nearbyint(  double _X);
      __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
      __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
      __declspec(dllimport) double __cdecl rint(  double _X);
      __declspec(dllimport) double __cdecl round(  double _X);
      __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
      __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
      __declspec(dllimport) double __cdecl tgamma(  double _X);
      __declspec(dllimport) double __cdecl trunc(  double _X);
      __declspec(dllimport) double __cdecl _j0(  double _X );
      __declspec(dllimport) double __cdecl _j1(  double _X );
      __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
      __declspec(dllimport) double __cdecl _y0(  double _X);
      __declspec(dllimport) double __cdecl _y1(  double _X);
      __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

      __declspec(dllimport) float     __cdecl acoshf(  float _X);
      __declspec(dllimport) float     __cdecl asinhf(  float _X);
      __declspec(dllimport) float     __cdecl atanhf(  float _X);
      __declspec(dllimport) float     __cdecl cbrtf(  float _X);
      __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
      __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl erff(  float _X);
      __declspec(dllimport) float     __cdecl erfcf(  float _X);
      __declspec(dllimport) float     __cdecl expm1f(  float _X);
      __declspec(dllimport) float     __cdecl exp2f(  float _X);
      __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
      __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
      __declspec(dllimport) int       __cdecl ilogbf(  float _X);
      __declspec(dllimport) float     __cdecl lgammaf(  float _X);
      __declspec(dllimport) long long __cdecl llrintf(  float _X);
      __declspec(dllimport) long long __cdecl llroundf(  float _X);
      __declspec(dllimport) float     __cdecl log1pf(  float _X);
      __declspec(dllimport) float     __cdecl log2f(  float _X);
      __declspec(dllimport) float     __cdecl logbf(  float _X);
      __declspec(dllimport) long      __cdecl lrintf(  float _X);
      __declspec(dllimport) long      __cdecl lroundf(  float _X);
      __declspec(dllimport) float     __cdecl nanf(  char const* _X);
      __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
      __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
      __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
      __declspec(dllimport) float     __cdecl rintf(  float _X);
      __declspec(dllimport) float     __cdecl roundf(  float _X);
      __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
      __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
      __declspec(dllimport) float     __cdecl tgammaf(  float _X);
      __declspec(dllimport) float     __cdecl truncf(  float _X);

    



#line 622 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl _logbf(  float _X);
          __declspec(dllimport) float __cdecl _nextafterf(  float _X,   float _Y);
          __declspec(dllimport) int   __cdecl _finitef(  float _X);
          __declspec(dllimport) int   __cdecl _isnanf(  float _X);
          __declspec(dllimport) int   __cdecl _fpclassf(  float _X);

          __declspec(dllimport) int   __cdecl _set_FMA3_enable(  int _Flag);
          __declspec(dllimport) int   __cdecl _get_FMA3_enable(void);

    




#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"



    

          __declspec(dllimport) float __cdecl acosf(  float _X);
          __declspec(dllimport) float __cdecl asinf(  float _X);
          __declspec(dllimport) float __cdecl atan2f(  float _Y,   float _X);
          __declspec(dllimport) float __cdecl atanf(  float _X);
          __declspec(dllimport) float __cdecl ceilf(  float _X);
          __declspec(dllimport) float __cdecl cosf(  float _X);
          __declspec(dllimport) float __cdecl coshf(  float _X);
          __declspec(dllimport) float __cdecl expf(  float _X);

    









































#line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

    



#line 703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

    


#line 708 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl floorf(  float _X);
          __declspec(dllimport) float __cdecl fmodf(  float _X,   float _Y);

    











#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

          __declspec(dllimport) float  __cdecl log10f(  float _X);
          __declspec(dllimport) float  __cdecl logf(  float _X);
          __declspec(dllimport) float  __cdecl modff(  float _X,   float *_Y);
          __declspec(dllimport) float  __cdecl powf(  float _X,   float _Y);
          __declspec(dllimport) float  __cdecl sinf(  float _X);
          __declspec(dllimport) float  __cdecl sinhf(  float _X);
          __declspec(dllimport) float  __cdecl sqrtf(  float _X);
          __declspec(dllimport) float  __cdecl tanf(  float _X);
          __declspec(dllimport) float  __cdecl tanhf(  float _X);

    

















































#line 813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

      __declspec(dllimport) long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

      __declspec(dllimport) long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

      __declspec(dllimport) long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

      __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

      __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

      __declspec(dllimport) long double __cdecl erfl(  long double _X);
      __declspec(dllimport) long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

      __declspec(dllimport) long double __cdecl exp2l(  long double _X);
      __declspec(dllimport) long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

      __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

      __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
      __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

      __declspec(dllimport) int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

      __declspec(dllimport) long double __cdecl lgammal(  long double _X);
      __declspec(dllimport) long long __cdecl llrintl(  long double _X);
      __declspec(dllimport) long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

      __declspec(dllimport) long double __cdecl log1pl(  long double _X);
      __declspec(dllimport) long double __cdecl log2l(  long double _X);
      __declspec(dllimport) long double __cdecl logbl(  long double _X);
      __declspec(dllimport) long __cdecl lrintl(  long double _X);
      __declspec(dllimport) long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

      __declspec(dllimport) long double __cdecl nanl(  char const* _X);
      __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
      __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

      __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
      __declspec(dllimport) long double __cdecl rintl(  long double _X);
      __declspec(dllimport) long double __cdecl roundl(  long double _X);
      __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
      __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

      __declspec(dllimport) long double __cdecl tgammal(  long double _X);
      __declspec(dllimport) long double __cdecl truncl(  long double _X);

    



#line 1001 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 1019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    #line 1027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

#line 1029 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#line 1034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_math.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\math.h"




#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdlib"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_malloc.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





































#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_malloc.h"

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
      __declspec(guard(overflow)) size_t _Count,
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
      __declspec(guard(overflow)) size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize_base(
      void* _Block
    ) noexcept;

 
__declspec(dllimport) 
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );


















#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_search.h"










#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stddef.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stddef.h"









#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stddef.h"
    
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stddef.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_search.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_search.h"



 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                   void const*   _Key,
      void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                size_t        _SizeOfElements,
                                      _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                                void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                   void const*   _Key,
      void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


































     
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

     
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

     
    __declspec(dllimport) double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) double __cdecl _wtof(
          wchar_t const* _String
        );

     
    __declspec(dllimport) double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) int __cdecl _wtoi(
          wchar_t const* _String
        );

     
    __declspec(dllimport) int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl _wtol(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

         
        __declspec(dllimport) int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"


#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );













    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"


    
    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"












#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning(pop)






__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);



#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"
        
    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

    


        
    #line 841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"



 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 923 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"




















 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




 
__declspec(dllimport) errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );

#line 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"




__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"







    
    
#line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"









      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

    


#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
          char const* _Command
        );

    
    
    #pragma warning(push)
    #pragma warning(disable: 6540)

     
    __declspec(dllimport) int __cdecl _putenv(
          char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning(pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"









    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdlib.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdlib"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )






[[nodiscard]]   inline double abs(  double _Xx) noexcept  {
    return :: fabs(_Xx);
}

[[nodiscard]]   inline float abs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline long double abs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}


 namespace std {
 using :: size_t;
 using :: div_t;
 using :: ldiv_t;
 using :: abort;
 using :: abs;
 using :: atexit;
 using :: atof;
 using :: atoi;
 using :: atol;
 using :: bsearch;
 using :: calloc;
 using :: div;
 using :: exit;
 using :: free;
 using :: labs;
 using :: ldiv;
 using :: malloc;
 using :: mblen;
 using :: mbstowcs;
 using :: mbtowc;
 using :: qsort;
 using :: rand;
 using :: realloc;
 using :: srand;
 using :: strtod;
 using :: strtol;
 using :: strtoul;
 using :: wcstombs;
 using :: wctomb;

 using :: lldiv_t;

 using :: getenv;
 using :: system;

 using :: atoll;
 using :: llabs;
 using :: lldiv;
 using :: strtof;
 using :: strtold;
 using :: strtoll;
 using :: strtoull;

 using :: _Exit;
 using :: at_quick_exit;
 using :: quick_exit;
} 



#pragma warning(pop)
#pragma pack(pop)

#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdlib"
#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdlib"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cfloat"









#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"








#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"
    #line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"



















    






        
    #line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"
























































































































































#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"

    

#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141) 

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);















__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );












 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);


      __declspec(dllimport) float __cdecl _scalbf(  float _X,   long _Y);
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"










    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\float.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cfloat"
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cfloat"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cwchar"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdio"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"




#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
    
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"


    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"














    








#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"




#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
    #line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"






#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"


    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"



#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_stdio_config.h"




















} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
    __declspec(dllimport) wint_t __cdecl getwc(
          FILE* _Stream
        );

     
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
     
    __declspec(dllimport) wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __declspec(dllimport) wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
    __declspec(dllimport) FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
    __declspec(dllimport) FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
        __declspec(dllimport) FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 931 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 1283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1719 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"


    
        
        
        #pragma warning(push)
        #pragma warning(disable: 4141 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    




#line 1863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 1949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1995 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    #line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

    


#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstdio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {































    
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"















    
    
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    
    
    
    
    
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
         
        __declspec(dllimport) errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                     char const* _FileName,
                                     char const* _Mode
            );

        
         
        __declspec(dllimport) size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
        __declspec(dllimport) char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fclose(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

     
    __declspec(dllimport) FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
    __declspec(dllimport) int __cdecl feof(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl ferror(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fgetc(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

     
    
    __declspec(dllimport) int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
    __declspec(dllimport) char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl _fileno(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
    __declspec(dllimport) int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
          int _Character
        );

     
    
    __declspec(dllimport) int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
    __declspec(dllimport) int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
    __declspec(dllimport) int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
    __declspec(dllimport) int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
    __declspec(dllimport) long __cdecl ftell(
          FILE* _Stream
        );

     
     
    __declspec(dllimport) __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
    __declspec(dllimport) int __cdecl getc(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl getchar(void);

     
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) int __cdecl _getw(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
        __declspec(dllimport) int __cdecl _pclose(
              FILE* _Stream
            );

         
        __declspec(dllimport) FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
          int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
          char const* _Buffer
        );

     
    
    __declspec(dllimport) int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

    #line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
    __declspec(dllimport) int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#line 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    
    
    
    
    
    __declspec(dllimport) void __cdecl _lock_file(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
    __declspec(dllimport) long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    














#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"



    
    

#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
          int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"


    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"



    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    








#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 1834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    








#line 1916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 2057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable: 6530) 

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

            _Result = vsscanf_s(_Buffer, _Format, _ArgList);

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #line 2299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 6530) 

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
#line 2442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\stdio.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdio"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )













 namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: size_t;
 using :: fpos_t;
 using :: FILE;
 using :: clearerr;
 using :: fclose;
 using :: feof;
 using :: ferror;
 using :: fflush;
 using :: fgetc;
 using :: fgetpos;
 using :: fgets;
 using :: fopen;
 using :: fprintf;
 using :: fputc;
 using :: fputs;
 using :: fread;
 using :: freopen;
 using :: fscanf;
 using :: fseek;
 using :: fsetpos;
 using :: ftell;
 using :: fwrite;
 using :: getc;
 using :: getchar;
 using :: perror;
 using :: putc;
 using :: putchar;
 using :: printf;
 using :: puts;
 using :: remove;
 using :: rename;
 using :: rewind;
 using :: scanf;
 using :: setbuf;
 using :: setvbuf;
 using :: sprintf;
 using :: sscanf;
 using :: tmpfile;
 using :: tmpnam;
 using :: ungetc;
 using :: vfprintf;
 using :: vprintf;
 using :: vsprintf;

 using :: snprintf;
 using :: vsnprintf;
 using :: vfscanf;
 using :: vscanf;
 using :: vsscanf;

#pragma warning(pop)
} 



#pragma warning(pop)
#pragma pack(pop)

#line 94 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdio"
#line 95 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstdio"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cwchar"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"









#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\errno.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\errno.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\errno.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )



__pragma(pack(push, 8)) extern "C" {



[[nodiscard]]  
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

[[nodiscard]]  
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

[[nodiscard]]  
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

[[nodiscard]]  
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

[[nodiscard]]    
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

[[nodiscard]]  

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]  
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]    

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_string.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memcpy_s.h"




#pragma warning(pop) 
} __pragma(pack(pop))
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_l(_Format, 0, _ArgList);
    }
#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vcwscanf_l(_Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

#line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wconio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {











    

#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"
        
    #line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"





















  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"


















































































#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wdirect.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wio.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_share.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )











    
    
    
    
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_share.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {










    
    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wio.h"

 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wio.h"

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wio.h"

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wprocess.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wprocess.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"











#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
    
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"
        



    #line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"



 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 436 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"









    


#line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wstring.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"









    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_wtime.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\stat.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\types.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )



    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\types.h"
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\types.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\types.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\types.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\stat.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\stat.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\sys\\stat.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"



#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"












#pragma once








#pragma warning(push)
#pragma warning(disable:   4514 4820 )


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"







#pragma once












#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {
























#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"

    typedef struct __declspec(align(16)) _SETJMP_FLOAT128
    {
        unsigned __int64 Part[2];
    } SETJMP_FLOAT128;

    
    typedef SETJMP_FLOAT128 _JBTYPE;

    typedef struct _JUMP_BUFFER
    {
        unsigned __int64 Frame;
        unsigned __int64 Rbx;
        unsigned __int64 Rsp;
        unsigned __int64 Rbp;
        unsigned __int64 Rsi;
        unsigned __int64 Rdi;
        unsigned __int64 R12;
        unsigned __int64 R13;
        unsigned __int64 R14;
        unsigned __int64 R15;
        unsigned __int64 Rip;
        unsigned long MxCsr;
        unsigned short FpCsr;
        unsigned short Spare;

        SETJMP_FLOAT128 Xmm6;
        SETJMP_FLOAT128 Xmm7;
        SETJMP_FLOAT128 Xmm8;
        SETJMP_FLOAT128 Xmm9;
        SETJMP_FLOAT128 Xmm10;
        SETJMP_FLOAT128 Xmm11;
        SETJMP_FLOAT128 Xmm12;
        SETJMP_FLOAT128 Xmm13;
        SETJMP_FLOAT128 Xmm14;
        SETJMP_FLOAT128 Xmm15;
    } _JUMP_BUFFER;






















































#line 142 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"





    
    typedef _JBTYPE jmp_buf[16];
#line 150 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"




    
#line 156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"




int __cdecl _setjmp(
      jmp_buf _Buf
    );


    __declspec(noreturn) void __cdecl longjmp(
          jmp_buf _Buf,
          int     _Value
        ) noexcept(false);





#line 175 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\setjmp.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"



#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"



    
        #pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"











#pragma once



#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"



#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"







#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"












#pragma once



#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"



#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"







#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"













#pragma once



#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"



#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"







#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"













#pragma once



#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"



#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"







#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"






#pragma once



#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"



#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"







#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"












#pragma once



#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"



#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"







#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
















#pragma once



#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"



#line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"







#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"























#pragma once



#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"



#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"







#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"










#pragma once






#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"



#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"



#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"


extern "C" { 


#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;









































































































































#line 184 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"


}; 
#line 188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"

#line 190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"
#line 191 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"
#line 192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\mmintrin.h"
#pragma external_header(pop)
#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





    


#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"













typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;






   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"

    
          __declspec(dllimport) int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    
        
    

#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"

    static_assert((sizeof(unsigned int) <= 16), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE");


    #pragma warning(push)
    #pragma warning(disable: 6540) 
                                   

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"






    
        
        




    #line 126 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"












#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"




#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014) 
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            





        }
    }
    #pragma warning(pop)

#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"




    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\malloc.h"
#pragma external_header(pop)
#line 80 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 

























#line 133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"























































 
 
 


extern "C" { 
  
#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"




#pragma warning(push)
#pragma warning(disable: 28251)





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern float _mm_cvtss_f32(__m128 _A);








#line 293 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"





extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#line 302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);



















#line 337 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);

extern void _m_prefetchit0(const void *);
extern void _m_prefetchit1(const void *);
#line 362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"


#line 365 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);
























#line 396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"







 
 
 





















































































































#line 524 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"

#pragma warning(pop) 


}; 
#line 530 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"

#line 532 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
#line 533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
#line 534 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmmintrin.h"
#pragma external_header(pop)
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"




#pragma warning(push)
#pragma warning(disable: 28251)





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);





#line 168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);










extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);


#line 228 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);


#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);


#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);

extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);

extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);







#line 352 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1,__int64 _I0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);


#line 363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);


#line 371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);



#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);






extern __int64 _mm_cvtsd_si64(__m128d);
extern __int64 _mm_cvttsd_si64(__m128d);
extern __m128d _mm_cvtsi64_sd(__m128d, __int64);
extern __m128i _mm_cvtsi64_si128(__int64);
extern __int64 _mm_cvtsi128_si64(__m128i);


#line 443 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"

#pragma warning(pop) 


}; 
#line 449 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"

#line 451 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
#line 452 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
#line 453 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\emmintrin.h"
#pragma external_header(pop)
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"

 
 
 














 
 
 


extern "C" { 
  
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );





extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );




extern __m128i _mm_lddqu_si128(__m128i const * );







extern void _mm_monitor(void const * , unsigned , unsigned );




extern void _mm_mwait(unsigned , unsigned );


}; 
#line 103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"

#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"
#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\pmmintrin.h"
#pragma external_header(pop)
#line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"









extern "C" {
#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    
    
    
    
    

    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);





#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    
    
    
    
    
    

    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);





#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    
    
    
    
    
    
    

    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);



#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);



#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);



#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);





#line 118 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);



#line 127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);





#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"


};
#line 144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"

#line 146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
#line 147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
#line 148 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\tmmintrin.h"
#pragma external_header(pop)
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"


















































extern "C" {
#line 85 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128, __m128, const int );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128 );

        
        

        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );

        
        

        extern __m128  _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);

        

        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);

        
        

        extern __m128i _mm_mullo_epi32(__m128i, __m128i);

        
        

        extern __m128i _mm_mul_epi32(__m128i, __m128i);

        
        

        extern int _mm_testz_si128(__m128i , __m128i );

        
        

        extern int _mm_testc_si128(__m128i , __m128i );

        
        
        

        extern int _mm_testnzc_si128(__m128i , __m128i );

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );

        




        
        

        extern int _mm_extract_ps(__m128 , const int );

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );


        extern __m128i _mm_insert_epi64(__m128i , __int64 , const int );
#line 194 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i , const int );
        extern int   _mm_extract_epi32(__m128i , const int );


        extern __int64 _mm_extract_epi64(__m128i , const int );
#line 203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i);

        

        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );

        

        extern __m128  _mm_round_ps(__m128  , int );
        extern __m128  _mm_round_ss(__m128 , __m128  , int );

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);


        
        

        extern __m128i _mm_packus_epi32(__m128i, __m128i);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );

        





#line 256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
        extern __m128i _mm_stream_load_si128(const __m128i*);
#line 258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"


}; 
#line 262 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"

#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
#line 265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
#line 266 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\smmintrin.h"
#pragma external_header(pop)
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"



extern "C" {
#line 38 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int     _mm_cmpistri (__m128i , __m128i , const int );

    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestri (__m128i , int , __m128i , int , const int );





    extern int     _mm_cmpistrz (__m128i , __m128i , const int );
    extern int     _mm_cmpistrc (__m128i , __m128i , const int );
    extern int     _mm_cmpistrs (__m128i , __m128i , const int );
    extern int     _mm_cmpistro (__m128i , __m128i , const int );
    extern int     _mm_cmpistra (__m128i , __m128i , const int );

    extern int     _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestra (__m128i , int , __m128i , int , const int );






    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );





    extern int _mm_popcnt_u32(unsigned int );


    extern __int64 _mm_popcnt_u64(unsigned __int64 );
#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );


    extern unsigned __int64 _mm_crc32_u64(unsigned __int64 , unsigned __int64 );
#line 133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"


}; 
#line 137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"

#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"
#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"
#line 141 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\nmmintrin.h"
#pragma external_header(pop)
#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"



extern "C" {
#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i , __m128i );





extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );





extern __m128i _mm_aesenc_si128(__m128i , __m128i );





extern __m128i _mm_aesenclast_si128(__m128i , __m128i );





extern __m128i _mm_aesimc_si128(__m128i );






extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );







extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );



}; 
#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"

#line 90 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"
#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"
#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\wmmintrin.h"
#pragma external_header(pop)
#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern "C" {
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;
















































extern unsigned long long __isa_inverted;
extern unsigned __avx10_version;

inline bool __check_isa_support(unsigned __x, unsigned __v = 0)


#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
{ return ((__x & __isa_inverted) == 0) && ((unsigned char)__avx10_version >= __v); }




inline bool


#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
__check_isa_avx10_512(unsigned __v) { return (__avx10_version >= (__v | 0x00040000)); }



extern unsigned __arch_inverted(void);
extern unsigned __arch_avx10ver(void);

inline bool __check_arch_support(unsigned __x, unsigned __v = 0)


#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
{ return ((__x & __arch_inverted()) == 0) && (__arch_avx10ver() >= __v); }





#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


inline unsigned _get_vlen(void)


#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
{
    unsigned arch_inverted = __arch_inverted();
    if ((arch_inverted & 0x00000004) == 0)
        return 512;
    else if ((arch_inverted & 0x00000002) == 0)
        return 256;
    else if ((arch_inverted & 0x00000001) == 0)
        return 128;
    else
        return 0;
}
#line 157 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"











extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);





extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);





extern int __cdecl _mm_comi_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);



























#line 676 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"








extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);

extern void __cdecl _xsave64(void *, unsigned __int64);
#line 1324 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);

extern void __cdecl _xsaveopt64(void *, unsigned __int64);
#line 1334 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"





extern void __cdecl _xsavec(void *, unsigned __int64);

extern void __cdecl _xsavec64(void *, unsigned __int64);
#line 1343 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);

extern void __cdecl _xrstor64(void const *, unsigned __int64);
#line 1353 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"






extern void __cdecl _xsaves(void *, unsigned __int64);

extern void __cdecl _xsaves64(void *, unsigned __int64);
#line 1363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"






extern void __cdecl _xrstors(void const *, unsigned __int64);

extern void __cdecl _xrstors64(void const *, unsigned __int64);
#line 1373 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);

extern void __cdecl _fxsave64(void *);
#line 1382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);

extern void __cdecl _fxrstor64(void const *);
#line 1391 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);

extern int __cdecl _rdrand64_step(unsigned __int64 *);
#line 1403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"





extern unsigned int     __cdecl _readfsbase_u32(void);
extern unsigned int     __cdecl _readgsbase_u32(void);
extern unsigned __int64 __cdecl _readfsbase_u64(void);
extern unsigned __int64 __cdecl _readgsbase_u64(void);




extern void __cdecl _writefsbase_u32(unsigned int);
extern void __cdecl _writegsbase_u32(unsigned int);
extern void __cdecl _writefsbase_u64(unsigned __int64);
extern void __cdecl _writegsbase_u64(unsigned __int64);
#line 1421 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);




extern float  __cdecl __fmadd_ss(float, float, float);
extern double __cdecl __fmadd_sd(double, double, double);
extern float  __cdecl __fmsub_ss(float, float, float);
extern double __cdecl __fmsub_sd(double, double, double);
extern float  __cdecl __fnmadd_ss(float, float, float);
extern double __cdecl __fnmadd_sd(double, double, double);
extern float  __cdecl __fnmsub_ss(float, float, float);
extern double __cdecl __fnmsub_sd(double, double, double);




extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);


extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
















extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _bextr2_u32(unsigned int ,
                                    unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );


extern unsigned __int64 _bextr_u64(unsigned __int64 ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned __int64 _bextr2_u64(unsigned __int64 ,
                                    unsigned __int64 );
extern unsigned __int64 _blsi_u64(unsigned __int64);
extern unsigned __int64 _blsmsk_u64(unsigned __int64);
extern unsigned __int64 _blsr_u64(unsigned __int64);
extern unsigned __int64 _bzhi_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _mulx_u64(unsigned __int64 ,
                                  unsigned __int64 ,
                                  unsigned __int64 * );
extern unsigned __int64 _pdep_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _pext_u64(unsigned __int64 ,
                                  unsigned __int64 );
extern unsigned __int64 _rorx_u64(unsigned __int64 ,
                                  const unsigned int );
extern __int64          _sarx_i64(__int64 ,
                                  unsigned int );
extern unsigned __int64 _shlx_u64(unsigned __int64 ,
                                  unsigned int );
extern unsigned __int64 _shrx_u64(unsigned __int64 ,
                                          unsigned int );
#line 1969 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);

extern unsigned __int64 _lzcnt_u64(unsigned __int64);
#line 1981 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"








extern unsigned __int16 _tzcnt_u16(unsigned __int16);
extern unsigned int     _tzcnt_u32(unsigned int);

extern unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 1994 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);


extern void _Store64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchange64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedExchangeAdd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedExchangeAdd64_HLERelease(__int64 volatile *,__int64);

extern __int64 _InterlockedAnd64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedAnd64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedOr64_HLERelease(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLEAcquire(__int64 volatile *,__int64);
extern __int64 _InterlockedXor64_HLERelease(__int64 volatile *,__int64);

extern unsigned char _interlockedbittestandset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandset64_HLERelease(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLEAcquire(__int64 *,__int64);
extern unsigned char _interlockedbittestandreset64_HLERelease(__int64 *,__int64);
#line 2053 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);

extern int __cdecl _rdseed64_step(unsigned __int64 *);
#line 2081 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"










extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );



extern unsigned char __cdecl _addcarryx_u64(unsigned char ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 ,
                                                   unsigned __int64 * );
#line 2103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"





extern unsigned short   __cdecl _load_be_u16(void const*);
extern unsigned int     __cdecl _load_be_u32(void const*);
extern unsigned __int64 __cdecl _load_be_u64(void const*);







extern void __cdecl _store_be_u16(void *, unsigned short);
extern void __cdecl _store_be_u32(void *, unsigned int);
extern void __cdecl _store_be_u64(void *, unsigned __int64);







extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int);

extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);




extern void * __cdecl _bnd_set_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t);
extern void * __cdecl _bnd_copy_ptr_bounds(const void *, const void *);
extern void * __cdecl _bnd_init_ptr_bounds(const void *);
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *);
extern void __cdecl _bnd_chk_ptr_lbounds(const void *);
extern void __cdecl _bnd_chk_ptr_ubounds(const void *);
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_load_ptr_bounds(const void **, const void *);
extern const void * __cdecl _bnd_get_ptr_lbound(const void *);
extern const void * __cdecl _bnd_get_ptr_ubound(const void *);


extern __m256i __cdecl _mm256_insert_epi8 (__m256i , int , const int );
extern __m256i __cdecl _mm256_insert_epi16(__m256i , int , const int );
extern __m256i __cdecl _mm256_insert_epi32(__m256i , int , const int );

extern __m256i __cdecl _mm256_insert_epi64(__m256i , __int64 , const int );
#line 2159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern int __cdecl _mm256_extract_epi8 (__m256i , const int );
extern int __cdecl _mm256_extract_epi16(__m256i , const int );
extern int __cdecl _mm256_extract_epi32(__m256i , const int );

extern __int64 __cdecl _mm256_extract_epi64(__m256i , const int );
#line 2167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern __m256d __cdecl _mm256_zextpd128_pd256(__m128d);
extern __m256  __cdecl _mm256_zextps128_ps256(__m128);
extern __m256i __cdecl _mm256_zextsi128_si256(__m128i);


extern unsigned int __cdecl _rdpid_u32(void);

extern void         __cdecl _ptwrite32(unsigned int);

extern void         __cdecl _ptwrite64(unsigned __int64);
#line 2180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern __m128i __cdecl _mm_dpbusd_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusd_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbusds_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusds_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwssd_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssd_avx_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwssds_avx_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssds_avx_epi32(__m256i, __m256i, __m256i);


extern unsigned int __cdecl _pconfig_u32(const int, size_t __data[]);
extern void __cdecl _wbnoinvd(void);


extern unsigned int __cdecl _encls_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclu_u32(const int, size_t __data[]);
extern unsigned int __cdecl _enclv_u32(const int, size_t __data[]);




extern unsigned __int64 __cdecl _udiv128(unsigned __int64 , unsigned __int64 , unsigned __int64 , unsigned __int64* );
extern __int64          __cdecl _div128(__int64 , __int64 , __int64 , __int64* );
#line 2206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern unsigned         __cdecl _udiv64(unsigned __int64 , unsigned , unsigned* );
extern int              __cdecl _div64(__int64 , int , int* );


extern unsigned char _mm_aesdec128kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesdec256kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesdecwide128kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned char _mm_aesdecwide256kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned char _mm_aesenc128kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesenc256kl_u8(__m128i* , __m128i , const void* );
extern unsigned char _mm_aesencwide128kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned char _mm_aesencwide256kl_u8(__m128i* , const __m128i* , const void* );
extern unsigned int  _mm_encodekey128_u32(unsigned int , __m128i , void* );
extern unsigned int  _mm_encodekey256_u32(unsigned int , __m128i , __m128i , void* );
extern void          _mm_loadiwkey(unsigned int , __m128i , __m128i , __m128i );


extern unsigned int     __cdecl _rdpkru_u32(void);
extern void             __cdecl _wrpkru(unsigned int);


extern int              __cdecl _enqcmd(void * , const void * );
extern int              __cdecl _enqcmds(void * , const void * );




extern void             __cdecl _incsspd (unsigned int);
extern unsigned int     __cdecl _rdsspd (void);
extern void             __cdecl _saveprevssp (void);
extern void             __cdecl _rstorssp (void *);
extern void             __cdecl _wrssd (unsigned int, void *);
extern void             __cdecl _wrussd (unsigned int, void *);
extern void             __cdecl _setssbsy (void);
extern void             __cdecl _clrssbsy (void *);
extern void *           __cdecl _switchssp(void *);

extern void             __cdecl _incsspq (unsigned __int64);
extern unsigned __int64 __cdecl _rdsspq (void);
extern void             __cdecl _wrssq (unsigned __int64, void *);
extern void             __cdecl _wrussq(unsigned __int64, void *);
#line 2248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"






extern __m128i _mm_div_epi8(__m128i, __m128i);
extern __m128i _mm_div_epi16(__m128i, __m128i);
extern __m128i _mm_div_epi32(__m128i, __m128i);
extern __m128i _mm_div_epi64(__m128i, __m128i);
extern __m128i _mm_div_epu8(__m128i, __m128i);
extern __m128i _mm_div_epu16(__m128i, __m128i);
extern __m128i _mm_div_epu32(__m128i, __m128i);
extern __m128i _mm_div_epu64(__m128i, __m128i);
extern __m128i _mm_rem_epi8(__m128i, __m128i);
extern __m128i _mm_rem_epi16(__m128i, __m128i);
extern __m128i _mm_rem_epi32(__m128i, __m128i);
extern __m128i _mm_rem_epi64(__m128i, __m128i);
extern __m128i _mm_rem_epu8(__m128i, __m128i);
extern __m128i _mm_rem_epu16(__m128i, __m128i);
extern __m128i _mm_rem_epu32(__m128i, __m128i);
extern __m128i _mm_rem_epu64(__m128i, __m128i);
extern __m256i _mm256_div_epi8(__m256i, __m256i);
extern __m256i _mm256_div_epi16(__m256i, __m256i);
extern __m256i _mm256_div_epi32(__m256i, __m256i);
extern __m256i _mm256_div_epi64(__m256i, __m256i);
extern __m256i _mm256_div_epu8(__m256i, __m256i);
extern __m256i _mm256_div_epu16(__m256i, __m256i);
extern __m256i _mm256_div_epu32(__m256i, __m256i);
extern __m256i _mm256_div_epu64(__m256i, __m256i);
extern __m256i _mm256_rem_epi8(__m256i, __m256i);
extern __m256i _mm256_rem_epi16(__m256i, __m256i);
extern __m256i _mm256_rem_epi32(__m256i, __m256i);
extern __m256i _mm256_rem_epi64(__m256i, __m256i);
extern __m256i _mm256_rem_epu8(__m256i, __m256i);
extern __m256i _mm256_rem_epu16(__m256i, __m256i);
extern __m256i _mm256_rem_epu32(__m256i, __m256i);
extern __m256i _mm256_rem_epu64(__m256i, __m256i);










extern __m128i _mm_divrem_epi32(__m128i * , __m128i, __m128i);
extern __m128i _mm_divrem_epu32(__m128i * , __m128i, __m128i);
extern __m256i _mm256_divrem_epi32(__m256i * , __m256i, __m256i);
extern __m256i _mm256_divrem_epu32(__m256i * , __m256i, __m256i);







extern __m128  _mm_sin_ps(__m128);
extern __m128d _mm_sin_pd(__m128d);
extern __m256  _mm256_sin_ps(__m256);
extern __m256d _mm256_sin_pd(__m256d);
extern __m128  _mm_cos_ps(__m128);
extern __m128d _mm_cos_pd(__m128d);
extern __m256  _mm256_cos_ps(__m256);
extern __m256d _mm256_cos_pd(__m256d);
extern __m128  _mm_sincos_ps(__m128  * , __m128);
extern __m128d _mm_sincos_pd(__m128d * , __m128d);
extern __m256  _mm256_sincos_ps(__m256  * , __m256);
extern __m256d _mm256_sincos_pd(__m256d * , __m256d);
extern __m128  _mm_tan_ps(__m128);
extern __m128d _mm_tan_pd(__m128d);
extern __m256  _mm256_tan_ps(__m256);
extern __m256d _mm256_tan_pd(__m256d);
extern __m128  _mm_asin_ps(__m128);
extern __m128d _mm_asin_pd(__m128d);
extern __m256  _mm256_asin_ps(__m256);
extern __m256d _mm256_asin_pd(__m256d);
extern __m128  _mm_acos_ps(__m128);
extern __m128d _mm_acos_pd(__m128d);
extern __m256  _mm256_acos_ps(__m256);
extern __m256d _mm256_acos_pd(__m256d);
extern __m128  _mm_atan_ps(__m128);
extern __m128d _mm_atan_pd(__m128d);
extern __m256  _mm256_atan_ps(__m256);
extern __m256d _mm256_atan_pd(__m256d);
extern __m128  _mm_atan2_ps(__m128, __m128);
extern __m128d _mm_atan2_pd(__m128d, __m128d);
extern __m256  _mm256_atan2_ps(__m256, __m256);
extern __m256d _mm256_atan2_pd(__m256d, __m256d);
extern __m128  _mm_sind_ps(__m128);
extern __m128d _mm_sind_pd(__m128d);
extern __m256  _mm256_sind_ps(__m256);
extern __m256d _mm256_sind_pd(__m256d);
extern __m128  _mm_cosd_ps(__m128);
extern __m128d _mm_cosd_pd(__m128d);
extern __m256  _mm256_cosd_ps(__m256);
extern __m256d _mm256_cosd_pd(__m256d);
extern __m128  _mm_tand_ps(__m128);
extern __m128d _mm_tand_pd(__m128d);
extern __m256  _mm256_tand_ps(__m256);
extern __m256d _mm256_tand_pd(__m256d);
extern __m128  _mm_sinh_ps(__m128);
extern __m128d _mm_sinh_pd(__m128d);
extern __m256  _mm256_sinh_ps(__m256);
extern __m256d _mm256_sinh_pd(__m256d);
extern __m128  _mm_cosh_ps(__m128);
extern __m128d _mm_cosh_pd(__m128d);
extern __m256  _mm256_cosh_ps(__m256);
extern __m256d _mm256_cosh_pd(__m256d);
extern __m128  _mm_tanh_ps(__m128);
extern __m128d _mm_tanh_pd(__m128d);
extern __m256  _mm256_tanh_ps(__m256);
extern __m256d _mm256_tanh_pd(__m256d);
extern __m128  _mm_asinh_ps(__m128);
extern __m128d _mm_asinh_pd(__m128d);
extern __m256  _mm256_asinh_ps(__m256);
extern __m256d _mm256_asinh_pd(__m256d);
extern __m128  _mm_acosh_ps(__m128);
extern __m128d _mm_acosh_pd(__m128d);
extern __m256  _mm256_acosh_ps(__m256);
extern __m256d _mm256_acosh_pd(__m256d);
extern __m128  _mm_atanh_ps(__m128);
extern __m128d _mm_atanh_pd(__m128d);
extern __m256  _mm256_atanh_ps(__m256);
extern __m256d _mm256_atanh_pd(__m256d);
extern __m128  _mm_log_ps(__m128);
extern __m128d _mm_log_pd(__m128d);
extern __m256  _mm256_log_ps(__m256);
extern __m256d _mm256_log_pd(__m256d);
extern __m128  _mm_log1p_ps(__m128);
extern __m128d _mm_log1p_pd(__m128d);
extern __m256  _mm256_log1p_ps(__m256);
extern __m256d _mm256_log1p_pd(__m256d);
extern __m128  _mm_log10_ps(__m128);
extern __m128d _mm_log10_pd(__m128d);
extern __m256  _mm256_log10_ps(__m256);
extern __m256d _mm256_log10_pd(__m256d);
extern __m128  _mm_log2_ps(__m128);
extern __m128d _mm_log2_pd(__m128d);
extern __m256  _mm256_log2_ps(__m256);
extern __m256d _mm256_log2_pd(__m256d);
extern __m128  _mm_logb_ps(__m128);
extern __m128d _mm_logb_pd(__m128d);
extern __m256  _mm256_logb_ps(__m256);
extern __m256d _mm256_logb_pd(__m256d);
extern __m128  _mm_exp_ps(__m128);
extern __m128d _mm_exp_pd(__m128d);
extern __m256  _mm256_exp_ps(__m256);
extern __m256d _mm256_exp_pd(__m256d);
extern __m128  _mm_exp10_ps(__m128);
extern __m128d _mm_exp10_pd(__m128d);
extern __m256  _mm256_exp10_ps(__m256);
extern __m256d _mm256_exp10_pd(__m256d);
extern __m128  _mm_exp2_ps(__m128);
extern __m128d _mm_exp2_pd(__m128d);
extern __m256  _mm256_exp2_ps(__m256);
extern __m256d _mm256_exp2_pd(__m256d);
extern __m128  _mm_expm1_ps(__m128);
extern __m128d _mm_expm1_pd(__m128d);
extern __m256  _mm256_expm1_ps(__m256);
extern __m256d _mm256_expm1_pd(__m256d);
extern __m128  _mm_pow_ps(__m128, __m128);
extern __m128d _mm_pow_pd(__m128d, __m128d);
extern __m256  _mm256_pow_ps(__m256, __m256);
extern __m256d _mm256_pow_pd(__m256d, __m256d);
extern __m128  _mm_trunc_ps(__m128);
extern __m128d _mm_trunc_pd(__m128d);
extern __m256  _mm256_trunc_ps(__m256);
extern __m256d _mm256_trunc_pd(__m256d);
extern __m128  _mm_svml_floor_ps(__m128);
extern __m128d _mm_svml_floor_pd(__m128d);
extern __m256  _mm256_svml_floor_ps(__m256);
extern __m256d _mm256_svml_floor_pd(__m256d);
extern __m128  _mm_svml_ceil_ps(__m128);
extern __m128d _mm_svml_ceil_pd(__m128d);
extern __m256  _mm256_svml_ceil_ps(__m256);
extern __m256d _mm256_svml_ceil_pd(__m256d);
extern __m128  _mm_svml_round_ps(__m128);
extern __m128d _mm_svml_round_pd(__m128d);
extern __m256  _mm256_svml_round_ps(__m256);
extern __m256d _mm256_svml_round_pd(__m256d);
extern __m128  _mm_fmod_ps(__m128, __m128);
extern __m128d _mm_fmod_pd(__m128d, __m128d);
extern __m256  _mm256_fmod_ps(__m256, __m256);
extern __m256d _mm256_fmod_pd(__m256d, __m256d);
extern __m128  _mm_svml_sqrt_ps(__m128);
extern __m128d _mm_svml_sqrt_pd(__m128d);
extern __m256  _mm256_svml_sqrt_ps(__m256);
extern __m256d _mm256_svml_sqrt_pd(__m256d);
extern __m128  _mm_invsqrt_ps(__m128);
extern __m128d _mm_invsqrt_pd(__m128d);
extern __m256  _mm256_invsqrt_ps(__m256);
extern __m256d _mm256_invsqrt_pd(__m256d);
extern __m128  _mm_cbrt_ps(__m128);
extern __m128d _mm_cbrt_pd(__m128d);
extern __m256  _mm256_cbrt_ps(__m256);
extern __m256d _mm256_cbrt_pd(__m256d);
extern __m128  _mm_invcbrt_ps(__m128);
extern __m128d _mm_invcbrt_pd(__m128d);
extern __m256  _mm256_invcbrt_ps(__m256);
extern __m256d _mm256_invcbrt_pd(__m256d);
extern __m128  _mm_hypot_ps(__m128, __m128);
extern __m128d _mm_hypot_pd(__m128d, __m128d);
extern __m256  _mm256_hypot_ps(__m256, __m256);
extern __m256d _mm256_hypot_pd(__m256d, __m256d);
extern __m128  _mm_cdfnorm_ps(__m128);
extern __m128d _mm_cdfnorm_pd(__m128d);
extern __m256  _mm256_cdfnorm_ps(__m256);
extern __m256d _mm256_cdfnorm_pd(__m256d);
extern __m128  _mm_cdfnorminv_ps(__m128);
extern __m128d _mm_cdfnorminv_pd(__m128d);
extern __m256  _mm256_cdfnorminv_ps(__m256);
extern __m256d _mm256_cdfnorminv_pd(__m256d);
extern __m128  _mm_cexp_ps(__m128);
extern __m256  _mm256_cexp_ps(__m256);
extern __m128  _mm_clog_ps(__m128);
extern __m256  _mm256_clog_ps(__m256);
extern __m128  _mm_csqrt_ps(__m128);
extern __m256  _mm256_csqrt_ps(__m256);
extern __m128  _mm_erf_ps(__m128);
extern __m128d _mm_erf_pd(__m128d);
extern __m256  _mm256_erf_ps(__m256);
extern __m256d _mm256_erf_pd(__m256d);
extern __m128  _mm_erfc_ps(__m128);
extern __m128d _mm_erfc_pd(__m128d);
extern __m256  _mm256_erfc_ps(__m256);
extern __m256d _mm256_erfc_pd(__m256d);
extern __m128  _mm_erfcinv_ps(__m128);
extern __m128d _mm_erfcinv_pd(__m128d);
extern __m256  _mm256_erfcinv_ps(__m256);
extern __m256d _mm256_erfcinv_pd(__m256d);
extern __m128  _mm_erfinv_ps(__m128);
extern __m128d _mm_erfinv_pd(__m128d);
extern __m256  _mm256_erfinv_ps(__m256);
extern __m256d _mm256_erfinv_pd(__m256d);


extern void _mm_cldemote(void const *);



extern void _directstoreu_u32(void *, unsigned int);

extern void _directstoreu_u64(void *, unsigned __int64);
#line 2495 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
extern void _movdir64b(void *, void const *);


extern void __cdecl _serialize(void);
extern void __cdecl _xsusldtrk(void);
extern void __cdecl _xresldtrk(void);


extern void _umonitor(void *);
extern unsigned char _umwait(unsigned int, unsigned __int64);
extern unsigned char _tpause(unsigned int, unsigned __int64);



extern void _clui(void);
extern void _stui(void);
extern unsigned char _testui(void);
extern void _senduipi(unsigned __int64);
#line 2514 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern void _hreset(unsigned __int32);


extern __m128 _mm_svml_cvtepu32_ps (__m128i);
extern __m256 _mm256_svml_cvtepu32_ps (__m256i);
extern __m128d _mm_svml_cvtepu32_pd (__m128i);
extern __m256d _mm256_svml_cvtepu32_pd (__m128i);
extern __m128d _mm_svml_cvtepi64_pd (__m128i);
extern __m256d _mm256_svml_cvtepi64_pd (__m256i);
extern __m128d _mm_svml_cvtepu64_pd (__m128i);
extern __m256d _mm256_svml_cvtepu64_pd (__m256i);


extern unsigned __int32 _castf32_u32 (float);
extern unsigned __int64 _castf64_u64 (double);
extern float _castu32_f32 (unsigned __int32);
extern double _castu64_f64 (unsigned __int64);


}; 
#line 2537 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"









































typedef unsigned char       __mmask8;
typedef unsigned short      __mmask16;
typedef unsigned int        __mmask32;
typedef unsigned __int64    __mmask64;

typedef union __declspec(intrin_type) __declspec(align(64)) __m512 {
    float m512_f32[16];
} __m512;

typedef struct __declspec(intrin_type) __declspec(align(64)) __m512d {
    double m512d_f64[8];
} __m512d;

typedef union  __declspec(intrin_type) __declspec(align(64)) __m512i {
    __int8              m512i_i8[64];
    __int16             m512i_i16[32];
    __int32             m512i_i32[16];
    __int64             m512i_i64[8];
    unsigned __int8     m512i_u8[64];
    unsigned __int16    m512i_u16[32];
    unsigned __int32    m512i_u32[16];
    unsigned __int64    m512i_u64[8];
} __m512i;



extern "C" {

#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern __m256  __cdecl _mm512_castps512_ps256(__m512);
extern __m512  __cdecl _mm512_castpd_ps(__m512d);
extern __m512  __cdecl _mm512_castps256_ps512(__m256);
extern __m512  __cdecl _mm512_castsi512_ps(__m512i);
extern __m512  __cdecl _mm512_castps128_ps512(__m128);

extern __m256d __cdecl _mm512_castpd512_pd256(__m512d);
extern __m512d __cdecl _mm512_castpd256_pd512(__m256d);
extern __m512d __cdecl _mm512_castps_pd(__m512);
extern __m512d __cdecl _mm512_castsi512_pd(__m512i);
extern __m512d __cdecl _mm512_castpd128_pd512(__m128d);

extern __m256i __cdecl _mm512_castsi512_si256(__m512i);
extern __m512i __cdecl _mm512_castpd_si512(__m512d);
extern __m512i __cdecl _mm512_castps_si512(__m512);
extern __m512i __cdecl _mm512_castsi256_si512(__m256i);








typedef enum {
    _MM_BROADCAST32_NONE,   

    _MM_BROADCAST_1X16,     
    _MM_BROADCAST_4X16      
} _MM_BROADCAST32_ENUM;


typedef enum {
    _MM_BROADCAST64_NONE,   

    _MM_BROADCAST_1X8,      
    _MM_BROADCAST_4X8       
} _MM_BROADCAST64_ENUM;






typedef enum {
    _MM_ROUND_MODE_NEAREST,             
    _MM_ROUND_MODE_DOWN,                
    _MM_ROUND_MODE_UP,                  
    _MM_ROUND_MODE_TOWARD_ZERO,         
    _MM_ROUND_MODE_DEFAULT,             
    _MM_ROUND_MODE_NO_EXC = 8,          
} _MM_ROUND_MODE_ENUM;


typedef enum {
    _MM_EXPADJ_NONE,               
    _MM_EXPADJ_4,                  
    _MM_EXPADJ_5,                  
    _MM_EXPADJ_8,                  
    _MM_EXPADJ_16,                 
    _MM_EXPADJ_24,                 
    _MM_EXPADJ_31,                 
    _MM_EXPADJ_32                  
} _MM_EXP_ADJ_ENUM;


typedef enum {
    _MM_SCALE_1 = 1,
    _MM_SCALE_2 = 2,
    _MM_SCALE_4 = 4,
    _MM_SCALE_8 = 8
} _MM_INDEX_SCALE_ENUM;


typedef enum {
    _MM_PERM_AAAA = 0x00, _MM_PERM_AAAB = 0x01, _MM_PERM_AAAC = 0x02,
    _MM_PERM_AAAD = 0x03, _MM_PERM_AABA = 0x04, _MM_PERM_AABB = 0x05,
    _MM_PERM_AABC = 0x06, _MM_PERM_AABD = 0x07, _MM_PERM_AACA = 0x08,
    _MM_PERM_AACB = 0x09, _MM_PERM_AACC = 0x0A, _MM_PERM_AACD = 0x0B,
    _MM_PERM_AADA = 0x0C, _MM_PERM_AADB = 0x0D, _MM_PERM_AADC = 0x0E,
    _MM_PERM_AADD = 0x0F, _MM_PERM_ABAA = 0x10, _MM_PERM_ABAB = 0x11,
    _MM_PERM_ABAC = 0x12, _MM_PERM_ABAD = 0x13, _MM_PERM_ABBA = 0x14,
    _MM_PERM_ABBB = 0x15, _MM_PERM_ABBC = 0x16, _MM_PERM_ABBD = 0x17,
    _MM_PERM_ABCA = 0x18, _MM_PERM_ABCB = 0x19, _MM_PERM_ABCC = 0x1A,
    _MM_PERM_ABCD = 0x1B, _MM_PERM_ABDA = 0x1C, _MM_PERM_ABDB = 0x1D,
    _MM_PERM_ABDC = 0x1E, _MM_PERM_ABDD = 0x1F, _MM_PERM_ACAA = 0x20,
    _MM_PERM_ACAB = 0x21, _MM_PERM_ACAC = 0x22, _MM_PERM_ACAD = 0x23,
    _MM_PERM_ACBA = 0x24, _MM_PERM_ACBB = 0x25, _MM_PERM_ACBC = 0x26,
    _MM_PERM_ACBD = 0x27, _MM_PERM_ACCA = 0x28, _MM_PERM_ACCB = 0x29,
    _MM_PERM_ACCC = 0x2A, _MM_PERM_ACCD = 0x2B, _MM_PERM_ACDA = 0x2C,
    _MM_PERM_ACDB = 0x2D, _MM_PERM_ACDC = 0x2E, _MM_PERM_ACDD = 0x2F,
    _MM_PERM_ADAA = 0x30, _MM_PERM_ADAB = 0x31, _MM_PERM_ADAC = 0x32,
    _MM_PERM_ADAD = 0x33, _MM_PERM_ADBA = 0x34, _MM_PERM_ADBB = 0x35,
    _MM_PERM_ADBC = 0x36, _MM_PERM_ADBD = 0x37, _MM_PERM_ADCA = 0x38,
    _MM_PERM_ADCB = 0x39, _MM_PERM_ADCC = 0x3A, _MM_PERM_ADCD = 0x3B,
    _MM_PERM_ADDA = 0x3C, _MM_PERM_ADDB = 0x3D, _MM_PERM_ADDC = 0x3E,
    _MM_PERM_ADDD = 0x3F, _MM_PERM_BAAA = 0x40, _MM_PERM_BAAB = 0x41,
    _MM_PERM_BAAC = 0x42, _MM_PERM_BAAD = 0x43, _MM_PERM_BABA = 0x44,
    _MM_PERM_BABB = 0x45, _MM_PERM_BABC = 0x46, _MM_PERM_BABD = 0x47,
    _MM_PERM_BACA = 0x48, _MM_PERM_BACB = 0x49, _MM_PERM_BACC = 0x4A,
    _MM_PERM_BACD = 0x4B, _MM_PERM_BADA = 0x4C, _MM_PERM_BADB = 0x4D,
    _MM_PERM_BADC = 0x4E, _MM_PERM_BADD = 0x4F, _MM_PERM_BBAA = 0x50,
    _MM_PERM_BBAB = 0x51, _MM_PERM_BBAC = 0x52, _MM_PERM_BBAD = 0x53,
    _MM_PERM_BBBA = 0x54, _MM_PERM_BBBB = 0x55, _MM_PERM_BBBC = 0x56,
    _MM_PERM_BBBD = 0x57, _MM_PERM_BBCA = 0x58, _MM_PERM_BBCB = 0x59,
    _MM_PERM_BBCC = 0x5A, _MM_PERM_BBCD = 0x5B, _MM_PERM_BBDA = 0x5C,
    _MM_PERM_BBDB = 0x5D, _MM_PERM_BBDC = 0x5E, _MM_PERM_BBDD = 0x5F,
    _MM_PERM_BCAA = 0x60, _MM_PERM_BCAB = 0x61, _MM_PERM_BCAC = 0x62,
    _MM_PERM_BCAD = 0x63, _MM_PERM_BCBA = 0x64, _MM_PERM_BCBB = 0x65,
    _MM_PERM_BCBC = 0x66, _MM_PERM_BCBD = 0x67, _MM_PERM_BCCA = 0x68,
    _MM_PERM_BCCB = 0x69, _MM_PERM_BCCC = 0x6A, _MM_PERM_BCCD = 0x6B,
    _MM_PERM_BCDA = 0x6C, _MM_PERM_BCDB = 0x6D, _MM_PERM_BCDC = 0x6E,
    _MM_PERM_BCDD = 0x6F, _MM_PERM_BDAA = 0x70, _MM_PERM_BDAB = 0x71,
    _MM_PERM_BDAC = 0x72, _MM_PERM_BDAD = 0x73, _MM_PERM_BDBA = 0x74,
    _MM_PERM_BDBB = 0x75, _MM_PERM_BDBC = 0x76, _MM_PERM_BDBD = 0x77,
    _MM_PERM_BDCA = 0x78, _MM_PERM_BDCB = 0x79, _MM_PERM_BDCC = 0x7A,
    _MM_PERM_BDCD = 0x7B, _MM_PERM_BDDA = 0x7C, _MM_PERM_BDDB = 0x7D,
    _MM_PERM_BDDC = 0x7E, _MM_PERM_BDDD = 0x7F, _MM_PERM_CAAA = 0x80,
    _MM_PERM_CAAB = 0x81, _MM_PERM_CAAC = 0x82, _MM_PERM_CAAD = 0x83,
    _MM_PERM_CABA = 0x84, _MM_PERM_CABB = 0x85, _MM_PERM_CABC = 0x86,
    _MM_PERM_CABD = 0x87, _MM_PERM_CACA = 0x88, _MM_PERM_CACB = 0x89,
    _MM_PERM_CACC = 0x8A, _MM_PERM_CACD = 0x8B, _MM_PERM_CADA = 0x8C,
    _MM_PERM_CADB = 0x8D, _MM_PERM_CADC = 0x8E, _MM_PERM_CADD = 0x8F,
    _MM_PERM_CBAA = 0x90, _MM_PERM_CBAB = 0x91, _MM_PERM_CBAC = 0x92,
    _MM_PERM_CBAD = 0x93, _MM_PERM_CBBA = 0x94, _MM_PERM_CBBB = 0x95,
    _MM_PERM_CBBC = 0x96, _MM_PERM_CBBD = 0x97, _MM_PERM_CBCA = 0x98,
    _MM_PERM_CBCB = 0x99, _MM_PERM_CBCC = 0x9A, _MM_PERM_CBCD = 0x9B,
    _MM_PERM_CBDA = 0x9C, _MM_PERM_CBDB = 0x9D, _MM_PERM_CBDC = 0x9E,
    _MM_PERM_CBDD = 0x9F, _MM_PERM_CCAA = 0xA0, _MM_PERM_CCAB = 0xA1,
    _MM_PERM_CCAC = 0xA2, _MM_PERM_CCAD = 0xA3, _MM_PERM_CCBA = 0xA4,
    _MM_PERM_CCBB = 0xA5, _MM_PERM_CCBC = 0xA6, _MM_PERM_CCBD = 0xA7,
    _MM_PERM_CCCA = 0xA8, _MM_PERM_CCCB = 0xA9, _MM_PERM_CCCC = 0xAA,
    _MM_PERM_CCCD = 0xAB, _MM_PERM_CCDA = 0xAC, _MM_PERM_CCDB = 0xAD,
    _MM_PERM_CCDC = 0xAE, _MM_PERM_CCDD = 0xAF, _MM_PERM_CDAA = 0xB0,
    _MM_PERM_CDAB = 0xB1, _MM_PERM_CDAC = 0xB2, _MM_PERM_CDAD = 0xB3,
    _MM_PERM_CDBA = 0xB4, _MM_PERM_CDBB = 0xB5, _MM_PERM_CDBC = 0xB6,
    _MM_PERM_CDBD = 0xB7, _MM_PERM_CDCA = 0xB8, _MM_PERM_CDCB = 0xB9,
    _MM_PERM_CDCC = 0xBA, _MM_PERM_CDCD = 0xBB, _MM_PERM_CDDA = 0xBC,
    _MM_PERM_CDDB = 0xBD, _MM_PERM_CDDC = 0xBE, _MM_PERM_CDDD = 0xBF,
    _MM_PERM_DAAA = 0xC0, _MM_PERM_DAAB = 0xC1, _MM_PERM_DAAC = 0xC2,
    _MM_PERM_DAAD = 0xC3, _MM_PERM_DABA = 0xC4, _MM_PERM_DABB = 0xC5,
    _MM_PERM_DABC = 0xC6, _MM_PERM_DABD = 0xC7, _MM_PERM_DACA = 0xC8,
    _MM_PERM_DACB = 0xC9, _MM_PERM_DACC = 0xCA, _MM_PERM_DACD = 0xCB,
    _MM_PERM_DADA = 0xCC, _MM_PERM_DADB = 0xCD, _MM_PERM_DADC = 0xCE,
    _MM_PERM_DADD = 0xCF, _MM_PERM_DBAA = 0xD0, _MM_PERM_DBAB = 0xD1,
    _MM_PERM_DBAC = 0xD2, _MM_PERM_DBAD = 0xD3, _MM_PERM_DBBA = 0xD4,
    _MM_PERM_DBBB = 0xD5, _MM_PERM_DBBC = 0xD6, _MM_PERM_DBBD = 0xD7,
    _MM_PERM_DBCA = 0xD8, _MM_PERM_DBCB = 0xD9, _MM_PERM_DBCC = 0xDA,
    _MM_PERM_DBCD = 0xDB, _MM_PERM_DBDA = 0xDC, _MM_PERM_DBDB = 0xDD,
    _MM_PERM_DBDC = 0xDE, _MM_PERM_DBDD = 0xDF, _MM_PERM_DCAA = 0xE0,
    _MM_PERM_DCAB = 0xE1, _MM_PERM_DCAC = 0xE2, _MM_PERM_DCAD = 0xE3,
    _MM_PERM_DCBA = 0xE4, _MM_PERM_DCBB = 0xE5, _MM_PERM_DCBC = 0xE6,
    _MM_PERM_DCBD = 0xE7, _MM_PERM_DCCA = 0xE8, _MM_PERM_DCCB = 0xE9,
    _MM_PERM_DCCC = 0xEA, _MM_PERM_DCCD = 0xEB, _MM_PERM_DCDA = 0xEC,
    _MM_PERM_DCDB = 0xED, _MM_PERM_DCDC = 0xEE, _MM_PERM_DCDD = 0xEF,
    _MM_PERM_DDAA = 0xF0, _MM_PERM_DDAB = 0xF1, _MM_PERM_DDAC = 0xF2,
    _MM_PERM_DDAD = 0xF3, _MM_PERM_DDBA = 0xF4, _MM_PERM_DDBB = 0xF5,
    _MM_PERM_DDBC = 0xF6, _MM_PERM_DDBD = 0xF7, _MM_PERM_DDCA = 0xF8,
    _MM_PERM_DDCB = 0xF9, _MM_PERM_DDCC = 0xFA, _MM_PERM_DDCD = 0xFB,
    _MM_PERM_DDDA = 0xFC, _MM_PERM_DDDB = 0xFD, _MM_PERM_DDDC = 0xFE,
    _MM_PERM_DDDD = 0xFF
} _MM_PERM_ENUM;





typedef enum {
    _MM_FIXUP_NO_CHANGE,
    _MM_FIXUP_NEG_INF,
    _MM_FIXUP_NEG_ZERO,
    _MM_FIXUP_POS_ZERO,
    _MM_FIXUP_POS_INF,
    _MM_FIXUP_NAN,
    _MM_FIXUP_MAX_FLOAT,
    _MM_FIXUP_MIN_FLOAT
} _MM_FIXUPRESULT_ENUM;





















typedef enum {
    _MM_MANT_NORM_1_2,      
    _MM_MANT_NORM_p5_2,     
    _MM_MANT_NORM_p5_1,     
    _MM_MANT_NORM_p75_1p5   
} _MM_MANTISSA_NORM_ENUM;

typedef enum {
    _MM_MANT_SIGN_src,      
    _MM_MANT_SIGN_zero,     
    _MM_MANT_SIGN_nan       
} _MM_MANTISSA_SIGN_ENUM;






typedef enum {
    _MM_CMPINT_EQ,      
    _MM_CMPINT_LT,      
    _MM_CMPINT_LE,      
    _MM_CMPINT_UNUSED,
    _MM_CMPINT_NE,      
    _MM_CMPINT_NLT,     

    _MM_CMPINT_NLE      

} _MM_CMPINT_ENUM;





extern __m512  __cdecl _mm512_setzero_ps(void);
extern __m512d __cdecl _mm512_setzero_pd(void);

extern __m512  __cdecl _mm512_set_ps(float , float, float, float, float, float, float, float, float, float, float, float, float, float, float, float );
extern __m512d __cdecl _mm512_set_pd(double , double, double, double, double, double, double, double );

extern __m512  __cdecl _mm512_setr_ps(float , float, float, float, float, float, float, float, float, float, float, float, float, float, float, float );
extern __m512d __cdecl _mm512_setr_pd(double , double, double, double, double, double, double, double );

extern __m512  __cdecl _mm512_set1_ps(float);
extern __m512d __cdecl _mm512_set1_pd(double);

extern __m512  __cdecl _mm512_load_ps(void const*);
extern __m512d __cdecl _mm512_load_pd(void const*);
extern __m512  __cdecl _mm512_maskz_load_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_load_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_load_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_load_pd(__m512d, __mmask8, void const*);
extern __m512  __cdecl _mm512_loadu_ps(void const*);
extern __m512d __cdecl _mm512_loadu_pd(void const*);
extern __m512  __cdecl _mm512_maskz_loadu_ps(__mmask16, void const*);
extern __m512d __cdecl _mm512_maskz_loadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_loadu_ps(__m512, __mmask16, void const*);
extern __m512d __cdecl _mm512_mask_loadu_pd(__m512d, __mmask8, void const*);

extern void    __cdecl _mm512_store_ps(void*, __m512);
extern void    __cdecl _mm512_store_pd(void*, __m512d);
extern void    __cdecl _mm512_storeu_ps(void*, __m512);
extern void    __cdecl _mm512_storeu_pd(void*, __m512d);
extern void    __cdecl _mm512_mask_store_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_store_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_storeu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_storeu_pd(void*, __mmask8, __m512d);

extern __m512  __cdecl _mm512_add_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_add_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_add_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_add_round_ps(__m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_add_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_add_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_add_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_add_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_add_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_add_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_add_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_add_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_sub_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_sub_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_sub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_sub_round_ps(__m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_sub_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_sub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_sub_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_sub_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_sub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_sub_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_sub_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_sub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_mul_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_mul_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_mul_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mul_round_ps( __m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_mul_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_mul_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mul_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_mul_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_mul_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mul_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_mul_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_mul_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_div_ps(__m512, __m512);
extern __m512  __cdecl _mm512_maskz_div_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask_div_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_div_round_ps(__m512, __m512, const int );
extern __m512  __cdecl _mm512_maskz_div_round_ps(__mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_div_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_div_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_div_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_div_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_div_round_pd(__m512d, __m512d, const int );
extern __m512d __cdecl _mm512_maskz_div_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_div_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmadd_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmadd_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmsub_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmsub_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmaddsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmaddsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmaddsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmaddsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmaddsub_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmaddsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmaddsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmaddsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmaddsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmaddsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmaddsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmaddsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmaddsub_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmaddsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmaddsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmaddsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fmsubadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fmsubadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fmsubadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fmsubadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fmsubadd_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fmsubadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fmsubadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fmsubadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fmsubadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fmsubadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fmsubadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fmsubadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fmsubadd_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fmsubadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fmsubadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fmsubadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fnmadd_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fnmadd_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fnmadd_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fnmadd_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fnmadd_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fnmadd_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fnmadd_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fnmadd_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fnmadd_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fnmadd_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fnmadd_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fnmadd_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fnmadd_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fnmadd_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fnmadd_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fnmadd_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_fnmsub_ps(__m512, __m512, __m512);
extern __m512  __cdecl _mm512_mask_fnmsub_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_mask3_fnmsub_ps(__m512, __m512, __m512, __mmask16);
extern __m512  __cdecl _mm512_maskz_fnmsub_ps(__mmask16, __m512, __m512, __m512);
extern __m512  __cdecl _mm512_fnmsub_round_ps(__m512, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask_fnmsub_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512  __cdecl _mm512_mask3_fnmsub_round_ps(__m512, __m512, __m512, __mmask16, const int );
extern __m512  __cdecl _mm512_maskz_fnmsub_round_ps(__mmask16, __m512, __m512, __m512, const int );
extern __m512d __cdecl _mm512_fnmsub_pd(__m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask_fnmsub_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_mask3_fnmsub_pd(__m512d, __m512d, __m512d, __mmask8);
extern __m512d __cdecl _mm512_maskz_fnmsub_pd(__mmask8, __m512d, __m512d, __m512d);
extern __m512d __cdecl _mm512_fnmsub_round_pd(__m512d, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask_fnmsub_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );
extern __m512d __cdecl _mm512_mask3_fnmsub_round_pd(__m512d, __m512d, __m512d, __mmask8, const int );
extern __m512d __cdecl _mm512_maskz_fnmsub_round_pd(__mmask8, __m512d, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_sqrt_ps(__m512);
extern __m512d __cdecl _mm512_sqrt_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_sqrt_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_sqrt_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_sqrt_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_sqrt_pd(__m512d, __mmask8, __m512d);
extern __m512  __cdecl _mm512_sqrt_round_ps(__m512, const int );
extern __m512d __cdecl _mm512_sqrt_round_pd(__m512d, const int );
extern __m512  __cdecl _mm512_maskz_sqrt_round_ps(__mmask16, __m512, const int );
extern __m512d __cdecl _mm512_maskz_sqrt_round_pd(__mmask8, __m512d, const int );
extern __m512  __cdecl _mm512_mask_sqrt_round_ps(__m512, __mmask16, __m512, const int );
extern __m512d __cdecl _mm512_mask_sqrt_round_pd(__m512d, __mmask8, __m512d, const int );

extern __m512  __cdecl _mm512_abs_ps(__m512);
extern __m512  __cdecl _mm512_maskz_abs_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_mask_abs_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_abs_pd(__m512d);
extern __m512d __cdecl _mm512_maskz_abs_pd(__mmask8, __m512d);
extern __m512d __cdecl _mm512_mask_abs_pd(__m512d, __mmask8, __m512d);

extern __m512  __cdecl _mm512_max_ps(__m512, __m512);
extern __m512d __cdecl _mm512_max_pd(__m512d, __m512d);
extern __m512  __cdecl _mm512_maskz_max_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_maskz_max_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_max_ps(__m512, __mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_max_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_max_round_ps(__m512, __m512, const int );
extern __m512d __cdecl _mm512_max_round_pd(__m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_max_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_max_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_max_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_max_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_min_ps(__m512, __m512);
extern __m512d __cdecl _mm512_min_pd(__m512d, __m512d);
extern __m512  __cdecl _mm512_maskz_min_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_maskz_min_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_mask_min_ps(__m512, __mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_min_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_min_round_ps(__m512, __m512, const int );
extern __m512d __cdecl _mm512_min_round_pd(__m512d, __m512d, const int );
extern __m512  __cdecl _mm512_maskz_min_round_ps(__mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_maskz_min_round_pd(__mmask8, __m512d, __m512d, const int );
extern __m512  __cdecl _mm512_mask_min_round_ps(__m512, __mmask16, __m512, __m512, const int );
extern __m512d __cdecl _mm512_mask_min_round_pd(__m512d, __mmask8, __m512d, __m512d, const int );

extern __m512  __cdecl _mm512_rcp14_ps(__m512);
extern __m512d __cdecl _mm512_rcp14_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_rcp14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rcp14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rcp14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rcp14_pd(__m512d, __mmask8, __m512d);

extern __m512  __cdecl _mm512_rsqrt14_ps(__m512);
extern __m512d __cdecl _mm512_rsqrt14_pd(__m512d);
extern __m512  __cdecl _mm512_maskz_rsqrt14_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_maskz_rsqrt14_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_rsqrt14_ps(__m512, __mmask16, __m512);
extern __m512d __cdecl _mm512_mask_rsqrt14_pd(__m512d, __mmask8, __m512d);

extern __m512d __cdecl _mm512_cvtps_pd(__m256);
extern __m256  __cdecl _mm512_cvtpd_ps(__m512d);
extern __m512d __cdecl _mm512_maskz_cvtps_pd(__mmask8, __m256);
extern __m256  __cdecl _mm512_maskz_cvtpd_ps(__mmask8, __m512d);
extern __m512d __cdecl _mm512_mask_cvtps_pd(__m512d, __mmask8, __m256);
extern __m256  __cdecl _mm512_mask_cvtpd_ps(__m256, __mmask8, __m512d);
extern __m512d __cdecl _mm512_cvt_roundps_pd(__m256, const int );
extern __m256  __cdecl _mm512_cvt_roundpd_ps(__m512d, const int );
extern __m512d __cdecl _mm512_maskz_cvt_roundps_pd(__mmask8, __m256, const int );
extern __m256  __cdecl _mm512_maskz_cvt_roundpd_ps(__mmask8, __m512d, const int );
extern __m512d __cdecl _mm512_mask_cvt_roundps_pd(__m512d, __mmask8, __m256, const int );
extern __m256  __cdecl _mm512_mask_cvt_roundpd_ps(__m256, __mmask8, __m512d, const int );

extern __mmask16 __cdecl _mm512_cmp_ps_mask(__m512, __m512, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_ps_mask(__mmask16, __m512, __m512, const int);
extern __mmask16 __cdecl _mm512_cmp_round_ps_mask(__m512, __m512, const int, const int );
extern __mmask16 __cdecl _mm512_mask_cmp_round_ps_mask(__mmask16, __m512, __m512, const int, const int );
extern __mmask8  __cdecl _mm512_cmp_pd_mask(__m512d, __m512d, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_pd_mask(__mmask8, __m512d, __m512d, const int);
extern __mmask8  __cdecl _mm512_cmp_round_pd_mask(__m512d, __m512d, const int, const int );
extern __mmask8  __cdecl _mm512_mask_cmp_round_pd_mask(__mmask8, __m512d, __m512d, const int, const int );

extern __m512  __cdecl _mm512_broadcast_f32x2(__m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x2(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x2(__mmask16, __m128);
extern __m512  __cdecl _mm512_broadcast_f32x4(__m128);
extern __m512  __cdecl _mm512_mask_broadcast_f32x4(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x4(__mmask16, __m128);
extern __m512  __cdecl _mm512_broadcast_f32x8(__m256);
extern __m512  __cdecl _mm512_mask_broadcast_f32x8(__m512, __mmask16, __m256);
extern __m512  __cdecl _mm512_maskz_broadcast_f32x8(__mmask16, __m256);
extern __m512d __cdecl _mm512_broadcast_f64x2(__m128d);
extern __m512d __cdecl _mm512_mask_broadcast_f64x2(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m512d __cdecl _mm512_broadcast_f64x4(__m256d);
extern __m512d __cdecl _mm512_mask_broadcast_f64x4(__m512d, __mmask8, __m256d);
extern __m512d __cdecl _mm512_maskz_broadcast_f64x4(__mmask8, __m256d);
extern __m512d __cdecl _mm512_broadcastsd_pd(__m128d);
extern __m512d __cdecl _mm512_mask_broadcastsd_pd(__m512d, __mmask8, __m128d);
extern __m512d __cdecl _mm512_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m512  __cdecl _mm512_broadcastss_ps(__m128);
extern __m512  __cdecl _mm512_mask_broadcastss_ps(__m512, __mmask16, __m128);
extern __m512  __cdecl _mm512_maskz_broadcastss_ps(__mmask16, __m128);

extern __m128  __cdecl _mm512_extractf32x4_ps(__m512, int);
extern __m128  __cdecl _mm512_mask_extractf32x4_ps(__m128, __mmask8, __m512, const int);
extern __m128  __cdecl _mm512_maskz_extractf32x4_ps(__mmask8, __m512, int);
extern __m256  __cdecl _mm512_extractf32x8_ps(__m512, int);
extern __m256  __cdecl _mm512_mask_extractf32x8_ps(__m256, __mmask8, __m512, const int);
extern __m256  __cdecl _mm512_maskz_extractf32x8_ps(__mmask8, __m512, int);
extern __m128d __cdecl _mm512_extractf64x2_pd(__m512d, int);
extern __m128d __cdecl _mm512_mask_extractf64x2_pd(__m128d, __mmask8, __m512d, const int);
extern __m128d __cdecl _mm512_maskz_extractf64x2_pd(__mmask8, __m512d, int);
extern __m256d __cdecl _mm512_extractf64x4_pd(__m512d, int);
extern __m256d __cdecl _mm512_mask_extractf64x4_pd(__m256d, __mmask8, __m512d, const int);
extern __m256d __cdecl _mm512_maskz_extractf64x4_pd(__mmask8, __m512d, int);

extern __m512  __cdecl _mm512_insertf32x4(__m512, __m128, int);
extern __m512  __cdecl _mm512_mask_insertf32x4(__m512, __mmask16, __m512, __m128, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x4(__mmask16, __m512, __m128, int);
extern __m512  __cdecl _mm512_insertf32x8(__m512, __m256, int);
extern __m512  __cdecl _mm512_mask_insertf32x8(__m512, __mmask16, __m512, __m256, const int);
extern __m512  __cdecl _mm512_maskz_insertf32x8(__mmask16, __m512, __m256, int);
extern __m512d __cdecl _mm512_insertf64x2(__m512d, __m128d, int);
extern __m512d __cdecl _mm512_mask_insertf64x2(__m512d, __mmask8, __m512d, __m128d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x2(__mmask8, __m512d, __m128d, int);
extern __m512d __cdecl _mm512_insertf64x4(__m512d, __m256d, int);
extern __m512d __cdecl _mm512_mask_insertf64x4(__m512d, __mmask8, __m512d, __m256d, const int);
extern __m512d __cdecl _mm512_maskz_insertf64x4(__mmask8, __m512d, __m256d, int);

extern __m512  __cdecl _mm512_shuffle_f32x4(__m512, __m512, const int);
extern __m512  __cdecl _mm512_mask_shuffle_f32x4(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_f32x4(__mmask16, __m512, __m512, const int);
extern __m512d __cdecl _mm512_shuffle_f64x2(__m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_shuffle_f64x2(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_f64x2(__mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_shuffle_pd(__m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_shuffle_pd(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_shuffle_pd(__mmask8, __m512d, __m512d, const int);
extern __m512  __cdecl _mm512_shuffle_ps(__m512, __m512, const int);
extern __m512  __cdecl _mm512_mask_shuffle_ps(__m512, __mmask16, __m512, __m512, const int);
extern __m512  __cdecl _mm512_maskz_shuffle_ps(__mmask16, __m512, __m512, const int);

extern __mmask16 _mm512_cmpeq_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmple_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmplt_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpneq_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpnle_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpnlt_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpord_ps_mask(__m512, __m512);
extern __mmask16 _mm512_cmpunord_ps_mask(__m512, __m512);

extern __mmask16 _mm512_mask_cmpeq_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmple_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmplt_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpneq_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpnle_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpnlt_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpord_ps_mask(__mmask16, __m512, __m512);
extern __mmask16 _mm512_mask_cmpunord_ps_mask(__mmask16, __m512, __m512);

extern __mmask8 _mm512_cmpeq_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmple_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmplt_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpneq_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpnle_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpnlt_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpord_pd_mask(__m512d, __m512d);
extern __mmask8 _mm512_cmpunord_pd_mask(__m512d, __m512d);

extern __mmask8 _mm512_mask_cmpeq_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmple_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmplt_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpneq_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpnle_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpnlt_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpord_pd_mask(__mmask8, __m512d, __m512d);
extern __mmask8 _mm512_mask_cmpunord_pd_mask(__mmask8, __m512d, __m512d);





































extern __m512i __cdecl _mm512_setzero_si512(void);

extern __m512i __cdecl _mm512_set_epi8(char , char, char, char, char, char, char, char, char, char, char, char, char, char, char, char,
                                       char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char,
                                       char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char,
                                       char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char );
extern __m512i __cdecl _mm512_set_epi16(short , short, short, short, short, short, short, short, short, short, short, short, short, short, short, short,
                                        short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short );
extern __m512i __cdecl _mm512_set_epi32(int , int, int, int, int, int, int, int, int, int, int, int, int, int, int, int );
extern __m512i __cdecl _mm512_set_epi64(__int64 , __int64, __int64, __int64, __int64, __int64, __int64, __int64 );

extern __m512i __cdecl _mm512_setr_epi8(char , char, char, char, char, char, char, char, char, char, char, char, char, char, char, char,
                                        char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char,
                                        char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char,
                                        char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char );
extern __m512i __cdecl _mm512_setr_epi16(short , short, short, short, short, short, short, short, short, short, short, short, short, short, short, short,
                                         short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short );
extern __m512i __cdecl _mm512_setr_epi32(int , int, int, int, int, int, int, int, int, int, int, int, int, int, int, int );
extern __m512i __cdecl _mm512_setr_epi64(__int64 , __int64, __int64, __int64, __int64, __int64, __int64, __int64 );

extern __m512i __cdecl _mm512_set1_epi8(char);
extern __m512i __cdecl _mm512_mask_set1_epi8(__m512i, __mmask64, char);
extern __m512i __cdecl _mm512_maskz_set1_epi8(__mmask64, char);
extern __m512i __cdecl _mm512_set1_epi16(short);
extern __m512i __cdecl _mm512_mask_set1_epi16(__m512i, __mmask32, short);
extern __m512i __cdecl _mm512_maskz_set1_epi16(__mmask32, short);
extern __m512i __cdecl _mm512_set1_epi32(int);
extern __m512i __cdecl _mm512_mask_set1_epi32(__m512i, __mmask16, int);
extern __m512i __cdecl _mm512_maskz_set1_epi32(__mmask16, int);
extern __m512i __cdecl _mm512_set1_epi64(__int64);
extern __m512i __cdecl _mm512_mask_set1_epi64(__m512i, __mmask8, __int64);
extern __m512i __cdecl _mm512_maskz_set1_epi64(__mmask8, __int64);

extern __m512i __cdecl _mm512_add_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_add_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_add_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_add_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_adds_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_adds_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_adds_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_abs_epi8(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_abs_epi16(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_abs_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_abs_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_abs_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_abs_epi64(__mmask8, __m512i);

extern __m512i  __cdecl _mm512_broadcast_i32x2(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x2(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x2(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i32x4(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x4(__m512i, __mmask16, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x4(__mmask16, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i32x8(__m256i);
extern __m512i  __cdecl _mm512_mask_broadcast_i32x8(__m512i, __mmask16, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i32x8(__mmask16, __m256i);
extern __m512i  __cdecl _mm512_broadcast_i64x2(__m128i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x2(__m512i, __mmask8, __m128i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m512i  __cdecl _mm512_broadcast_i64x4(__m256i);
extern __m512i  __cdecl _mm512_mask_broadcast_i64x4(__m512i, __mmask8, __m256i);
extern __m512i  __cdecl _mm512_maskz_broadcast_i64x4(__mmask8, __m256i);
extern __m512i __cdecl _mm512_broadcastb_epi8(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastb_epi8(__m512i, __mmask64, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastb_epi8(__mmask64, __m128i);
extern __m512i __cdecl _mm512_broadcastw_epi16(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastw_epi16(__m512i, __mmask32, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastw_epi16(__mmask32, __m128i);
extern __m512i __cdecl _mm512_broadcastd_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastd_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastd_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_broadcastq_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_broadcastq_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_broadcastmw_epi32(__mmask16);
extern __m512i __cdecl _mm512_broadcastmb_epi64(__mmask8);

extern __m512i __cdecl _mm512_sub_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_sub_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sub_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sub_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_subs_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_subs_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_subs_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_max_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_max_epu64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_max_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_max_epu64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_min_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_min_epu64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_min_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_min_epu64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_mul_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epi32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epi32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mul_epu32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mul_epu32(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mul_epu32(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhi_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhi_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhi_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhi_epu16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullo_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mullo_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mullox_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mullox_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_mulhrs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_mulhrs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_mulhrs_epi16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_load_epi32(void const*);
extern __m512i __cdecl _mm512_mask_load_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_load_epi64(void const*);
extern __m512i __cdecl _mm512_mask_load_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_load_epi64(__mmask8, void const*);
extern __m512i __cdecl _mm512_loadu_epi8(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi8(__m512i, __mmask64, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi8(__mmask64, void const*);
extern __m512i __cdecl _mm512_loadu_epi16(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi16(__m512i, __mmask32, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi16(__mmask32, void const*);
extern __m512i __cdecl _mm512_loadu_epi32(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_loadu_epi64(void const*);
extern __m512i __cdecl _mm512_mask_loadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_loadu_epi64(__mmask8, void const*);

extern void    __cdecl _mm512_store_epi32(void*, __m512i);
extern void    __cdecl _mm512_mask_store_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_store_epi64(void*, __m512i);
extern void    __cdecl _mm512_mask_store_epi64(void*, __mmask8, __m512i);
extern void    __cdecl _mm512_storeu_epi8(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_storeu_epi16(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_storeu_epi32(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_storeu_epi64(void*, __m512i);
extern void    __cdecl _mm512_mask_storeu_epi64(void*, __mmask8, __m512i);

extern __m128i __cdecl _mm512_extracti32x4_epi32(__m512i, int);
extern __m128i __cdecl _mm512_mask_extracti32x4_epi32(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti32x4_epi32(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_extracti32x8_epi32(__m512i, int);
extern __m256i __cdecl _mm512_mask_extracti32x8_epi32(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti32x8_epi32(__mmask8, __m512i, int);
extern __m128i __cdecl _mm512_extracti64x2_epi64(__m512i, int);
extern __m128i __cdecl _mm512_mask_extracti64x2_epi64(__m128i, __mmask8, __m512i, int);
extern __m128i __cdecl _mm512_maskz_extracti64x2_epi64(__mmask8, __m512i, int);
extern __m256i __cdecl _mm512_extracti64x4_epi64(__m512i, int);
extern __m256i __cdecl _mm512_mask_extracti64x4_epi64(__m256i, __mmask8, __m512i, int);
extern __m256i __cdecl _mm512_maskz_extracti64x4_epi64(__mmask8, __m512i, int);

extern __m512i __cdecl _mm512_inserti32x4(__m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti32x4(__m512i, __mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x4(__mmask16, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_inserti32x8(__m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_inserti32x8(__m512i, __mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti32x8(__mmask16, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_inserti64x2(__m512i, __m128i, int);
extern __m512i __cdecl _mm512_mask_inserti64x2(__m512i, __mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x2(__mmask8, __m512i, __m128i, int);
extern __m512i __cdecl _mm512_inserti64x4(__m512i, __m256i, int);
extern __m512i __cdecl _mm512_mask_inserti64x4(__m512i, __mmask8, __m512i, __m256i, int);
extern __m512i __cdecl _mm512_maskz_inserti64x4(__mmask8, __m512i, __m256i, int);

extern __m512i __cdecl _mm512_shuffle_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shuffle_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shuffle_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_shuffle_epi32(__m512i, int);
extern __m512i __cdecl _mm512_mask_shuffle_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shuffle_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_shuffle_i32x4(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shuffle_i32x4(__m512i, __mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i32x4(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_shuffle_i64x2(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_shuffle_i64x2(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_shuffle_i64x2(__mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_shufflehi_epi16(__m512i, int);
extern __m512i __cdecl _mm512_mask_shufflehi_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflehi_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_shufflelo_epi16(__m512i, int);
extern __m512i __cdecl _mm512_mask_shufflelo_epi16(__m512i, __mmask32, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shufflelo_epi16(__mmask32, __m512i, int);

extern __m512  __cdecl _mm512_mask_mov_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_mov_ps(__mmask16, __m512);
extern __m512d __cdecl _mm512_mask_mov_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_mov_pd(__mmask8, __m512d);
extern __m512i __cdecl _mm512_mask_mov_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_mov_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_mov_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_movedup_pd(__m512d);
extern __m512d __cdecl _mm512_mask_movedup_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_movedup_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_movehdup_ps(__m512);
extern __m512  __cdecl _mm512_mask_movehdup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_movehdup_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_moveldup_ps(__m512);
extern __m512  __cdecl _mm512_mask_moveldup_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_moveldup_ps(__mmask16, __m512);

extern __m512i __cdecl _mm512_movm_epi8(__mmask64);
extern __m512i __cdecl _mm512_movm_epi16(__mmask32);
extern __m512i __cdecl _mm512_movm_epi32(__mmask16);
extern __m512i __cdecl _mm512_movm_epi64(__mmask8);
extern __mmask64 __cdecl _mm512_movepi8_mask(__m512i);
extern __mmask32 __cdecl _mm512_movepi16_mask(__m512i);
extern __mmask16 __cdecl _mm512_movepi32_mask(__m512i);
extern __mmask8  __cdecl _mm512_movepi64_mask(__m512i);

extern __m512i __cdecl _mm512_alignr_epi8(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi8(__m512i, __mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi8(__mmask64, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_alignr_epi32(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi32(__m512i, __mmask16, __m512i, __m512i, const int );
extern __m512i __cdecl _mm512_maskz_alignr_epi32(__mmask16, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_alignr_epi64(__m512i, __m512i, const int);
extern __m512i __cdecl _mm512_mask_alignr_epi64(__m512i, __mmask8, __m512i, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_alignr_epi64(__mmask8, __m512i, __m512i, const int);

extern __m512d __cdecl _mm512_and_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_and_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_and_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_and_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_and_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_and_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_and_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_and_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_and_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_and_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_and_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_andnot_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_andnot_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_andnot_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_andnot_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_andnot_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_andnot_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_andnot_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_andnot_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_andnot_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_andnot_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_andnot_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_or_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_or_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_or_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_or_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_or_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_or_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_or_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_or_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_or_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_or_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_or_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_xor_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_xor_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_xor_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_xor_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_xor_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_xor_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_xor_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_xor_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_xor_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_xor_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_xor_epi64(__mmask8, __m512i, __m512i);

extern __m512  __cdecl _mm512_mask_blend_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_mask_blend_pd(__mmask8, __m512d, __m512d);
extern __m512i __cdecl _mm512_mask_blend_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_blend_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_sll_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_sll_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_sll_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_slli_epi16(__m512i, unsigned int);
extern __m512i __cdecl _mm512_slli_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_slli_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_sllv_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_sllv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_sllv_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_sll_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sll_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sll_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_slli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_slli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_slli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_sllv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_sllv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_sllv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_srl_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_srl_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_srl_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_srli_epi16(__m512i, int);
extern __m512i __cdecl _mm512_srli_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srli_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srlv_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_srlv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_srlv_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_srl_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srl_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_srl_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srli_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi16(__mmask32, __m512i, int);
extern __m512i __cdecl _mm512_mask_srli_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srli_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srli_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srlv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srlv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srlv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_sra_epi16(__m512i, __m128i);
extern __m512i __cdecl _mm512_sra_epi32(__m512i, __m128i);
extern __m512i __cdecl _mm512_sra_epi64(__m512i, __m128i);
extern __m512i __cdecl _mm512_srai_epi16(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srai_epi32(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srai_epi64(__m512i, unsigned int);
extern __m512i __cdecl _mm512_srav_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_srav_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_srav_epi64(__m512i, __m512i);

extern __m512i __cdecl _mm512_mask_sra_epi16(__m512i, __mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi16(__mmask32, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi32(__m512i, __mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi32(__mmask16, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_sra_epi64(__m512i, __mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_maskz_sra_epi64(__mmask8, __m512i, __m128i);
extern __m512i __cdecl _mm512_mask_srai_epi16(__m512i, __mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi16(__mmask32, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi32(__m512i, __mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi32(__mmask16, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srai_epi64(__m512i, __mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_maskz_srai_epi64(__mmask8, __m512i, unsigned int);
extern __m512i __cdecl _mm512_mask_srav_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_srav_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_srav_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_bslli_epi128(__m512i, int);
extern __m512i __cdecl _mm512_bsrli_epi128(__m512i, int);

extern __m512i __cdecl _mm512_rol_epi32(__m512i, const int);
extern __m512i __cdecl _mm512_mask_rol_epi32(__m512i, __mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi32(__mmask16, __m512i, const int);
extern __m512i __cdecl _mm512_rol_epi64(__m512i, const int);
extern __m512i __cdecl _mm512_mask_rol_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_rol_epi64(__mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_rolv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rolv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_rolv_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rolv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rolv_epi64(__mmask8, __m512i, __m512i);

extern __m512i __cdecl _mm512_ror_epi32(__m512i, int);
extern __m512i __cdecl _mm512_mask_ror_epi32(__m512i, __mmask16, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi32(__mmask16, __m512i, int);
extern __m512i __cdecl _mm512_ror_epi64(__m512i, int);
extern __m512i __cdecl _mm512_mask_ror_epi64(__m512i, __mmask8, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ror_epi64(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_rorv_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rorv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_rorv_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_rorv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_rorv_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_unpackhi_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_unpackhi_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpackhi_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_unpackhi_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_unpackhi_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpackhi_ps(__mmask16, __m512, __m512);
extern __m512d __cdecl _mm512_unpacklo_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_unpacklo_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_unpacklo_pd(__mmask8, __m512d, __m512d);
extern __m512  __cdecl _mm512_unpacklo_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_unpacklo_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_unpacklo_ps(__mmask16, __m512, __m512);
extern __m512i __cdecl _mm512_unpackhi_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpackhi_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpackhi_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpackhi_epi64(__mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_unpacklo_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_unpacklo_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_unpacklo_epi64(__mmask8, __m512i, __m512i);

extern __m512  __cdecl _mm512_getexp_ps(__m512);
extern __m512  __cdecl _mm512_mask_getexp_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_getexp_ps(__mmask16, __m512);
extern __m512  __cdecl _mm512_getexp_round_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_getexp_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_getexp_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_getexp_pd(__m512d);
extern __m512d __cdecl _mm512_mask_getexp_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_getexp_pd(__mmask8, __m512d);
extern __m512d __cdecl _mm512_getexp_round_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_getexp_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_getexp_round_pd(__mmask8, __m512d, int);

extern __m512  __cdecl _mm512_getmant_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_getmant_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_getmant_ps(__mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_getmant_round_ps(__m512, int, int, int);
extern __m512  __cdecl _mm512_mask_getmant_round_ps(__m512, __mmask16, __m512, int, int, int);
extern __m512  __cdecl _mm512_maskz_getmant_round_ps(__mmask16, __m512, int, int, int);
extern __m512d __cdecl _mm512_getmant_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_getmant_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_getmant_pd(__mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_getmant_round_pd(__m512d, int, int, int);
extern __m512d __cdecl _mm512_mask_getmant_round_pd(__m512d, __mmask8, __m512d, int, int, int);
extern __m512d __cdecl _mm512_maskz_getmant_round_pd(__mmask8, __m512d, int, int, int);

extern __m512d __cdecl _mm512_permute_pd(__m512d, const int);
extern __m512d __cdecl _mm512_mask_permute_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permute_pd(__mmask8, __m512d, const int);
extern __m512  __cdecl _mm512_permute_ps(__m512, const int);
extern __m512  __cdecl _mm512_mask_permute_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_permute_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_permutevar_pd(__m512d, __m512i);
extern __m512d __cdecl _mm512_mask_permutevar_pd(__m512d, __mmask8, __m512d, __m512i);
extern __m512d __cdecl _mm512_maskz_permutevar_pd(__mmask8, __m512d, __m512i);
extern __m512  __cdecl _mm512_permutevar_ps(__m512, __m512i);
extern __m512  __cdecl _mm512_mask_permutevar_ps(__m512, __mmask16, __m512, __m512i);
extern __m512  __cdecl _mm512_maskz_permutevar_ps(__mmask16, __m512, __m512i);
extern __m512i __cdecl _mm512_permutevar_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutevar_epi32(__m512i, __mmask16, __m512i, __m512i);

extern __m512d __cdecl _mm512_permutex_pd(__m512d, const int);
extern __m512d __cdecl _mm512_mask_permutex_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_permutex_pd(__mmask8, __m512d, const int);
extern __m512i __cdecl _mm512_permutex_epi64(__m512i, const int);
extern __m512i __cdecl _mm512_mask_permutex_epi64(__m512i, __mmask8, __m512i, const int);
extern __m512i __cdecl _mm512_maskz_permutex_epi64(__mmask8, __m512i, const int);
extern __m512d __cdecl _mm512_permutexvar_pd(__m512i, __m512d);
extern __m512d __cdecl _mm512_mask_permutexvar_pd(__m512d, __mmask8, __m512i, __m512d);
extern __m512d __cdecl _mm512_maskz_permutexvar_pd(__mmask8, __m512i, __m512d);
extern __m512  __cdecl _mm512_permutexvar_ps(__m512i, __m512);
extern __m512  __cdecl _mm512_mask_permutexvar_ps(__m512, __mmask16, __m512i, __m512);
extern __m512  __cdecl _mm512_maskz_permutexvar_ps(__mmask16, __m512i, __m512);
extern __m512i __cdecl _mm512_permutexvar_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi16(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_permutexvar_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi32(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_permutexvar_epi64(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi64(__mmask8, __m512i, __m512i);

extern __m512d __cdecl _mm512_permutex2var_pd(__m512d, __m512i , __m512d);
extern __m512d __cdecl _mm512_mask_permutex2var_pd(__m512d, __mmask8, __m512i , __m512d);
extern __m512d __cdecl _mm512_mask2_permutex2var_pd(__m512d, __m512i , __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_permutex2var_pd(__mmask8, __m512d, __m512i , __m512d);
extern __m512  __cdecl _mm512_permutex2var_ps(__m512, __m512i , __m512);
extern __m512  __cdecl _mm512_mask_permutex2var_ps(__m512, __mmask16, __m512i , __m512);
extern __m512  __cdecl _mm512_mask2_permutex2var_ps(__m512, __m512i , __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_permutex2var_ps(__mmask16, __m512, __m512i , __m512);
extern __m512i __cdecl _mm512_permutex2var_epi16(__m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi16(__m512i, __mmask32, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi16(__m512i, __m512i , __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi16(__mmask32, __m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_permutex2var_epi32(__m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi32(__m512i, __mmask16, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi32(__m512i, __m512i , __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi32(__mmask16, __m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_permutex2var_epi64(__m512i, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi64(__m512i, __mmask8, __m512i , __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi64(__m512i, __m512i , __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi64(__mmask8, __m512i, __m512i , __m512i);

extern __m512d __cdecl _mm512_mask_compress_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_compress_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_compress_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_compress_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_compress_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_compress_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_compress_epi64(__mmask8, __m512i);

extern void    __cdecl _mm512_mask_compressstoreu_pd(void*, __mmask8, __m512d);
extern void    __cdecl _mm512_mask_compressstoreu_ps(void*, __mmask16, __m512);
extern void    __cdecl _mm512_mask_compressstoreu_epi8(void*, __mmask64, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi16(void*, __mmask32, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi32(void*, __mmask16, __m512i);
extern void    __cdecl _mm512_mask_compressstoreu_epi64(void*, __mmask8, __m512i);

extern __m512d __cdecl _mm512_mask_expand_pd(__m512d, __mmask8, __m512d);
extern __m512d __cdecl _mm512_maskz_expand_pd(__mmask8, __m512d);
extern __m512  __cdecl _mm512_mask_expand_ps(__m512, __mmask16, __m512);
extern __m512  __cdecl _mm512_maskz_expand_ps(__mmask16, __m512);
extern __m512i __cdecl _mm512_mask_expand_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi8(__mmask64, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi16(__mmask32, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_mask_expand_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_expand_epi64(__mmask8, __m512i);
extern __m512d __cdecl _mm512_mask_expandloadu_pd(__m512d, __mmask8, void const*);
extern __m512d __cdecl _mm512_maskz_expandloadu_pd(__mmask8, void const*);
extern __m512  __cdecl _mm512_mask_expandloadu_ps(__m512, __mmask16, void const*);
extern __m512  __cdecl _mm512_maskz_expandloadu_ps(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi8(__m512i, __mmask64, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi8(__mmask64, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi16(__m512i, __mmask32, const void*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi16(__mmask32, const void*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi32(__m512i, __mmask16, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi32(__mmask16, void const*);
extern __m512i __cdecl _mm512_mask_expandloadu_epi64(__m512i, __mmask8, void const*);
extern __m512i __cdecl _mm512_maskz_expandloadu_epi64(__mmask8, void const*);

extern __m512i __cdecl _mm512_ternarylogic_epi32(__m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi32(__mmask16, __m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_ternarylogic_epi64(__m512i, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_ternarylogic_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_ternarylogic_epi64(__mmask8, __m512i, __m512i, __m512i, int);

extern __m512i __cdecl _mm512_conflict_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_conflict_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_conflict_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_conflict_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_conflict_epi64(__mmask8, __m512i);

extern __m512i __cdecl _mm512_lzcnt_epi8(__m512i);
extern __m256i __cdecl _mm256_lzcnt_epi8(__m256i);
extern __m128i __cdecl _mm_lzcnt_epi8(__m128i);

extern __m512i __cdecl _mm512_lzcnt_epi16(__m512i);
extern __m256i __cdecl _mm256_lzcnt_epi16(__m256i);
extern __m128i __cdecl _mm_lzcnt_epi16(__m128i);

extern __m512i __cdecl _mm512_lzcnt_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi32(__mmask16, __m512i);
extern __m512i __cdecl _mm512_lzcnt_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_lzcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_lzcnt_epi64(__mmask8, __m512i);

extern __m512i __cdecl _mm512_avg_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu8(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_avg_epu16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_avg_epu16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_avg_epu16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_sad_epu8(__m512i, __m512i);
extern __m512i __cdecl _mm512_dbsad_epu8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_dbsad_epu8(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_dbsad_epu8(__mmask32, __m512i, __m512i, int);

extern float   __cdecl _mm512_reduce_add_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_add_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_add_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_add_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_add_epi8(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi8(__mmask64, __m512i);
extern int     __cdecl _mm512_reduce_add_epi16(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi16(__mmask32, __m512i);
extern int     __cdecl _mm512_reduce_add_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_add_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_add_epi64(__mmask8, __m512i);
extern int     __cdecl _mm512_reduce_add_epu8(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epu8(__mmask64, __m512i);
extern int     __cdecl _mm512_reduce_add_epu16(__m512i);
extern int     __cdecl _mm512_mask_reduce_add_epu16(__mmask32, __m512i);

extern float   __cdecl _mm512_reduce_mul_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_mul_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_mul_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_mul_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_mul_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_mul_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_mul_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_mul_epi64(__mmask8, __m512i);

extern float   __cdecl _mm512_reduce_min_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_min_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_min_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_min_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_min_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_min_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_min_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_min_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_min_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_min_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_min_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_min_epu64(__mmask8, __m512i);

extern float   __cdecl _mm512_reduce_max_ps(__m512);
extern float   __cdecl _mm512_mask_reduce_max_ps(__mmask16, __m512);
extern double  __cdecl _mm512_reduce_max_pd(__m512d);
extern double  __cdecl _mm512_mask_reduce_max_pd(__mmask8, __m512d);
extern int     __cdecl _mm512_reduce_max_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_max_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_max_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_max_epi64(__mmask8, __m512i);
extern unsigned int     __cdecl _mm512_reduce_max_epu32(__m512i);
extern unsigned int     __cdecl _mm512_mask_reduce_max_epu32(__mmask16, __m512i);
extern unsigned __int64 __cdecl _mm512_reduce_max_epu64(__m512i);
extern unsigned __int64 __cdecl _mm512_mask_reduce_max_epu64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_and_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_and_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_and_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_and_epi64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_or_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_or_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_or_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_or_epi64(__mmask8, __m512i);

extern int     __cdecl _mm512_reduce_xor_epi32(__m512i);
extern int     __cdecl _mm512_mask_reduce_xor_epi32(__mmask16, __m512i);
extern __int64 __cdecl _mm512_reduce_xor_epi64(__m512i);
extern __int64 __cdecl _mm512_mask_reduce_xor_epi64(__mmask8, __m512i);

extern __m512d __cdecl _mm512_reduce_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_reduce_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_reduce_pd(__mmask8, __m512d, int);
extern __m512d __cdecl _mm512_reduce_round_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_reduce_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_reduce_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_reduce_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_reduce_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_reduce_ps(__mmask16, __m512, int);
extern __m512  __cdecl _mm512_reduce_round_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_reduce_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_reduce_round_ps(__mmask16, __m512, int, int);

extern __m512d __cdecl _mm512_roundscale_pd(__m512d, int);
extern __m512d __cdecl _mm512_mask_roundscale_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_roundscale_pd(__mmask8, __m512d, int);
extern __m512d __cdecl _mm512_roundscale_round_pd(__m512d, int, int);
extern __m512d __cdecl _mm512_mask_roundscale_round_pd(__m512d, __mmask8, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_roundscale_round_pd(__mmask8, __m512d, int, int);
extern __m512  __cdecl _mm512_roundscale_ps(__m512, int);
extern __m512  __cdecl _mm512_mask_roundscale_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_roundscale_ps(__mmask16, __m512, int);
extern __m512  __cdecl _mm512_roundscale_round_ps(__m512, int, int);
extern __m512  __cdecl _mm512_mask_roundscale_round_ps(__m512, __mmask16, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_roundscale_round_ps(__mmask16, __m512, int, int);

extern __m512d __cdecl _mm512_scalef_pd(__m512d, __m512d);
extern __m512d __cdecl _mm512_mask_scalef_pd(__m512d, __mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_maskz_scalef_pd(__mmask8, __m512d, __m512d);
extern __m512d __cdecl _mm512_scalef_round_pd(__m512d, __m512d, int);
extern __m512d __cdecl _mm512_mask_scalef_round_pd(__m512d, __mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_maskz_scalef_round_pd(__mmask8, __m512d, __m512d, int);
extern __m512  __cdecl _mm512_scalef_ps(__m512, __m512);
extern __m512  __cdecl _mm512_mask_scalef_ps(__m512, __mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_maskz_scalef_ps(__mmask16, __m512, __m512);
extern __m512  __cdecl _mm512_scalef_round_ps(__m512, __m512, int);
extern __m512  __cdecl _mm512_mask_scalef_round_ps(__m512, __mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_maskz_scalef_round_ps(__mmask16, __m512, __m512, int);

extern __m512d __cdecl _mm512_fixupimm_pd(__m512d, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_mask_fixupimm_pd(__m512d, __mmask8, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_maskz_fixupimm_pd(__mmask8, __m512d, __m512d, __m512i, const int);
extern __m512d __cdecl _mm512_fixupimm_round_pd(__m512d, __m512d, __m512i, const int, const int);
extern __m512d __cdecl _mm512_mask_fixupimm_round_pd(__m512d, __mmask8, __m512d, __m512i, const int, const int);
extern __m512d __cdecl _mm512_maskz_fixupimm_round_pd(__mmask8, __m512d, __m512d, __m512i, const int, const int);
extern __m512  __cdecl _mm512_fixupimm_ps(__m512, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_mask_fixupimm_ps(__m512, __mmask16, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_maskz_fixupimm_ps(__mmask16, __m512, __m512, __m512i, const int);
extern __m512  __cdecl _mm512_fixupimm_round_ps(__m512, __m512, __m512i, const int, const int);
extern __m512  __cdecl _mm512_mask_fixupimm_round_ps(__m512, __mmask16, __m512, __m512i, const int, const int);
extern __m512  __cdecl _mm512_maskz_fixupimm_round_ps(__mmask16, __m512, __m512, __m512i, const int, const int);

extern void    __cdecl _mm512_stream_pd(void*, __m512d);
extern void    __cdecl _mm512_stream_ps(void*, __m512);
extern void    __cdecl _mm512_stream_si512(void*, __m512i);
extern __m512i __cdecl _mm512_stream_load_si512(void const*);

extern __m128d __cdecl _mm512_castpd512_pd128(__m512d);
extern __m128  __cdecl _mm512_castps512_ps128(__m512);
extern __m128i __cdecl _mm512_castsi512_si128(__m512i);
extern __m512i __cdecl _mm512_castsi128_si512(__m128i);

extern __mmask16 __cdecl _mm512_fpclass_ps_mask(__m512, int);
extern __mmask16 __cdecl _mm512_mask_fpclass_ps_mask(__mmask16, __m512, int);
extern __mmask8  __cdecl _mm512_fpclass_pd_mask(__m512d, int);
extern __mmask8  __cdecl _mm512_mask_fpclass_pd_mask(__mmask8, __m512d, int);

extern __m512d __cdecl _mm512_range_pd(__m512d, __m512d, int);
extern __m512d __cdecl _mm512_mask_range_pd(__m512d, __mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_maskz_range_pd(__mmask8, __m512d, __m512d, int);
extern __m512d __cdecl _mm512_range_round_pd(__m512d, __m512d, int, int);
extern __m512d __cdecl _mm512_mask_range_round_pd(__m512d, __mmask8, __m512d, __m512d, int, int);
extern __m512d __cdecl _mm512_maskz_range_round_pd(__mmask8, __m512d, __m512d, int, int);
extern __m512  __cdecl _mm512_range_ps(__m512, __m512, int);
extern __m512  __cdecl _mm512_mask_range_ps(__m512, __mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_maskz_range_ps(__mmask16, __m512, __m512, int);
extern __m512  __cdecl _mm512_range_round_ps(__m512, __m512, int, int);
extern __m512  __cdecl _mm512_mask_range_round_ps(__m512, __mmask16, __m512, __m512, int, int);
extern __m512  __cdecl _mm512_maskz_range_round_ps(__mmask16, __m512, __m512, int, int);

extern __m512i __cdecl _mm512_madd_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd_epi16(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd_epi16(__mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maddubs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_maddubs_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_maddubs_epi16(__mmask32, __m512i, __m512i);

extern __m512i __cdecl _mm512_packs_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_packs_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packs_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packs_epi32(__mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_packus_epi16(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi16(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi16(__mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_packus_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_packus_epi32(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_packus_epi32(__mmask32, __m512i, __m512i);

extern __mmask64 __cdecl _mm512_cmp_epi8_mask(__m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_cmp_epi8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_cmp_epi16_mask(__m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epi16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_cmp_epi32_mask(__m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epi32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_cmp_epi64_mask(__m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epi64_mask(__mmask8, __m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_cmp_epu8_mask(__m512i, __m512i, const int);
extern __mmask64 __cdecl _mm512_mask_cmp_epu8_mask(__mmask64, __m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_cmp_epu16_mask(__m512i, __m512i, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_epu16_mask(__mmask32, __m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_cmp_epu32_mask(__m512i, __m512i, const int);
extern __mmask16 __cdecl _mm512_mask_cmp_epu32_mask(__mmask16, __m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_cmp_epu64_mask(__m512i, __m512i, const int);
extern __mmask8  __cdecl _mm512_mask_cmp_epu64_mask(__mmask8, __m512i, __m512i, const int);

extern __mmask64 __cdecl _mm512_test_epi8_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_test_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_test_epi16_mask(__m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_test_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask64 __cdecl _mm512_testn_epi8_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_testn_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask32 __cdecl _mm512_testn_epi16_mask(__m512i, __m512i);
extern __mmask32 __cdecl _mm512_mask_testn_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_test_epi32_mask(__m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_test_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_test_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_test_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask16 __cdecl _mm512_testn_epi32_mask(__m512i, __m512i);
extern __mmask16 __cdecl _mm512_mask_testn_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_testn_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_testn_epi64_mask(__mmask8, __m512i, __m512i);

extern __mmask16 __cdecl _mm512_kunpackb(__mmask16, __mmask16);
extern __mmask32 __cdecl _mm512_kunpackw(__mmask32, __mmask32);
extern __mmask64 __cdecl _mm512_kunpackd(__mmask64, __mmask64);

extern unsigned char __cdecl _mm512_testz_and_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_and_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_and_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_and_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_andn_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_andn_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_andn_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_andn_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_or_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_or_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_or_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_or_mask64(__mmask64, __mmask64);
extern unsigned char __cdecl _mm512_testz_nor_mask8(__mmask8, __mmask8);
extern unsigned char __cdecl _mm512_testz_nor_mask16(__mmask16, __mmask16);
extern unsigned char __cdecl _mm512_testz_nor_mask32(__mmask32, __mmask32);
extern unsigned char __cdecl _mm512_testz_nor_mask64(__mmask64, __mmask64);

extern __m512  __cdecl _mm512_i32gather_ps(__m512i, void const*, int);
extern __m512  __cdecl _mm512_mask_i32gather_ps(__m512, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_ps(void*, __m512i, __m512, int);
extern void    __cdecl _mm512_mask_i32scatter_ps(void*, __mmask16, __m512i, __m512, int);
extern __m512d __cdecl _mm512_i64gather_pd(__m512i, void const*, int);
extern __m512d __cdecl _mm512_mask_i64gather_pd(__m512d, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_pd(void*, __m512i, __m512d, int);
extern void    __cdecl _mm512_mask_i64scatter_pd(void*, __mmask8, __m512i, __m512d, int);
extern __m512d __cdecl _mm512_i32gather_pd(__m256i, void const*, int);
extern __m512d __cdecl _mm512_mask_i32gather_pd(__m512d, __mmask8, __m256i, void const*, int);
extern void    __cdecl _mm512_i32scatter_pd(void*, __m256i, __m512d, int);
extern void    __cdecl _mm512_mask_i32scatter_pd(void*, __mmask8, __m256i, __m512d, int);
extern __m512i __cdecl _mm512_i32gather_epi32(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi32(__m512i, __mmask16, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi32(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi32(void*, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_i32gather_epi64(__m256i, void const*, int);
extern __m512i __cdecl _mm512_mask_i32gather_epi64(__m512i, __mmask8, __m256i, void const*, int);
extern __m512i __cdecl _mm512_i64gather_epi64(__m512i, void const*, int);
extern __m512i __cdecl _mm512_mask_i64gather_epi64(__m512i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i32scatter_epi64(void*, __m256i, __m512i, int);
extern void    __cdecl _mm512_mask_i32scatter_epi64(void*, __mmask8, __m256i, __m512i, int);
extern void    __cdecl _mm512_i64scatter_epi64(void*, __m512i, __m512i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi64(void*, __mmask8, __m512i, __m512i, int);
extern __m256  __cdecl _mm512_i64gather_ps(__m512i, void const*, int);
extern __m256  __cdecl _mm512_mask_i64gather_ps(__m256, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_ps(void*, __m512i, __m256, int);
extern void    __cdecl _mm512_mask_i64scatter_ps(void*, __mmask8, __m512i, __m256, int);
extern __m256i __cdecl _mm512_i64gather_epi32(__m512i, void const*, int);
extern __m256i __cdecl _mm512_mask_i64gather_epi32(__m256i, __mmask8, __m512i, void const*, int);
extern void    __cdecl _mm512_i64scatter_epi32(void*, __m512i, __m256i, int);
extern void    __cdecl _mm512_mask_i64scatter_epi32(void*, __mmask8, __m512i, __m256i, int);

extern __m512d __cdecl _mm512_cvtpslo_pd(__m512);
extern __m512d __cdecl _mm512_mask_cvtpslo_pd(__m512d, __mmask8, __m512);
extern __m512d __cdecl _mm512_cvtepi32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepi32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_cvtepu32lo_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepu32lo_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_cvtepi32_pd(__m256i);
extern __m512d __cdecl _mm512_mask_cvtepi32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepi32_pd(__mmask8, __m256i);
extern __m512d __cdecl _mm512_cvtepu32_pd(__m256i);
extern __m512d __cdecl _mm512_mask_cvtepu32_pd(__m512d, __mmask8, __m256i);
extern __m512d __cdecl _mm512_maskz_cvtepu32_pd(__mmask8, __m256i);

extern __m512  __cdecl _mm512_cvtepi32_ps( __m512i);
extern __m512  __cdecl _mm512_mask_cvtepi32_ps(__m512, __mmask16, __m512i);
extern __m512  __cdecl _mm512_maskz_cvtepi32_ps(__mmask16, __m512i);
extern __m512  __cdecl _mm512_cvt_roundepi32_ps(__m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundepi32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepi32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_cvtepu32_ps( __m512i);
extern __m512  __cdecl _mm512_mask_cvtepu32_ps(__m512, __mmask16, __m512i);
extern __m512  __cdecl _mm512_maskz_cvtepu32_ps(__mmask16, __m512i);
extern __m512  __cdecl _mm512_cvt_roundepu32_ps(__m512i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundepu32_ps(__m512, __mmask16, __m512i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundepu32_ps(__mmask16, __m512i, int);
extern __m512  __cdecl _mm512_cvtph_ps(__m256i);
extern __m512  __cdecl _mm512_mask_cvtph_ps(__m512, __mmask16, __m256i);
extern __m512  __cdecl _mm512_maskz_cvtph_ps(__mmask16, __m256i);
extern __m512  __cdecl _mm512_cvt_roundph_ps(__m256i, int);
extern __m512  __cdecl _mm512_mask_cvt_roundph_ps(__m512, __mmask16, __m256i, int);
extern __m512  __cdecl _mm512_maskz_cvt_roundph_ps(__mmask16, __m256i, int);
extern __m256i __cdecl _mm512_cvtps_ph(__m512, int);
extern __m256i __cdecl _mm512_mask_cvtps_ph(__m256i, __mmask16, __m512, int);
extern __m256i __cdecl _mm512_maskz_cvtps_ph(__mmask16, __m512, int);
extern __m256i __cdecl _mm512_cvt_roundps_ph(__m512, int);
extern __m256i __cdecl _mm512_mask_cvt_roundps_ph(__m256i, __mmask16, __m512, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundps_ph(__mmask16, __m512, int);
extern __m256  __cdecl _mm512_cvtepi64_ps(__m512i);
extern __m256  __cdecl _mm512_mask_cvtepi64_ps(__m256, __mmask8, __m512i);
extern __m256  __cdecl _mm512_maskz_cvtepi64_ps(__mmask8, __m512i);
extern __m256  __cdecl _mm512_cvt_roundepi64_ps(__m512i, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepi64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepi64_ps(__mmask8, __m512i, int);
extern __m256  __cdecl _mm512_cvtepu64_ps(__m512i);
extern __m256  __cdecl _mm512_mask_cvtepu64_ps(__m256, __mmask8, __m512i);
extern __m256  __cdecl _mm512_maskz_cvtepu64_ps(__mmask8, __m512i);
extern __m256  __cdecl _mm512_cvt_roundepu64_ps(__m512i, int);
extern __m256  __cdecl _mm512_mask_cvt_roundepu64_ps(__m256, __mmask8, __m512i, int);
extern __m256  __cdecl _mm512_maskz_cvt_roundepu64_ps(__mmask8, __m512i, int);

extern __m512i __cdecl _mm512_cvtepi8_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_cvtepi8_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepi16_epi32(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_cvtepi16_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepi16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i __cdecl _mm512_cvtepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_cvtsepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m128i __cdecl _mm512_cvtusepi32_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi32_epi8(__m128i, __mmask16, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi32_epi8(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi8(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtsepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m256i __cdecl _mm512_cvtusepi32_epi16(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi32_epi16(__m256i, __mmask16, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi32_epi16(__mmask16, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi32_storeu_epi16(void*, __mmask16, __m512i);
extern __m512i __cdecl _mm512_cvtepi32_epi64(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi32_epi64(__mmask8, __m256i);
extern __m128i __cdecl _mm512_cvtepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtsepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtusepi64_epi8(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi8(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi8(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtsepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtsepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtsepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m128i __cdecl _mm512_cvtusepi64_epi16(__m512i);
extern __m128i __cdecl _mm512_mask_cvtusepi64_epi16(__m128i, __mmask8, __m512i);
extern __m128i __cdecl _mm512_maskz_cvtusepi64_epi16(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtsepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m256i __cdecl _mm512_cvtusepi64_epi32(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi64_epi32(__m256i, __mmask8, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi64_epi32(__mmask8, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m512i);
extern __m512i __cdecl _mm512_cvtepu8_epi32(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi32(__m512i, __mmask16, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi32(__mmask16, __m128i);
extern __m512i __cdecl _mm512_cvtepu8_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepu16_epi32(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi32(__m512i, __mmask16, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi32(__mmask16, __m256i);
extern __m512i __cdecl _mm512_cvtepu16_epi64(__m128i);
extern __m512i __cdecl _mm512_mask_cvtepu16_epi64(__m512i, __mmask8, __m128i);
extern __m512i __cdecl _mm512_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m512i __cdecl _mm512_cvtepu32_epi64(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu32_epi64(__m512i, __mmask8, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu32_epi64(__mmask8, __m256i);

extern __m512i __cdecl _mm512_cvtps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_cvtps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvtps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvt_roundps_epi32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvttps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_cvttps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvttps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvtt_roundps_epi32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvtps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_cvtps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvtps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvt_roundps_epu32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu32(__mmask16, __m512, int);
extern __m512i __cdecl _mm512_cvttps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_cvttps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvttps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvtt_roundps_epu32(__m512, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu32(__m512i, __mmask16, __m512, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu32(__mmask16, __m512, int);
extern __m256i __cdecl _mm512_cvtpd_epi32(__m512d);
extern __m256i __cdecl _mm512_mask_cvtpd_epi32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvtpd_epi32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvt_roundpd_epi32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvttpd_epi32(__m512d);
extern __m256i __cdecl _mm512_mask_cvttpd_epi32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvttpd_epi32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvtt_roundpd_epi32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epi32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epi32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvtpd_epu32(__m512d);
extern __m256i __cdecl _mm512_mask_cvtpd_epu32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvtpd_epu32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvt_roundpd_epu32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvt_roundpd_epu32(__mmask8, __m512d, int);
extern __m256i __cdecl _mm512_cvttpd_epu32(__m512d);
extern __m256i __cdecl _mm512_mask_cvttpd_epu32(__m256i, __mmask8, __m512d);
extern __m256i __cdecl _mm512_maskz_cvttpd_epu32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvtt_roundpd_epu32(__m512d, int);
extern __m256i __cdecl _mm512_mask_cvtt_roundpd_epu32(__m256i, __mmask8, __m512d, int);
extern __m256i __cdecl _mm512_maskz_cvtt_roundpd_epu32(__mmask8, __m512d, int);

extern __m512i __cdecl _mm512_cvtepi8_epi16(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepi8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepi8_epi16(__mmask32, __m256i);
extern __m512i __cdecl _mm512_cvtepu8_epi16(__m256i);
extern __m512i __cdecl _mm512_mask_cvtepu8_epi16(__m512i, __mmask32, __m256i);
extern __m512i __cdecl _mm512_maskz_cvtepu8_epi16(__mmask32, __m256i);
extern __m256i __cdecl _mm512_cvtepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_cvtsepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtsepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtsepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtsepi16_storeu_epi8(void*, __mmask32, __m512i);
extern __m256i __cdecl _mm512_cvtusepi16_epi8(__m512i);
extern __m256i __cdecl _mm512_mask_cvtusepi16_epi8(__m256i, __mmask32, __m512i);
extern __m256i __cdecl _mm512_maskz_cvtusepi16_epi8(__mmask32, __m512i);
extern void    __cdecl _mm512_mask_cvtusepi16_storeu_epi8(void*, __mmask32, __m512i);

extern __m512d __cdecl _mm512_cvtepi64_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepi64_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_maskz_cvtepi64_pd(__mmask8, __m512i);
extern __m512d __cdecl _mm512_cvt_roundepi64_pd(__m512i, int);
extern __m512d __cdecl _mm512_mask_cvt_roundepi64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepi64_pd(__mmask8, __m512i, int);
extern __m512d __cdecl _mm512_cvtepu64_pd(__m512i);
extern __m512d __cdecl _mm512_mask_cvtepu64_pd(__m512d, __mmask8, __m512i);
extern __m512d __cdecl _mm512_maskz_cvtepu64_pd(__mmask8, __m512i);
extern __m512d __cdecl _mm512_cvt_roundepu64_pd(__m512i, int);
extern __m512d __cdecl _mm512_mask_cvt_roundepu64_pd(__m512d, __mmask8, __m512i, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundepu64_pd(__mmask8, __m512i, int);
extern __m512i __cdecl _mm512_cvtpd_epi64(__m512d);
extern __m512i __cdecl _mm512_mask_cvtpd_epi64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvtpd_epi64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvt_roundpd_epi64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvtpd_epu64(__m512d);
extern __m512i __cdecl _mm512_mask_cvtpd_epu64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvtpd_epu64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvt_roundpd_epu64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvttpd_epi64(__m512d);
extern __m512i __cdecl _mm512_mask_cvttpd_epi64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvttpd_epi64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtt_roundpd_epi64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epi64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epi64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvttpd_epu64(__m512d);
extern __m512i __cdecl _mm512_mask_cvttpd_epu64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvttpd_epu64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtt_roundpd_epu64(__m512d, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundpd_epu64(__m512i, __mmask8, __m512d, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundpd_epu64(__mmask8, __m512d, int);
extern __m512i __cdecl _mm512_cvtps_epi64(__m256);
extern __m512i __cdecl _mm512_mask_cvtps_epi64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvtps_epi64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvt_roundps_epi64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvtps_epu64(__m256);
extern __m512i __cdecl _mm512_mask_cvtps_epu64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvtps_epu64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvt_roundps_epu64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundps_epu64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvttps_epi64(__m256);
extern __m512i __cdecl _mm512_mask_cvttps_epi64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvttps_epi64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvtt_roundps_epi64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epi64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epi64(__mmask8, __m256, int);
extern __m512i __cdecl _mm512_cvttps_epu64(__m256);
extern __m512i __cdecl _mm512_mask_cvttps_epu64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvttps_epu64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvtt_roundps_epu64(__m256, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundps_epu64(__m512i, __mmask8, __m256, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundps_epu64(__mmask8, __m256, int);

extern __mmask64  __cdecl _mm512_cmpeq_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpge_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpgt_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmple_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmplt_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpneq_epi8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpeq_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpge_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpgt_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmple_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmplt_epu8_mask(__m512i, __m512i);
extern __mmask64  __cdecl _mm512_cmpneq_epu8_mask(__m512i, __m512i);

extern __mmask64  __cdecl _mm512_mask_cmpeq_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpge_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpgt_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmple_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmplt_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpneq_epi8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpeq_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpge_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpgt_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmple_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmplt_epu8_mask(__mmask64, __m512i, __m512i);
extern __mmask64  __cdecl _mm512_mask_cmpneq_epu8_mask(__mmask64, __m512i, __m512i);

extern __mmask32  __cdecl _mm512_cmpeq_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpge_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpgt_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmple_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmplt_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpneq_epi16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpeq_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpge_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpgt_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmple_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmplt_epu16_mask(__m512i, __m512i);
extern __mmask32  __cdecl _mm512_cmpneq_epu16_mask(__m512i, __m512i);

extern __mmask32  __cdecl _mm512_mask_cmpeq_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpge_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpgt_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmple_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmplt_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpneq_epi16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpeq_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpge_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpgt_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmple_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmplt_epu16_mask(__mmask32, __m512i, __m512i);
extern __mmask32  __cdecl _mm512_mask_cmpneq_epu16_mask(__mmask32, __m512i, __m512i);

extern __mmask16  __cdecl _mm512_cmpeq_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpge_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpgt_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmple_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmplt_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpneq_epi32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpeq_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpge_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpgt_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmple_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmplt_epu32_mask(__m512i, __m512i);
extern __mmask16  __cdecl _mm512_cmpneq_epu32_mask(__m512i, __m512i);

extern __mmask16  __cdecl _mm512_mask_cmpeq_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpge_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpgt_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmple_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmplt_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpneq_epi32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpeq_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpge_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpgt_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmple_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmplt_epu32_mask(__mmask16, __m512i, __m512i);
extern __mmask16  __cdecl _mm512_mask_cmpneq_epu32_mask(__mmask16, __m512i, __m512i);

extern __mmask8  __cdecl _mm512_cmpeq_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpge_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpgt_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmple_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmplt_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpneq_epi64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpeq_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpge_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpgt_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmple_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmplt_epu64_mask(__m512i, __m512i);
extern __mmask8  __cdecl _mm512_cmpneq_epu64_mask(__m512i, __m512i);

extern __mmask8  __cdecl _mm512_mask_cmpeq_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpge_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpgt_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmple_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmplt_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpneq_epi64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpeq_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpge_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpgt_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmple_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmplt_epu64_mask(__mmask8, __m512i, __m512i);
extern __mmask8  __cdecl _mm512_mask_cmpneq_epu64_mask(__mmask8, __m512i, __m512i);































































extern __m128i   __cdecl _mm_mask_abs_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_abs_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_abs_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_abs_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_abs_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_abs_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_abs_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_abs_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_abs_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_add_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_add_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_add_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_add_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_add_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_add_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_add_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_add_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_add_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_add_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_adds_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_adds_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_adds_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_adds_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_adds_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_alignr_epi32(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi32(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi32(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi32(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi32(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi32(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_alignr_epi64(__m128i, __m128i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi64(__m128i, __mmask8, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi64(__mmask8, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_alignr_epi64(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi64(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi64(__mmask8, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_mask_alignr_epi8(__m128i, __mmask16, __m128i, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_alignr_epi8(__mmask16, __m128i, __m128i, const int);
extern __m256i   __cdecl _mm256_mask_alignr_epi8(__m256i, __mmask32, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_alignr_epi8(__mmask32, __m256i, __m256i, const int);
extern __m128i   __cdecl _mm_and_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_and_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_and_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_and_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_and_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_and_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_and_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_and_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_and_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_and_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_and_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_and_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_and_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_and_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_and_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_and_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_and_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_and_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_andnot_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_andnot_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_andnot_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_andnot_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_andnot_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_andnot_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_andnot_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_andnot_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_andnot_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_andnot_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_andnot_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_andnot_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_andnot_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_andnot_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_andnot_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_andnot_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_andnot_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_andnot_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_avg_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_avg_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_avg_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_avg_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_avg_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_blend_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_blend_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_blend_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_blend_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_blend_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_blend_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_broadcast_f32x2(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x2(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x2(__mmask8, __m128);
extern __m256    __cdecl _mm256_broadcast_f32x4(__m128);
extern __m256    __cdecl _mm256_mask_broadcast_f32x4(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcast_f32x4(__mmask8, __m128);
extern __m256d   __cdecl _mm256_broadcast_f64x2(__m128d);
extern __m256d   __cdecl _mm256_mask_broadcast_f64x2(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcast_f64x2(__mmask8, __m128d);
extern __m128i   __cdecl _mm_broadcast_i32x2(__m128i);
extern __m128i   __cdecl _mm_mask_broadcast_i32x2(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x2(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i32x4(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i32x4(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i32x4(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_broadcast_i64x2(__m128i);
extern __m256i   __cdecl _mm256_mask_broadcast_i64x2(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcast_i64x2(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastb_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastb_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastb_epi8(__m256i, __mmask32, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastb_epi8(__mmask32, __m128i);
extern __m128i   __cdecl _mm_mask_broadcastd_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastd_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastd_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_broadcastmb_epi64(__mmask8);
extern __m256i   __cdecl _mm256_broadcastmb_epi64(__mmask8);
extern __m128i   __cdecl _mm_broadcastmw_epi32(__mmask16);
extern __m256i   __cdecl _mm256_broadcastmw_epi32(__mmask16);
extern __m128i   __cdecl _mm_mask_broadcastq_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastq_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastq_epi64(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_broadcastsd_pd(__m256d, __mmask8, __m128d);
extern __m256d   __cdecl _mm256_maskz_broadcastsd_pd(__mmask8, __m128d);
extern __m128    __cdecl _mm_mask_broadcastss_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_broadcastss_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_broadcastss_ps(__m256, __mmask8, __m128);
extern __m256    __cdecl _mm256_maskz_broadcastss_ps(__mmask8, __m128);
extern __m128i   __cdecl _mm_mask_broadcastw_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_broadcastw_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_broadcastw_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_broadcastw_epi16(__mmask16, __m128i);
extern __mmask8  __cdecl _mm_cmp_epi16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epi16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epi16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epi16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epi32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epi64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epi64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epi64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epi64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epi8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epi8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epi8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epi8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu16_mask(__m128i, __m128i, const int);
extern __mmask8  __cdecl _mm_mask_cmp_epu16_mask(__mmask8, __m128i, __m128i, const int);
extern __mmask16 __cdecl _mm256_cmp_epu16_mask(__m256i, __m256i, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_epu16_mask(__mmask16, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_epu32_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu32_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu32_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu32_mask(__mmask8, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_cmp_epu64_mask(__m128i, __m128i, int);
extern __mmask8  __cdecl _mm_mask_cmp_epu64_mask(__mmask8, __m128i, __m128i, int);
extern __mmask8  __cdecl _mm256_cmp_epu64_mask(__m256i, __m256i, int);
extern __mmask8  __cdecl _mm256_mask_cmp_epu64_mask(__mmask8, __m256i, __m256i, int);
extern __mmask16 __cdecl _mm_cmp_epu8_mask(__m128i, __m128i, const int);
extern __mmask16 __cdecl _mm_mask_cmp_epu8_mask(__mmask16, __m128i, __m128i, const int);
extern __mmask32 __cdecl _mm256_cmp_epu8_mask(__m256i, __m256i, const int);
extern __mmask32 __cdecl _mm256_mask_cmp_epu8_mask(__mmask32, __m256i, __m256i, const int);
extern __mmask8  __cdecl _mm_cmp_pd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_pd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm256_cmp_pd_mask(__m256d, __m256d, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_pd_mask(__mmask8, __m256d, __m256d, const int);
extern __mmask8  __cdecl _mm_cmp_ps_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ps_mask(__mmask8, __m128, __m128, const int);
extern __mmask8  __cdecl _mm256_cmp_ps_mask(__m256, __m256, const int);
extern __mmask8  __cdecl _mm256_mask_cmp_ps_mask(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_compress_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_compress_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_compress_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_compress_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_compress_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_compress_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_compress_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_compress_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_compress_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_compress_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_compress_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_compress_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_compress_ps(__mmask8, __m256);
extern void      __cdecl _mm_mask_compressstoreu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_compressstoreu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_compressstoreu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_compressstoreu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_compressstoreu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_compressstoreu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_conflict_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_conflict_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_conflict_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_conflict_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_conflict_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_conflict_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_conflict_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtps_ph(__m128i, __mmask8, __m128, int);
extern __m128i   __cdecl _mm_maskz_cvtps_ph(__mmask8, __m128, int);
extern __m128i   __cdecl _mm_mask_cvt_roundps_ph(__m128i, __mmask8, __m128, int);
extern __m128i   __cdecl _mm_maskz_cvt_roundps_ph(__mmask8, __m128, int);
extern __m128i   __cdecl _mm256_mask_cvtps_ph(__m128i, __mmask8, __m256, int);
extern __m128i   __cdecl _mm256_maskz_cvtps_ph(__mmask8, __m256, int);
extern __m128i   __cdecl _mm256_mask_cvt_roundps_ph(__m128i, __mmask8, __m256, int);
extern __m128i   __cdecl _mm256_maskz_cvt_roundps_ph(__mmask8, __m256, int);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_cvtepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi32_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_cvtepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi32_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_cvtepi32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_mask_cvtepi32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepi32_pd(__mmask8, __m128i);
extern __m128    __cdecl _mm_mask_cvtepi32_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi32_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtepi32_ps(__m256, __mmask8, __m256i);
extern __m256    __cdecl _mm256_maskz_cvtepi32_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtepi64_epi8(__mmask8, __m256i);
extern __m128d   __cdecl _mm_cvtepi64_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepi64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepi64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepi64_pd(__m256i);
extern __m256d   __cdecl _mm256_mask_cvtepi64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepi64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_cvtepi64_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepi64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepi64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_cvtepi64_ps(__m256i);
extern __m128    __cdecl _mm256_mask_cvtepi64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepi64_ps(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepi8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepi8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepi8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu16_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu16_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu16_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu32_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu32_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu32_epi64(__mmask8, __m128i);
extern __m128    __cdecl _mm_cvtepu32_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepu32_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepu32_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_cvtepu32_ps(__m256i);
extern __m256    __cdecl _mm256_mask_cvtepu32_ps(__m256, __mmask8, __m256i);
extern __m256    __cdecl _mm256_maskz_cvtepu32_ps(__mmask8, __m256i);
extern __m128d   __cdecl _mm_cvtepu32_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepu32_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepu32_pd(__m128i);
extern __m256d   __cdecl _mm256_mask_cvtepu32_pd(__m256d, __mmask8, __m128i);
extern __m256d   __cdecl _mm256_maskz_cvtepu32_pd(__mmask8, __m128i);
extern __m128d   __cdecl _mm_cvtepu64_pd(__m128i);
extern __m128d   __cdecl _mm_mask_cvtepu64_pd(__m128d, __mmask8, __m128i);
extern __m128d   __cdecl _mm_maskz_cvtepu64_pd(__mmask8, __m128i);
extern __m256d   __cdecl _mm256_cvtepu64_pd(__m256i);
extern __m256d   __cdecl _mm256_mask_cvtepu64_pd(__m256d, __mmask8, __m256i);
extern __m256d   __cdecl _mm256_maskz_cvtepu64_pd(__mmask8, __m256i);
extern __m128    __cdecl _mm_cvtepu64_ps(__m128i);
extern __m128    __cdecl _mm_mask_cvtepu64_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtepu64_ps(__mmask8, __m128i);
extern __m128    __cdecl _mm256_cvtepu64_ps(__m256i);
extern __m128    __cdecl _mm256_mask_cvtepu64_ps(__m128, __mmask8, __m256i);
extern __m128    __cdecl _mm256_maskz_cvtepu64_ps(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi16(__m256i, __mmask16, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi16(__mmask16, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi32(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtepu8_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_cvtepu8_epi64(__m256i, __mmask8, __m128i);
extern __m256i   __cdecl _mm256_maskz_cvtepu8_epi64(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epi64(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvtpd_epi64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epu32(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_cvtpd_epu32(__m256d);
extern __m128i   __cdecl _mm256_mask_cvtpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvtpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvtpd_epu64(__m128d);
extern __m128i   __cdecl _mm_mask_cvtpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvtpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvtpd_epu64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvtpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvtpd_epu64(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtpd_ps(__m128, __mmask8, __m128d);
extern __m128    __cdecl _mm_maskz_cvtpd_ps(__mmask8, __m128d);
extern __m128    __cdecl _mm256_mask_cvtpd_ps(__m128, __mmask8, __m256d);
extern __m128    __cdecl _mm256_maskz_cvtpd_ps(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_cvtph_ps(__m128, __mmask8, __m128i);
extern __m128    __cdecl _mm_maskz_cvtph_ps(__mmask8, __m128i);
extern __m256    __cdecl _mm256_mask_cvtph_ps(__m256, __mmask8, __m128i);
extern __m256    __cdecl _mm256_maskz_cvtph_ps(__mmask8, __m128i);
extern __m128i   __cdecl _mm_mask_cvtps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvtps_epi64(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epi64(__m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtps_epu32(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epu32(__m256);
extern __m256i   __cdecl _mm256_mask_cvtps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvtps_epu64(__m128);
extern __m128i   __cdecl _mm_mask_cvtps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvtps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvtps_epu64(__m128);
extern __m256i   __cdecl _mm256_mask_cvtps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvtps_epu64(__mmask8, __m128);
extern __m128d   __cdecl _mm_mask_cvtps_pd(__m128d, __mmask8, __m128);
extern __m128d   __cdecl _mm_maskz_cvtps_pd(__mmask8, __m128);
extern __m256d   __cdecl _mm256_mask_cvtps_pd(__m256d, __mmask8, __m128);
extern __m256d   __cdecl _mm256_maskz_cvtps_pd(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtsepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtsepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtsepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtsepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtsepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtsepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtsepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtsepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtsepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtsepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_cvttpd_epi32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epi32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epi32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epi64(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epi64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epi64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvttpd_epi64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epi64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epi64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epu32(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu32(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu32(__mmask8, __m128d);
extern __m128i   __cdecl _mm256_cvttpd_epu32(__m256d);
extern __m128i   __cdecl _mm256_mask_cvttpd_epu32(__m128i, __mmask8, __m256d);
extern __m128i   __cdecl _mm256_maskz_cvttpd_epu32(__mmask8, __m256d);
extern __m128i   __cdecl _mm_cvttpd_epu64(__m128d);
extern __m128i   __cdecl _mm_mask_cvttpd_epu64(__m128i, __mmask8, __m128d);
extern __m128i   __cdecl _mm_maskz_cvttpd_epu64(__mmask8, __m128d);
extern __m256i   __cdecl _mm256_cvttpd_epu64(__m256d);
extern __m256i   __cdecl _mm256_mask_cvttpd_epu64(__m256i, __mmask8, __m256d);
extern __m256i   __cdecl _mm256_maskz_cvttpd_epu64(__mmask8, __m256d);
extern __m128i   __cdecl _mm_mask_cvttps_epi32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvttps_epi64(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epi64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epi64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epi64(__m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epi64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epi64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvttps_epu32(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epu32(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu32(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epu32(__m256);
extern __m256i   __cdecl _mm256_mask_cvttps_epu32(__m256i, __mmask8, __m256);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu32(__mmask8, __m256);
extern __m128i   __cdecl _mm_cvttps_epu64(__m128);
extern __m128i   __cdecl _mm_mask_cvttps_epu64(__m128i, __mmask8, __m128);
extern __m128i   __cdecl _mm_maskz_cvttps_epu64(__mmask8, __m128);
extern __m256i   __cdecl _mm256_cvttps_epu64(__m128);
extern __m256i   __cdecl _mm256_mask_cvttps_epu64(__m256i, __mmask8, __m128);
extern __m256i   __cdecl _mm256_maskz_cvttps_epu64(__mmask8, __m128);
extern __m128i   __cdecl _mm_cvtusepi16_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi16_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi16_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi16_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi16_epi8(__m128i, __mmask16, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi16_epi8(__mmask16, __m256i);
extern void      __cdecl _mm_mask_cvtusepi16_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi16_storeu_epi8(void*, __mmask16, __m256i);
extern __m128i   __cdecl _mm_cvtusepi32_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi32_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi32_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi32_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi32_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi32_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi32_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi32_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi32_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi16(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi16(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi16(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi16(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi16(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi32(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi32(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi32(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_cvtusepi64_epi8(__m128i);
extern __m128i   __cdecl _mm_mask_cvtusepi64_epi8(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_cvtusepi64_epi8(__mmask8, __m128i);
extern __m128i   __cdecl _mm256_cvtusepi64_epi8(__m256i);
extern __m128i   __cdecl _mm256_mask_cvtusepi64_epi8(__m128i, __mmask8, __m256i);
extern __m128i   __cdecl _mm256_maskz_cvtusepi64_epi8(__mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi16(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_cvtusepi64_storeu_epi8(void*, __mmask8, __m256i);
extern __m128i   __cdecl _mm_dbsad_epu8(__m128i, __m128i, int);
extern __m128i   __cdecl _mm_mask_dbsad_epu8(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_dbsad_epu8(__mmask8, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_dbsad_epu8(__m256i, __m256i, int);
extern __m256i   __cdecl _mm256_mask_dbsad_epu8(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_dbsad_epu8(__mmask16, __m256i, __m256i, int);
extern __m128d   __cdecl _mm_mask_div_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_div_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_div_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_div_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_div_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_div_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_expand_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi8(__mmask32, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_expand_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_expand_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_expand_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_expand_epi64(__mmask8, __m256i);
extern __m128d   __cdecl _mm_mask_expand_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_expand_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_expand_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_expand_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_expand_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_expand_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_expand_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_expand_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_expandloadu_epi8(__m128i, __mmask16, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi8(__mmask16, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi8(__m256i, __mmask32, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi8(__mmask32, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi16(__m128i, __mmask8, const void*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi16(__mmask8, const void*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi16(__m256i, __mmask16, const void*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi16(__mmask16, const void*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_expandloadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_expandloadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_expandloadu_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_expandloadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_expandloadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_expandloadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_expandloadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_expandloadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_expandloadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_expandloadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_expandloadu_ps(__mmask8, void const*);
extern __m128    __cdecl _mm256_extractf32x4_ps(__m256, int);
extern __m128    __cdecl _mm256_mask_extractf32x4_ps(__m128, __mmask8, __m256, int);
extern __m128    __cdecl _mm256_maskz_extractf32x4_ps(__mmask8, __m256, int);
extern __m128d   __cdecl _mm256_extractf64x2_pd(__m256d, int);
extern __m128d   __cdecl _mm256_mask_extractf64x2_pd(__m128d, __mmask8, __m256d, int);
extern __m128d   __cdecl _mm256_maskz_extractf64x2_pd(__mmask8, __m256d, int);
extern __m128i   __cdecl _mm256_extracti32x4_epi32(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti32x4_epi32(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti32x4_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_extracti64x2_epi64(__m256i, int);
extern __m128i   __cdecl _mm256_mask_extracti64x2_epi64(__m128i, __mmask8, __m256i, int);
extern __m128i   __cdecl _mm256_maskz_extracti64x2_epi64(__mmask8, __m256i, int);
extern __m128d   __cdecl _mm_fixupimm_pd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_pd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_pd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m256d   __cdecl _mm256_fixupimm_pd(__m256d, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_mask_fixupimm_pd(__m256d, __mmask8, __m256d, __m256i, const int);
extern __m256d   __cdecl _mm256_maskz_fixupimm_pd(__mmask8, __m256d, __m256d, __m256i, const int);
extern __m128    __cdecl _mm_fixupimm_ps(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ps(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ps(__mmask8, __m128, __m128, __m128i, const int);
extern __m256    __cdecl _mm256_fixupimm_ps(__m256, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_mask_fixupimm_ps(__m256, __mmask8, __m256, __m256i, const int);
extern __m256    __cdecl _mm256_maskz_fixupimm_ps(__mmask8, __m256, __m256, __m256i, const int);
extern __m128d   __cdecl _mm_mask_fmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmaddsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmaddsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmaddsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmaddsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmaddsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmaddsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmaddsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmaddsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmaddsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmaddsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmaddsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmaddsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsub_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fmsubadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsubadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsubadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fmsubadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fmsubadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fmsubadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fmsubadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsubadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsubadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fmsubadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fmsubadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fmsubadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmadd_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmadd_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmadd_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmadd_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmadd_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmadd_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmadd_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmadd_ps(__mmask8, __m256, __m256, __m256);
extern __m128d   __cdecl _mm_mask_fnmsub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_pd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_pd(__mmask8, __m128d, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_fnmsub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_mask3_fnmsub_pd(__m256d, __m256d, __m256d, __mmask8);
extern __m256d   __cdecl _mm256_maskz_fnmsub_pd(__mmask8, __m256d, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_fnmsub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ps(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ps(__mmask8, __m128, __m128, __m128);
extern __m256    __cdecl _mm256_mask_fnmsub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_mask3_fnmsub_ps(__m256, __m256, __m256, __mmask8);
extern __m256    __cdecl _mm256_maskz_fnmsub_ps(__mmask8, __m256, __m256, __m256);
extern __mmask8  __cdecl _mm_fpclass_pd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_pd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm256_fpclass_pd_mask(__m256d, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_pd_mask(__mmask8, __m256d, int);
extern __mmask8  __cdecl _mm_fpclass_ps_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ps_mask(__mmask8, __m128, int);
extern __mmask8  __cdecl _mm256_fpclass_ps_mask(__m256, int);
extern __mmask8  __cdecl _mm256_mask_fpclass_ps_mask(__mmask8, __m256, int);
extern __m128d   __cdecl _mm_getexp_pd(__m128d);
extern __m128d   __cdecl _mm_mask_getexp_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_getexp_pd(__m256d);
extern __m256d   __cdecl _mm256_mask_getexp_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_getexp_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_getexp_ps(__m128);
extern __m128    __cdecl _mm_mask_getexp_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_getexp_ps(__m256);
extern __m256    __cdecl _mm256_mask_getexp_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_getexp_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_getmant_pd(__m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_pd(__m128d, __mmask8, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_pd(__mmask8, __m128d, int, int);
extern __m256d   __cdecl _mm256_getmant_pd(__m256d, int, int);
extern __m256d   __cdecl _mm256_mask_getmant_pd(__m256d, __mmask8, __m256d, int, int);
extern __m256d   __cdecl _mm256_maskz_getmant_pd(__mmask8, __m256d, int, int);
extern __m128    __cdecl _mm_getmant_ps(__m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ps(__m128, __mmask8, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ps(__mmask8, __m128, int, int);
extern __m256    __cdecl _mm256_getmant_ps(__m256, int, int);
extern __m256    __cdecl _mm256_mask_getmant_ps(__m256, __mmask8, __m256, int, int);
extern __m256    __cdecl _mm256_maskz_getmant_ps(__mmask8, __m256, int, int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi32(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i32gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i32gather_epi64(__m256i, __mmask8, __m128i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i32gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i32gather_pd(__m256d, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i32gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m256    __cdecl _mm256_mmask_i32gather_ps(__m256, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i32scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi32(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi32(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i32scatter_epi64(void*, __m128i, __m256i, const int);
extern void      __cdecl _mm256_mask_i32scatter_epi64(void*, __mmask8, __m128i, __m256i, const int);
extern void      __cdecl _mm_i32scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i32scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i32scatter_pd(void*, __m128i, __m256d, const int);
extern void      __cdecl _mm256_mask_i32scatter_pd(void*, __mmask8, __m128i, __m256d, const int);
extern void      __cdecl _mm_i32scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i32scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i32scatter_ps(void*, __m256i, __m256, const int);
extern void      __cdecl _mm256_mask_i32scatter_ps(void*, __mmask8, __m256i, __m256, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi32(__m128i, __mmask8, __m128i, void const*, const int);
extern __m128i   __cdecl _mm256_mmask_i64gather_epi32(__m128i, __mmask8, __m256i, void const*, const int);
extern __m128i   __cdecl _mm_mmask_i64gather_epi64(__m128i, __mmask8, __m128i, void const*, const int);
extern __m256i   __cdecl _mm256_mmask_i64gather_epi64(__m256i, __mmask8, __m256i, void const*, const int);
extern __m128d   __cdecl _mm_mmask_i64gather_pd(__m128d, __mmask8, __m128i, void const*, const int);
extern __m256d   __cdecl _mm256_mmask_i64gather_pd(__m256d, __mmask8, __m256i, void const*, const int);
extern __m128    __cdecl _mm_mmask_i64gather_ps(__m128, __mmask8, __m128i, void const*, const int);
extern __m128    __cdecl _mm256_mmask_i64gather_ps(__m128, __mmask8, __m256i, void const*, const int);
extern void      __cdecl _mm_i64scatter_epi32(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi32(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi32(void*, __m256i, __m128i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi32(void*, __mmask8, __m256i, __m128i, const int);
extern void      __cdecl _mm_i64scatter_epi64(void*, __m128i, __m128i, const int);
extern void      __cdecl _mm_mask_i64scatter_epi64(void*, __mmask8, __m128i, __m128i, const int);
extern void      __cdecl _mm256_i64scatter_epi64(void*, __m256i, __m256i, const int);
extern void      __cdecl _mm256_mask_i64scatter_epi64(void*, __mmask8, __m256i, __m256i, const int);
extern void      __cdecl _mm_i64scatter_pd(void*, __m128i, __m128d, const int);
extern void      __cdecl _mm_mask_i64scatter_pd(void*, __mmask8, __m128i, __m128d, const int);
extern void      __cdecl _mm256_i64scatter_pd(void*, __m256i, __m256d, const int);
extern void      __cdecl _mm256_mask_i64scatter_pd(void*, __mmask8, __m256i, __m256d, const int);
extern void      __cdecl _mm_i64scatter_ps(void*, __m128i, __m128, const int);
extern void      __cdecl _mm_mask_i64scatter_ps(void*, __mmask8, __m128i, __m128, const int);
extern void      __cdecl _mm256_i64scatter_ps(void*, __m256i, __m128, const int);
extern void      __cdecl _mm256_mask_i64scatter_ps(void*, __mmask8, __m256i, __m128, const int);
extern __m256    __cdecl _mm256_insertf32x4(__m256, __m128, int);
extern __m256    __cdecl _mm256_mask_insertf32x4(__m256, __mmask8, __m256, __m128, int);
extern __m256    __cdecl _mm256_maskz_insertf32x4(__mmask8, __m256, __m128, int);
extern __m256d   __cdecl _mm256_insertf64x2(__m256d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_insertf64x2(__m256d, __mmask8, __m256d, __m128d, int);
extern __m256d   __cdecl _mm256_maskz_insertf64x2(__mmask8, __m256d, __m128d, int);
extern __m256i   __cdecl _mm256_inserti32x4(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti32x4(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti32x4(__mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_inserti64x2(__m256i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_inserti64x2(__m256i, __mmask8, __m256i, __m128i, int);
extern __m256i   __cdecl _mm256_maskz_inserti64x2(__mmask8, __m256i, __m128i, int);
extern __m128i   __cdecl _mm_mask_load_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_mask_load_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_load_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_mask_load_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_load_epi64(__mmask8, void const*);
extern __m128d   __cdecl _mm_mask_load_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_load_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_load_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_load_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_load_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_load_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_load_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_load_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi16(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi16(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi16(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi16(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi16(__m256i, __mmask16, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi16(__mmask16, void const*);
extern __m128i   __cdecl _mm_loadu_epi32(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi32(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi32(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi32(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi32(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi32(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi64(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi64(__m128i, __mmask8, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi64(__mmask8, void const*);
extern __m256i   __cdecl _mm256_loadu_epi64(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi64(__m256i, __mmask8, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi64(__mmask8, void const*);
extern __m128i   __cdecl _mm_loadu_epi8(void const*);
extern __m128i   __cdecl _mm_mask_loadu_epi8(__m128i, __mmask16, void const*);
extern __m128i   __cdecl _mm_maskz_loadu_epi8(__mmask16, void const*);
extern __m256i   __cdecl _mm256_loadu_epi8(void const*);
extern __m256i   __cdecl _mm256_mask_loadu_epi8(__m256i, __mmask32, void const*);
extern __m256i   __cdecl _mm256_maskz_loadu_epi8(__mmask32, void const*);
extern __m128d   __cdecl _mm_mask_loadu_pd(__m128d, __mmask8, void const*);
extern __m128d   __cdecl _mm_maskz_loadu_pd(__mmask8, void const*);
extern __m256d   __cdecl _mm256_mask_loadu_pd(__m256d, __mmask8, void const*);
extern __m256d   __cdecl _mm256_maskz_loadu_pd(__mmask8, void const*);
extern __m128    __cdecl _mm_mask_loadu_ps(__m128, __mmask8, void const*);
extern __m128    __cdecl _mm_maskz_loadu_ps(__mmask8, void const*);
extern __m256    __cdecl _mm256_mask_loadu_ps(__m256, __mmask8, void const*);
extern __m256    __cdecl _mm256_maskz_loadu_ps(__mmask8, void const*);
extern __m128i   __cdecl _mm_lzcnt_epi32(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi32(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_lzcnt_epi64(__m128i);
extern __m128i   __cdecl _mm_mask_lzcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_lzcnt_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_lzcnt_epi64(__m256i);
extern __m256i   __cdecl _mm256_mask_lzcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_lzcnt_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_madd_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_madd_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_madd_epi16(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_madd_epi16(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_maddubs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_maddubs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_maddubs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_maddubs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_max_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_max_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_max_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_max_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_max_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_max_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_max_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_max_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_max_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_max_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_max_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_max_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_min_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_min_epu64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_min_epu64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_min_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_min_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_min_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_min_epu8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_min_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_min_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_min_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_min_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_min_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_min_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mov_epi16(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi16(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi16(__m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi16(__mmask16, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi32(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi32(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi32(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi32(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi64(__m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi64(__mmask8, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi64(__m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi64(__mmask8, __m256i);
extern __m128i   __cdecl _mm_mask_mov_epi8(__m128i, __mmask16, __m128i);
extern __m128i   __cdecl _mm_maskz_mov_epi8(__mmask16, __m128i);
extern __m256i   __cdecl _mm256_mask_mov_epi8(__m256i, __mmask32, __m256i);
extern __m256i   __cdecl _mm256_maskz_mov_epi8(__mmask32, __m256i);
extern __m128d   __cdecl _mm_mask_mov_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_mov_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_mov_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_mov_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_mov_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_mov_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_mov_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_mov_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_movedup_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_movedup_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_movedup_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_movedup_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_movehdup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_movehdup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_movehdup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_movehdup_ps(__mmask8, __m256);
extern __m128    __cdecl _mm_mask_moveldup_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_moveldup_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_moveldup_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_moveldup_ps(__mmask8, __m256);
extern __mmask8  __cdecl _mm_movepi16_mask(__m128i);
extern __mmask16 __cdecl _mm256_movepi16_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi32_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi32_mask(__m256i);
extern __mmask8  __cdecl _mm_movepi64_mask(__m128i);
extern __mmask8  __cdecl _mm256_movepi64_mask(__m256i);
extern __mmask16 __cdecl _mm_movepi8_mask(__m128i);
extern __mmask32 __cdecl _mm256_movepi8_mask(__m256i);
extern __m128i   __cdecl _mm_movm_epi16(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi16(__mmask16);
extern __m128i   __cdecl _mm_movm_epi32(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi32(__mmask8);
extern __m128i   __cdecl _mm_movm_epi64(__mmask8);
extern __m256i   __cdecl _mm256_movm_epi64(__mmask8);
extern __m128i   __cdecl _mm_movm_epi8(__mmask16);
extern __m256i   __cdecl _mm256_movm_epi8(__mmask32);
extern __m128i   __cdecl _mm_mask_mul_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mul_epu32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mul_epu32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mul_epu32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mul_epu32(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_mul_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_mul_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_mul_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_mul_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_mul_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_mul_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_mulhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhi_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhi_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhi_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhi_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mulhrs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mulhrs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mulhrs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mulhrs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_mullo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_mullo_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mullo_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_mullo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_mullo_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mullo_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_or_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_or_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_or_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_or_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_or_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_or_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_or_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_or_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_or_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_or_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_or_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_or_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_or_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_or_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_or_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_or_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_or_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_or_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_packs_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packs_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packs_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packs_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packs_epi32(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi16(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi16(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi16(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi16(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_packus_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_packus_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_packus_epi32(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_packus_epi32(__mmask16, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permute_pd(__m128d, __mmask8, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_permute_pd(__mmask8, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_permute_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permute_pd(__mmask8, __m256d, const int);
extern __m128    __cdecl _mm_mask_permute_ps(__m128, __mmask8, __m128, const int);
extern __m128    __cdecl _mm_maskz_permute_ps(__mmask8, __m128, const int);
extern __m256    __cdecl _mm256_mask_permute_ps(__m256, __mmask8, __m256, const int);
extern __m256    __cdecl _mm256_maskz_permute_ps(__mmask8, __m256, const int);
extern __m128d   __cdecl _mm_mask_permutevar_pd(__m128d, __mmask8, __m128d, __m128i);
extern __m128d   __cdecl _mm_maskz_permutevar_pd(__mmask8, __m128d, __m128i);
extern __m256d   __cdecl _mm256_mask_permutevar_pd(__m256d, __mmask8, __m256d, __m256i);
extern __m256d   __cdecl _mm256_maskz_permutevar_pd(__mmask8, __m256d, __m256i);
extern __m128    __cdecl _mm_mask_permutevar_ps(__m128, __mmask8, __m128, __m128i);
extern __m128    __cdecl _mm_maskz_permutevar_ps(__mmask8, __m128, __m128i);
extern __m256    __cdecl _mm256_mask_permutevar_ps(__m256, __mmask8, __m256, __m256i);
extern __m256    __cdecl _mm256_maskz_permutevar_ps(__mmask8, __m256, __m256i);
extern __m256i   __cdecl _mm256_mask_permutex_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_permutex_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_permutex_epi64(__m256i, const int);
extern __m256d   __cdecl _mm256_mask_permutex_pd(__m256d, __mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_permutex_pd(__mmask8, __m256d, const int);
extern __m256d   __cdecl _mm256_permutex_pd(__m256d, const int);
extern __m128i   __cdecl _mm_mask_permutex2var_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi16(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi16(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi16(__m256i, __m256i, __mmask16, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi16(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi32(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi32(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi32(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi32(__m256i, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_permutex2var_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_mask2_permutex2var_epi64(__m128i, __m128i, __mmask8, __m128i);
extern __m128i   __cdecl _mm_maskz_permutex2var_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutex2var_epi64(__m128i, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutex2var_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_mask2_permutex2var_epi64(__m256i, __m256i, __mmask8, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutex2var_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutex2var_epi64(__m256i, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_permutex2var_pd(__m128d, __mmask8, __m128i, __m128d);
extern __m128d   __cdecl _mm_mask2_permutex2var_pd(__m128d, __m128i, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_permutex2var_pd(__mmask8, __m128d, __m128i, __m128d);
extern __m128d   __cdecl _mm_permutex2var_pd(__m128d, __m128i, __m128d);
extern __m256d   __cdecl _mm256_mask_permutex2var_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_mask2_permutex2var_pd(__m256d, __m256i, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutex2var_pd(__mmask8, __m256d, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutex2var_pd(__m256d, __m256i, __m256d);
extern __m128    __cdecl _mm_mask_permutex2var_ps(__m128, __mmask8, __m128i, __m128);
extern __m128    __cdecl _mm_mask2_permutex2var_ps(__m128, __m128i, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_permutex2var_ps(__mmask8, __m128, __m128i, __m128);
extern __m128    __cdecl _mm_permutex2var_ps(__m128, __m128i, __m128);
extern __m256    __cdecl _mm256_mask_permutex2var_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_mask2_permutex2var_ps(__m256, __m256i, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_permutex2var_ps(__mmask8, __m256, __m256i, __m256);
extern __m256    __cdecl _mm256_permutex2var_ps(__m256, __m256i, __m256);
extern __m128i   __cdecl _mm_mask_permutexvar_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_permutexvar_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_permutexvar_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi16(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_permutexvar_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_permutexvar_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_permutexvar_epi64(__m256i, __m256i);
extern __m256d   __cdecl _mm256_mask_permutexvar_pd(__m256d, __mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_maskz_permutexvar_pd(__mmask8, __m256i, __m256d);
extern __m256d   __cdecl _mm256_permutexvar_pd(__m256i, __m256d);
extern __m256    __cdecl _mm256_mask_permutexvar_ps(__m256, __mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_maskz_permutexvar_ps(__mmask8, __m256i, __m256);
extern __m256    __cdecl _mm256_permutexvar_ps(__m256i, __m256);
extern __m128d   __cdecl _mm_mask_range_pd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_range_pd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_range_pd(__m128d, __m128d, int);
extern __m256d   __cdecl _mm256_mask_range_pd(__m256d, __mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_range_pd(__mmask8, __m256d, __m256d, int);
extern __m256d   __cdecl _mm256_range_pd(__m256d, __m256d, int);
extern __m128    __cdecl _mm_mask_range_ps(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_range_ps(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_range_ps(__m128, __m128, int);
extern __m256    __cdecl _mm256_mask_range_ps(__m256, __mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_maskz_range_ps(__mmask8, __m256, __m256, int);
extern __m256    __cdecl _mm256_range_ps(__m256, __m256, int);
extern __m128d   __cdecl _mm_mask_rcp14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_pd(__mmask8, __m128d);
extern __m128d   __cdecl _mm_rcp14_pd(__m128d);
extern __m256d   __cdecl _mm256_mask_rcp14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rcp14_pd(__mmask8, __m256d);
extern __m256d   __cdecl _mm256_rcp14_pd(__m256d);
extern __m128    __cdecl _mm_mask_rcp14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ps(__mmask8, __m128);
extern __m128    __cdecl _mm_rcp14_ps(__m128);
extern __m256    __cdecl _mm256_mask_rcp14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rcp14_ps(__mmask8, __m256);
extern __m256    __cdecl _mm256_rcp14_ps(__m256);
extern __m128d   __cdecl _mm_mask_reduce_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_reduce_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_reduce_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_reduce_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_reduce_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_reduce_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_reduce_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_reduce_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_reduce_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_reduce_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_reduce_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_reduce_ps(__m256, int);
extern __m128i   __cdecl _mm_mask_rol_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi32(__m128i, int);
extern __m256i   __cdecl _mm256_mask_rol_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rol_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_rol_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_rol_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_rol_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_rol_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_rol_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rolv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rolv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rolv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rolv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rolv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rolv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rolv_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ror_epi32(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi32(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi32(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi32(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi32(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi32(__m256i, const int);
extern __m128i   __cdecl _mm_mask_ror_epi64(__m128i, __mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_maskz_ror_epi64(__mmask8, __m128i, const int);
extern __m128i   __cdecl _mm_ror_epi64(__m128i, const int);
extern __m256i   __cdecl _mm256_mask_ror_epi64(__m256i, __mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_ror_epi64(__mmask8, __m256i, const int);
extern __m256i   __cdecl _mm256_ror_epi64(__m256i, const int);
extern __m128i   __cdecl _mm_mask_rorv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi32(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi32(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi32(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi32(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_rorv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_rorv_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_rorv_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_rorv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_rorv_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_rorv_epi64(__m256i, __m256i);
extern __m128d   __cdecl _mm_mask_roundscale_pd(__m128d, __mmask8, __m128d, int);
extern __m128d   __cdecl _mm_maskz_roundscale_pd(__mmask8, __m128d, int);
extern __m128d   __cdecl _mm_roundscale_pd(__m128d, int);
extern __m256d   __cdecl _mm256_mask_roundscale_pd(__m256d, __mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_maskz_roundscale_pd(__mmask8, __m256d, int);
extern __m256d   __cdecl _mm256_roundscale_pd(__m256d, int);
extern __m128    __cdecl _mm_mask_roundscale_ps(__m128, __mmask8, __m128, int);
extern __m128    __cdecl _mm_maskz_roundscale_ps(__mmask8, __m128, int);
extern __m128    __cdecl _mm_roundscale_ps(__m128, int);
extern __m256    __cdecl _mm256_mask_roundscale_ps(__m256, __mmask8, __m256, int);
extern __m256    __cdecl _mm256_maskz_roundscale_ps(__mmask8, __m256, int);
extern __m256    __cdecl _mm256_roundscale_ps(__m256, int);
extern __m128d   __cdecl _mm_mask_rsqrt14_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_rsqrt14_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_rsqrt14_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_rsqrt14_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_rsqrt14_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_rsqrt14_ps(__mmask8, __m256);
extern __m128d   __cdecl _mm_mask_scalef_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_pd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_pd(__m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_scalef_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_scalef_pd(__mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_scalef_pd(__m256d, __m256d);
extern __m128    __cdecl _mm_mask_scalef_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ps(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ps(__m128, __m128);
extern __m256    __cdecl _mm256_mask_scalef_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_scalef_ps(__mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_scalef_ps(__m256, __m256);
extern __m128i   __cdecl _mm_mask_set1_epi16(__m128i, __mmask8, short);
extern __m128i   __cdecl _mm_maskz_set1_epi16(__mmask8, short);
extern __m256i   __cdecl _mm256_mask_set1_epi16(__m256i, __mmask16, short);
extern __m256i   __cdecl _mm256_maskz_set1_epi16(__mmask16, short);
extern __m128i   __cdecl _mm_mask_set1_epi32(__m128i, __mmask8, int);
extern __m128i   __cdecl _mm_maskz_set1_epi32(__mmask8, int);
extern __m256i   __cdecl _mm256_mask_set1_epi32(__m256i, __mmask8, int);
extern __m256i   __cdecl _mm256_maskz_set1_epi32(__mmask8, int);
extern __m128i   __cdecl _mm_mask_set1_epi64(__m128i, __mmask8, __int64);
extern __m128i   __cdecl _mm_maskz_set1_epi64(__mmask8, __int64);
extern __m256i   __cdecl _mm256_mask_set1_epi64(__m256i, __mmask8, __int64);
extern __m256i   __cdecl _mm256_maskz_set1_epi64(__mmask8, __int64);
extern __m128i   __cdecl _mm_mask_set1_epi8(__m128i, __mmask16, char);
extern __m128i   __cdecl _mm_maskz_set1_epi8(__mmask16, char);
extern __m256i   __cdecl _mm256_mask_set1_epi8(__m256i, __mmask32, char);
extern __m256i   __cdecl _mm256_maskz_set1_epi8(__mmask32, char);
extern __m128i   __cdecl _mm_mask_shuffle_epi32(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shuffle_epi32(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shuffle_epi32(__m256i, __mmask8, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi32(__mmask8, __m256i, int);
extern __m128i   __cdecl _mm_mask_shuffle_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_shuffle_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_shuffle_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_shuffle_epi8(__mmask32, __m256i, __m256i);
extern __m256    __cdecl _mm256_mask_shuffle_f32x4(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_f32x4(__mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_shuffle_f32x4(__m256, __m256, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_f64x2(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_f64x2(__mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_shuffle_f64x2(__m256d, __m256d, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i32x4(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i32x4(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i32x4(__m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_mask_shuffle_i64x2(__m256i, __mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_maskz_shuffle_i64x2(__mmask8, __m256i, __m256i, const int);
extern __m256i   __cdecl _mm256_shuffle_i64x2(__m256i, __m256i, const int);
extern __m128d   __cdecl _mm_mask_shuffle_pd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_shuffle_pd(__mmask8, __m128d, __m128d, const int);
extern __m256d   __cdecl _mm256_mask_shuffle_pd(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d   __cdecl _mm256_maskz_shuffle_pd(__mmask8, __m256d, __m256d, const int);
extern __m128    __cdecl _mm_mask_shuffle_ps(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_shuffle_ps(__mmask8, __m128, __m128, const int);
extern __m256    __cdecl _mm256_mask_shuffle_ps(__m256, __mmask8, __m256, __m256, const int);
extern __m256    __cdecl _mm256_maskz_shuffle_ps(__mmask8, __m256, __m256, const int);
extern __m128i   __cdecl _mm_mask_shufflehi_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflehi_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflehi_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflehi_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_shufflelo_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_shufflelo_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_shufflelo_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_shufflelo_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_sll_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sll_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sll_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sll_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sll_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_slli_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_slli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_slli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_slli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_slli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_sllv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sllv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_sllv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sllv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sllv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sllv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sllv_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sqrt_pd(__m128d, __mmask8, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_pd(__mmask8, __m128d);
extern __m256d   __cdecl _mm256_mask_sqrt_pd(__m256d, __mmask8, __m256d);
extern __m256d   __cdecl _mm256_maskz_sqrt_pd(__mmask8, __m256d);
extern __m128    __cdecl _mm_mask_sqrt_ps(__m128, __mmask8, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ps(__mmask8, __m128);
extern __m256    __cdecl _mm256_mask_sqrt_ps(__m256, __mmask8, __m256);
extern __m256    __cdecl _mm256_maskz_sqrt_ps(__mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sra_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_sra_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sra_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_sra_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sra_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_sra_epi64(__mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_sra_epi64(__m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srai_epi16(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi16(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi16(__m256i, __mmask16, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi16(__mmask16, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srai_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srai_epi64(__mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_srai_epi64(__m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srai_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srai_epi64(__mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_srai_epi64(__m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srav_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srav_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srav_epi64(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srav_epi64(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srav_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srav_epi64(__mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srav_epi64(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srl_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi16(__m256i, __mmask16, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi16(__mmask16, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi32(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi32(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srl_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srl_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srl_epi64(__m256i, __mmask8, __m256i, __m128i);
extern __m256i   __cdecl _mm256_maskz_srl_epi64(__mmask8, __m256i, __m128i);
extern __m128i   __cdecl _mm_mask_srli_epi16(__m128i, __mmask8, __m128i, int);
extern __m128i   __cdecl _mm_maskz_srli_epi16(__mmask8, __m128i, int);
extern __m256i   __cdecl _mm256_mask_srli_epi16(__m256i, __mmask16, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_srli_epi16(__mmask16, __m256i, int);
extern __m128i   __cdecl _mm_mask_srli_epi32(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi32(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi32(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi32(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srli_epi64(__m128i, __mmask8, __m128i, unsigned int);
extern __m128i   __cdecl _mm_maskz_srli_epi64(__mmask8, __m128i, unsigned int);
extern __m256i   __cdecl _mm256_mask_srli_epi64(__m256i, __mmask8, __m256i, unsigned int);
extern __m256i   __cdecl _mm256_maskz_srli_epi64(__mmask8, __m256i, unsigned int);
extern __m128i   __cdecl _mm_mask_srlv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi16(__mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_srlv_epi16(__m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi16(__mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_srlv_epi16(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_srlv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_srlv_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_srlv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_srlv_epi64(__mmask8, __m256i, __m256i);
extern void      __cdecl _mm_mask_store_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_store_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_mask_store_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_store_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_store_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_store_ps(void*, __mmask8, __m256);
extern void      __cdecl _mm_storeu_epi16(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi16(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi16(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi16(void*, __mmask16, __m256i);
extern void      __cdecl _mm_storeu_epi32(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi32(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi32(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi32(void*, __mmask8, __m256i);
extern void      __cdecl _mm_storeu_epi64(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi64(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi64(void*, __mmask8, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi64(void*, __mmask8, __m256i);
extern void      __cdecl _mm_storeu_epi8(void*, __m128i);
extern void      __cdecl _mm256_storeu_epi8(void*, __m256i);
extern void      __cdecl _mm_mask_storeu_epi8(void*, __mmask16, __m128i);
extern void      __cdecl _mm256_mask_storeu_epi8(void*, __mmask32, __m256i);
extern void      __cdecl _mm_mask_storeu_pd(void*, __mmask8, __m128d);
extern void      __cdecl _mm256_mask_storeu_pd(void*, __mmask8, __m256d);
extern void      __cdecl _mm_mask_storeu_ps(void*, __mmask8, __m128);
extern void      __cdecl _mm256_mask_storeu_ps(void*, __mmask8, __m256);
extern __m128i   __cdecl _mm_mask_sub_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_sub_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_sub_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_sub_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_sub_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_sub_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_sub_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_sub_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_sub_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_sub_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_sub_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_subs_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epi8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_subs_epu8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_subs_epu8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_subs_epu8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_subs_epu8(__mmask32, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi32(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi32(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi32(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi32(__m256i, __m256i, __m256i, int);
extern __m128i   __cdecl _mm_mask_ternarylogic_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_maskz_ternarylogic_epi64(__mmask8, __m128i, __m128i, __m128i, int);
extern __m128i   __cdecl _mm_ternarylogic_epi64(__m128i, __m128i, __m128i, int);
extern __m256i   __cdecl _mm256_mask_ternarylogic_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_maskz_ternarylogic_epi64(__mmask8, __m256i, __m256i, __m256i, int);
extern __m256i   __cdecl _mm256_ternarylogic_epi64(__m256i, __m256i, __m256i, int);
extern __mmask8  __cdecl _mm_mask_test_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_test_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_test_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_test_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_test_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_test_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_test_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_test_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_test_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_test_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_test_epi8_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi16_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm256_mask_testn_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16 __cdecl _mm256_testn_epi16_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm_mask_testn_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_testn_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm256_mask_testn_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_testn_epi64_mask(__m256i, __m256i);
extern __mmask16 __cdecl _mm_mask_testn_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16 __cdecl _mm_testn_epi8_mask(__m128i, __m128i);
extern __mmask32 __cdecl _mm256_mask_testn_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32 __cdecl _mm256_testn_epi8_mask(__m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpackhi_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpackhi_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpackhi_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpackhi_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpackhi_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpackhi_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpackhi_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpackhi_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpackhi_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpackhi_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpackhi_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpackhi_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_mask_unpacklo_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi16(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi16(__mmask16, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi64(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_mask_unpacklo_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_unpacklo_epi8(__mmask16, __m128i, __m128i);
extern __m256i   __cdecl _mm256_mask_unpacklo_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_unpacklo_epi8(__mmask32, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_unpacklo_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_unpacklo_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_unpacklo_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_unpacklo_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_unpacklo_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_unpacklo_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_unpacklo_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_unpacklo_ps(__mmask8, __m256, __m256);
extern __m128i   __cdecl _mm_xor_epi32(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_xor_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi32(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_xor_epi32(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_xor_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi32(__mmask8, __m256i, __m256i);
extern __m128i   __cdecl _mm_xor_epi64(__m128i, __m128i);
extern __m128i   __cdecl _mm_mask_xor_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i   __cdecl _mm_maskz_xor_epi64(__mmask8, __m128i, __m128i);
extern __m256i   __cdecl _mm256_xor_epi64(__m256i, __m256i);
extern __m256i   __cdecl _mm256_mask_xor_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i   __cdecl _mm256_maskz_xor_epi64(__mmask8, __m256i, __m256i);
extern __m128d   __cdecl _mm_mask_xor_pd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_xor_pd(__mmask8, __m128d, __m128d);
extern __m256d   __cdecl _mm256_mask_xor_pd(__m256d, __mmask8, __m256d, __m256d);
extern __m256d   __cdecl _mm256_maskz_xor_pd(__mmask8, __m256d, __m256d);
extern __m128    __cdecl _mm_mask_xor_ps(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_xor_ps(__mmask8, __m128, __m128);
extern __m256    __cdecl _mm256_mask_xor_ps(__m256, __mmask8, __m256, __m256);
extern __m256    __cdecl _mm256_maskz_xor_ps(__mmask8, __m256, __m256);

extern __mmask16  __cdecl _mm_cmpeq_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpge_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpgt_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmple_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmplt_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpneq_epi8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpeq_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpge_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpgt_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmple_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmplt_epu8_mask(__m128i, __m128i);
extern __mmask16  __cdecl _mm_cmpneq_epu8_mask(__m128i, __m128i);

extern __mmask16  __cdecl _mm_mask_cmpeq_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpge_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpgt_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmple_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmplt_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpneq_epi8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpeq_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpge_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpgt_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmple_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmplt_epu8_mask(__mmask16, __m128i, __m128i);
extern __mmask16  __cdecl _mm_mask_cmpneq_epu8_mask(__mmask16, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu16_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu16_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu16_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu16_mask(__mmask8, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu32_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu32_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu32_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu32_mask(__mmask8, __m128i, __m128i);

extern __mmask8  __cdecl _mm_cmpeq_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epi64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpeq_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpge_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpgt_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmple_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmplt_epu64_mask(__m128i, __m128i);
extern __mmask8  __cdecl _mm_cmpneq_epu64_mask(__m128i, __m128i);

extern __mmask8  __cdecl _mm_mask_cmpeq_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epi64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpeq_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpge_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpgt_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmple_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmplt_epu64_mask(__mmask8, __m128i, __m128i);
extern __mmask8  __cdecl _mm_mask_cmpneq_epu64_mask(__mmask8, __m128i, __m128i);

extern __mmask32  __cdecl _mm256_cmpeq_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpge_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpgt_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmple_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmplt_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpneq_epi8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpeq_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpge_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpgt_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmple_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmplt_epu8_mask(__m256i, __m256i);
extern __mmask32  __cdecl _mm256_cmpneq_epu8_mask(__m256i, __m256i);

extern __mmask32  __cdecl _mm256_mask_cmpeq_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpge_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpgt_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmple_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmplt_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpneq_epi8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpeq_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpge_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpgt_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmple_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmplt_epu8_mask(__mmask32, __m256i, __m256i);
extern __mmask32  __cdecl _mm256_mask_cmpneq_epu8_mask(__mmask32, __m256i, __m256i);

extern __mmask16  __cdecl _mm256_cmpeq_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpge_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpgt_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmple_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmplt_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpneq_epi16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpeq_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpge_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpgt_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmple_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmplt_epu16_mask(__m256i, __m256i);
extern __mmask16  __cdecl _mm256_cmpneq_epu16_mask(__m256i, __m256i);

extern __mmask16  __cdecl _mm256_mask_cmpeq_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpge_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpgt_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmple_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmplt_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpneq_epi16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpeq_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpge_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpgt_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmple_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmplt_epu16_mask(__mmask16, __m256i, __m256i);
extern __mmask16  __cdecl _mm256_mask_cmpneq_epu16_mask(__mmask16, __m256i, __m256i);

extern __mmask8  __cdecl _mm256_cmpeq_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epi32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpeq_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epu32_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epu32_mask(__m256i, __m256i);

extern __mmask8  __cdecl _mm256_mask_cmpeq_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epi32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpeq_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epu32_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epu32_mask(__mmask8, __m256i, __m256i);

extern __mmask8  __cdecl _mm256_cmpeq_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epi64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpeq_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpge_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpgt_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmple_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmplt_epu64_mask(__m256i, __m256i);
extern __mmask8  __cdecl _mm256_cmpneq_epu64_mask(__m256i, __m256i);

extern __mmask8  __cdecl _mm256_mask_cmpeq_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epi64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpeq_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpge_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpgt_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmple_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmplt_epu64_mask(__mmask8, __m256i, __m256i);
extern __mmask8  __cdecl _mm256_mask_cmpneq_epu64_mask(__mmask8, __m256i, __m256i);


extern __m128d   __cdecl _mm_add_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_add_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_add_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_add_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_add_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_add_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_add_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_add_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_add_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_add_ss(__mmask8, __m128, __m128);
extern __mmask8  __cdecl _mm_cmp_round_sd_mask(__m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_sd_mask(__mmask8, __m128d, __m128d, const int, const int);
extern __mmask8  __cdecl _mm_cmp_round_ss_mask(__m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_mask_cmp_round_ss_mask(__mmask8, __m128, __m128, const int, const int);
extern __mmask8  __cdecl _mm_cmp_sd_mask(__m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_mask_cmp_sd_mask(__mmask8, __m128d, __m128d, const int);
extern __mmask8  __cdecl _mm_cmp_ss_mask(__m128, __m128, const int);
extern __mmask8  __cdecl _mm_mask_cmp_ss_mask(__mmask8, __m128, __m128, const int);
extern int       __cdecl _mm_comi_round_sd(__m128d, __m128d, const int, const int);
extern int       __cdecl _mm_comi_round_ss(__m128, __m128, const int, const int);
extern __m128    __cdecl _mm_cvt_roundi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvt_roundsd_si32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsd_ss(__m128, __m128d, int);
extern __m128    __cdecl _mm_mask_cvt_roundsd_ss(__m128, __mmask8, __m128, __m128d, int);
extern __m128    __cdecl _mm_maskz_cvt_roundsd_ss(__mmask8, __m128, __m128d, int);
extern unsigned int __cdecl _mm_cvt_roundsd_u32(__m128d, int);
extern __m128    __cdecl _mm_cvt_roundsi32_ss(__m128, int, int);
extern int       __cdecl _mm_cvt_roundss_i32(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundss_sd(__m128d, __m128, int);
extern __m128d   __cdecl _mm_mask_cvt_roundss_sd(__m128d, __mmask8, __m128d, __m128, int);
extern __m128d   __cdecl _mm_maskz_cvt_roundss_sd(__mmask8, __m128d, __m128, int);
extern int       __cdecl _mm_cvt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvt_roundss_u32(__m128, int);
extern __m128    __cdecl _mm_cvt_roundu32_ss(__m128, unsigned int, int);
extern __m128d   __cdecl _mm_cvti32_sd(__m128d, int);
extern __m128    __cdecl _mm_cvti32_ss(__m128, int);
extern int       __cdecl _mm_cvtsd_i32(__m128d);
extern __m128    __cdecl _mm_mask_cvtsd_ss(__m128, __mmask8, __m128, __m128d);
extern __m128    __cdecl _mm_maskz_cvtsd_ss(__mmask8, __m128, __m128d);
extern unsigned int __cdecl _mm_cvtsd_u32(__m128d);
extern int       __cdecl _mm_cvtss_i32(__m128);
extern __m128d   __cdecl _mm_mask_cvtss_sd(__m128d, __mmask8, __m128d, __m128);
extern __m128d   __cdecl _mm_maskz_cvtss_sd(__mmask8, __m128d, __m128);
extern unsigned int __cdecl _mm_cvtss_u32(__m128);
extern int       __cdecl _mm_cvtt_roundsd_i32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundsd_si32(__m128d, int);
extern unsigned int __cdecl _mm_cvtt_roundsd_u32(__m128d, int);
extern int       __cdecl _mm_cvtt_roundss_i32(__m128, int);
extern int       __cdecl _mm_cvtt_roundss_si32(__m128, int);
extern unsigned int __cdecl _mm_cvtt_roundss_u32(__m128, int);
extern int       __cdecl _mm_cvttsd_i32(__m128d);
extern unsigned int __cdecl _mm_cvttsd_u32(__m128d);
extern int       __cdecl _mm_cvttss_i32(__m128);
extern unsigned int __cdecl _mm_cvttss_u32(__m128);
extern __m128d   __cdecl _mm_cvtu32_sd(__m128d, unsigned int);
extern __m128    __cdecl _mm_cvtu32_ss(__m128, unsigned int);
extern __m128d   __cdecl _mm_div_round_sd(__m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_div_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_div_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128    __cdecl _mm_div_round_ss(__m128, __m128, int);
extern __m128    __cdecl _mm_mask_div_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_div_round_ss(__mmask8, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_div_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_div_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_div_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_div_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_fixupimm_round_sd(__m128d, __m128d, __m128i, const int, int);
extern __m128d   __cdecl _mm_mask_fixupimm_round_sd(__m128d, __mmask8, __m128d, __m128i, const int, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_round_sd(__mmask8, __m128d, __m128d, __m128i, const int, const int);
extern __m128    __cdecl _mm_fixupimm_round_ss(__m128, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_mask_fixupimm_round_ss(__m128, __mmask8, __m128, __m128i, const int, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_round_ss(__mmask8, __m128, __m128, __m128i, const int, const int);
extern __m128d   __cdecl _mm_fixupimm_sd(__m128d, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_mask_fixupimm_sd(__m128d, __mmask8, __m128d, __m128i, const int);
extern __m128d   __cdecl _mm_maskz_fixupimm_sd(__mmask8, __m128d, __m128d, __m128i, const int);
extern __m128    __cdecl _mm_fixupimm_ss(__m128, __m128, __m128i, const int);
extern __m128    __cdecl _mm_mask_fixupimm_ss(__m128, __mmask8, __m128, __m128i, const int);
extern __m128    __cdecl _mm_maskz_fixupimm_ss(__mmask8, __m128, __m128, __m128i, const int);
extern __m128d   __cdecl _mm_fmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fmsub_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmadd_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmadd_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmadd_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmadd_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmadd_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmadd_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmadd_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmadd_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmadd_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmadd_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmadd_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmadd_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmadd_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmadd_ss(__mmask8, __m128, __m128, __m128);
extern __m128d   __cdecl _mm_fnmsub_round_sd(__m128d, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask_fnmsub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mask3_fnmsub_round_sd(__m128d, __m128d, __m128d, __mmask8, int);
extern __m128d   __cdecl _mm_maskz_fnmsub_round_sd(__mmask8, __m128d, __m128d, __m128d, int);
extern __m128    __cdecl _mm_fnmsub_round_ss(__m128, __m128, __m128, int);
extern __m128    __cdecl _mm_mask_fnmsub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mask3_fnmsub_round_ss(__m128, __m128, __m128, __mmask8, int);
extern __m128    __cdecl _mm_maskz_fnmsub_round_ss(__mmask8, __m128, __m128, __m128, int);
extern __m128d   __cdecl _mm_mask_fnmsub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_mask3_fnmsub_sd(__m128d, __m128d, __m128d, __mmask8);
extern __m128d   __cdecl _mm_maskz_fnmsub_sd(__mmask8, __m128d, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_fnmsub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_mask3_fnmsub_ss(__m128, __m128, __m128, __mmask8);
extern __m128    __cdecl _mm_maskz_fnmsub_ss(__mmask8, __m128, __m128, __m128);
extern __mmask8  __cdecl _mm_fpclass_sd_mask(__m128d, int);
extern __mmask8  __cdecl _mm_mask_fpclass_sd_mask(__mmask8, __m128d, int);
extern __mmask8  __cdecl _mm_fpclass_ss_mask(__m128, int);
extern __mmask8  __cdecl _mm_mask_fpclass_ss_mask(__mmask8, __m128, int);
extern __m128d   __cdecl _mm_getexp_round_sd(__m128d, __m128d, const int);
extern __m128d   __cdecl _mm_mask_getexp_round_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_getexp_round_sd(__mmask8, __m128d, __m128d, const int);
extern __m128    __cdecl _mm_getexp_round_ss(__m128, __m128, const int);
extern __m128    __cdecl _mm_mask_getexp_round_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_getexp_round_ss(__mmask8, __m128, __m128, const int);
extern __m128d   __cdecl _mm_getexp_sd(__m128d, __m128d);
extern __m128d   __cdecl _mm_mask_getexp_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_getexp_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_getexp_ss(__m128, __m128);
extern __m128    __cdecl _mm_mask_getexp_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_getexp_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_getmant_round_sd(__m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_mask_getmant_round_sd(__m128d, __mmask8, __m128d, __m128d, int, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_round_sd(__mmask8, __m128d, __m128d, int, int, int);
extern __m128    __cdecl _mm_getmant_round_ss(__m128, __m128, int, int, int);
extern __m128    __cdecl _mm_mask_getmant_round_ss(__m128, __mmask8, __m128, __m128, int, int, int);
extern __m128    __cdecl _mm_maskz_getmant_round_ss(__mmask8, __m128, __m128, int, int, int);
extern __m128d   __cdecl _mm_getmant_sd(__m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_mask_getmant_sd(__m128d, __mmask8, __m128d, __m128d, int, int);
extern __m128d   __cdecl _mm_maskz_getmant_sd(__mmask8, __m128d, __m128d, int, int);
extern __m128    __cdecl _mm_getmant_ss(__m128, __m128, int, int);
extern __m128    __cdecl _mm_mask_getmant_ss(__m128, __mmask8, __m128, __m128, int, int);
extern __m128    __cdecl _mm_maskz_getmant_ss(__mmask8, __m128, __m128, int, int);
extern __m128d   __cdecl _mm_mask_load_sd(__m128d, __mmask8, const double*);
extern __m128d   __cdecl _mm_maskz_load_sd(__mmask8, const double*);
extern __m128    __cdecl _mm_mask_load_ss(__m128, __mmask8, const float*);
extern __m128    __cdecl _mm_maskz_load_ss(__mmask8, const float*);
extern __m128d   __cdecl _mm_mask_max_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_max_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_max_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_max_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_max_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_max_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_max_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_max_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_max_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_max_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_min_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_min_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_min_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_min_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_min_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_min_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_min_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_min_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_min_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_min_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_move_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_move_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_move_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_move_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_mask_mul_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_mul_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_mul_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_mul_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_mul_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_mul_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_mul_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_mul_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_mul_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_mul_ss(__mmask8, __m128, __m128);
extern __m128d   __cdecl _mm_range_sd(__m128d, __m128d, const int);
extern __m128d   __cdecl _mm_mask_range_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_range_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_range_round_sd(__m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_mask_range_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_range_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_range_ss(__m128, __m128, const int);
extern __m128    __cdecl _mm_mask_range_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_range_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_range_round_ss(__m128, __m128, const int, int);
extern __m128    __cdecl _mm_mask_range_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_range_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_rcp14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rcp28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rcp28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rcp28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rcp28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rcp28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rcp28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rcp28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rcp28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rcp28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rcp28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rcp28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rcp28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_reduce_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_maskz_reduce_round_sd(__mmask8, __m128d, __m128d, const int, int);
extern __m128d   __cdecl _mm_reduce_round_sd(__m128d, __m128d, const int, int);
extern __m128    __cdecl _mm_mask_reduce_round_ss(__m128, __mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_maskz_reduce_round_ss(__mmask8, __m128, __m128, const int, int);
extern __m128    __cdecl _mm_reduce_round_ss(__m128, __m128, const int, int);
extern __m128d   __cdecl _mm_mask_reduce_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_reduce_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_reduce_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_reduce_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_reduce_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_reduce_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_roundscale_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_round_sd(__mmask8, __m128d, __m128d, const int, const int);
extern __m128d   __cdecl _mm_roundscale_round_sd(__m128d, __m128d, const int, const int);
extern __m128    __cdecl _mm_mask_roundscale_round_ss(__m128, __mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_maskz_roundscale_round_ss(__mmask8, __m128, __m128, const int, const int);
extern __m128    __cdecl _mm_roundscale_round_ss(__m128, __m128, const int, const int);
extern __m128d   __cdecl _mm_mask_roundscale_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_maskz_roundscale_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d   __cdecl _mm_roundscale_sd(__m128d, __m128d, const int);
extern __m128    __cdecl _mm_mask_roundscale_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_maskz_roundscale_ss(__mmask8, __m128, __m128, const int);
extern __m128    __cdecl _mm_roundscale_ss(__m128, __m128, const int);
extern __m128d   __cdecl _mm_mask_rsqrt14_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt14_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt14_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt14_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt14_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt14_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_rsqrt28_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_rsqrt28_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_rsqrt28_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_rsqrt28_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_rsqrt28_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_rsqrt28_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_rsqrt28_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_rsqrt28_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_rsqrt28_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_rsqrt28_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_rsqrt28_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_rsqrt28_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_scalef_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_scalef_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_scalef_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_scalef_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_scalef_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_scalef_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_scalef_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_scalef_sd(__mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_scalef_sd(__m128d, __m128d);
extern __m128    __cdecl _mm_mask_scalef_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_scalef_ss(__mmask8, __m128, __m128);
extern __m128    __cdecl _mm_scalef_ss(__m128, __m128);
extern __m128d   __cdecl _mm_mask_sqrt_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sqrt_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sqrt_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sqrt_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sqrt_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sqrt_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sqrt_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sqrt_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sqrt_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sqrt_ss(__mmask8, __m128, __m128);
extern void      __cdecl _mm_mask_store_sd(double*, __mmask8, __m128d);
extern void      __cdecl _mm_mask_store_ss(float*, __mmask8, __m128);
extern __m128d   __cdecl _mm_mask_sub_round_sd(__m128d, __mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_maskz_sub_round_sd(__mmask8, __m128d, __m128d, int);
extern __m128d   __cdecl _mm_sub_round_sd(__m128d, __m128d, int);
extern __m128    __cdecl _mm_mask_sub_round_ss(__m128, __mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_maskz_sub_round_ss(__mmask8, __m128, __m128, int);
extern __m128    __cdecl _mm_sub_round_ss(__m128, __m128, int);
extern __m128d   __cdecl _mm_mask_sub_sd(__m128d, __mmask8, __m128d, __m128d);
extern __m128d   __cdecl _mm_maskz_sub_sd(__mmask8, __m128d, __m128d);
extern __m128    __cdecl _mm_mask_sub_ss(__m128, __mmask8, __m128, __m128);
extern __m128    __cdecl _mm_maskz_sub_ss(__mmask8, __m128, __m128);



extern unsigned __int64 __cdecl _mm_cvtsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvtss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvttsd_u64(__m128d);
extern unsigned __int64 __cdecl _mm_cvttss_u64(__m128);
extern unsigned __int64 __cdecl _mm_cvt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvt_roundss_u64(__m128, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundsd_u64(__m128d, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundss_u64(__m128, int);

extern __m128d   __cdecl _mm_cvti64_sd(__m128d, __int64);
extern __m128    __cdecl _mm_cvti64_ss(__m128, __int64);
extern __int64   __cdecl _mm_cvtsd_i64(__m128d);
extern __int64   __cdecl _mm_cvtss_i64(__m128);
extern __int64   __cdecl _mm_cvttsd_i64(__m128d);
extern __int64   __cdecl _mm_cvttss_i64(__m128);
extern __int64   __cdecl _mm_cvtt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundsd_si64(__m128d, int);
extern __int64   __cdecl _mm_cvtt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvtt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvtu64_sd(__m128d, unsigned __int64);
extern __m128    __cdecl _mm_cvtu64_ss(__m128, unsigned __int64);
extern __m128d   __cdecl _mm_cvt_roundi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundsd_i64(__m128d, int);
extern __int64   __cdecl _mm_cvt_roundsd_si64(__m128d, int);
extern __m128d   __cdecl _mm_cvt_roundsi64_sd(__m128d, __int64, int);
extern __m128    __cdecl _mm_cvt_roundsi64_ss(__m128, __int64, int);
extern __int64   __cdecl _mm_cvt_roundss_i64(__m128, int);
extern __int64   __cdecl _mm_cvt_roundss_si64(__m128, int);
extern __m128d   __cdecl _mm_cvt_roundu64_sd(__m128d, unsigned __int64, int);
extern __m128    __cdecl _mm_cvt_roundu64_ss(__m128, unsigned __int64, int);

#line 4360 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern __m512d   __cdecl _mm512_zextpd128_pd512(__m128d);
extern __m512d   __cdecl _mm512_zextpd256_pd512(__m256d);
extern __m512    __cdecl _mm512_zextps128_ps512(__m128);
extern __m512    __cdecl _mm512_zextps256_ps512(__m256);
extern __m512i   __cdecl _mm512_zextsi128_si512(__m128i);
extern __m512i   __cdecl _mm512_zextsi256_si512(__m256i);



























#line 4396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern __m128i __cdecl _mm_madd52hi_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52hi_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52hi_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52hi_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52hi_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52hi_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52hi_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52hi_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52hi_epu64(__mmask8, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_madd52lo_epu64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_madd52lo_epu64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_madd52lo_epu64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52lo_epu64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_madd52lo_epu64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_madd52lo_epu64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_madd52lo_epu64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_madd52lo_epu64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_madd52lo_epu64(__mmask8, __m512i, __m512i, __m512i);


extern __m128i __cdecl _mm_permutexvar_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_permutexvar_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_permutexvar_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_permutexvar_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutexvar_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_permutexvar_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutexvar_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutexvar_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_permutexvar_epi8(__mmask64, __m512i, __m512i);

extern __m128i __cdecl _mm_permutex2var_epi8(__m128i, __m128i , __m128i);
extern __m128i __cdecl _mm_mask_permutex2var_epi8(__m128i, __mmask16, __m128i , __m128i);
extern __m128i __cdecl _mm_mask2_permutex2var_epi8(__m128i, __m128i , __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_permutex2var_epi8(__mmask16, __m128i, __m128i , __m128i);
extern __m256i __cdecl _mm256_permutex2var_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_permutex2var_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask2_permutex2var_epi8(__m256i, __m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_permutex2var_epi8(__mmask32, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_permutex2var_epi8(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_permutex2var_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask2_permutex2var_epi8(__m512i, __m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_permutex2var_epi8(__mmask64, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_multishift_epi64_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_multishift_epi64_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_multishift_epi64_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_multishift_epi64_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_multishift_epi64_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_multishift_epi64_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_multishift_epi64_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_multishift_epi64_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_multishift_epi64_epi8(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_dpbusd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusd_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpbusds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpbusds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpbusds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbusds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpbusds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpbusds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpbusds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpbusds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpbusds_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpwssd_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssd_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssd_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssd_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssd_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssd_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssd_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssd_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssd_epi32(__mmask16, __m512i, __m512i, __m512i);

extern __m128i __cdecl _mm_dpwssds_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_dpwssds_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_dpwssds_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwssds_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_dpwssds_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_dpwssds_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_dpwssds_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_dpwssds_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_dpwssds_epi32(__mmask16, __m512i, __m512i, __m512i);


extern __m256i __cdecl _mm256_aesenc_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenc_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesenclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesenclast_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdec_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdec_epi128(__m512i, __m512i);
extern __m256i __cdecl _mm256_aesdeclast_epi128(__m256i, __m256i);
extern __m512i __cdecl _mm512_aesdeclast_epi128(__m512i, __m512i);


extern __m256i __cdecl _mm256_clmulepi64_epi128(__m256i, __m256i, const int);
extern __m512i __cdecl _mm512_clmulepi64_epi128(__m512i, __m512i, const int);


extern __m128i __cdecl _mm_popcnt_epi32(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi32(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi32(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi32(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi32(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi32(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi32(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi32(__m512i, __mmask16, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi32(__mmask16, __m512i);

extern __m128i __cdecl _mm_popcnt_epi64(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi64(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi64(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi64(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi64(__m256i, __mmask8, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi64(__mmask8, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi64(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi64(__m512i, __mmask8, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi64(__mmask8, __m512i);


extern __m128i __cdecl _mm_popcnt_epi8(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi8(__m128i, __mmask16, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi8(__mmask16, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi8(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi8(__m256i, __mmask32, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi8(__mmask32, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi8(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi8(__m512i, __mmask64, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi8(__mmask64, __m512i);

extern __m128i __cdecl _mm_popcnt_epi16(__m128i);
extern __m128i __cdecl _mm_mask_popcnt_epi16(__m128i, __mmask8, __m128i);
extern __m128i __cdecl _mm_maskz_popcnt_epi16(__mmask8, __m128i);
extern __m256i __cdecl _mm256_popcnt_epi16(__m256i);
extern __m256i __cdecl _mm256_mask_popcnt_epi16(__m256i, __mmask16, __m256i);
extern __m256i __cdecl _mm256_maskz_popcnt_epi16(__mmask16, __m256i);
extern __m512i __cdecl _mm512_popcnt_epi16(__m512i);
extern __m512i __cdecl _mm512_mask_popcnt_epi16(__m512i, __mmask32, __m512i);
extern __m512i __cdecl _mm512_maskz_popcnt_epi16(__mmask32, __m512i);

extern __mmask16 __cdecl _mm_bitshuffle_epi64_mask(__m128i, __m128i);
extern __mmask16 __cdecl _mm_mask_bitshuffle_epi64_mask(__mmask16, __m128i, __m128i);
extern __mmask32 __cdecl _mm256_bitshuffle_epi64_mask(__m256i, __m256i);
extern __mmask32 __cdecl _mm256_mask_bitshuffle_epi64_mask(__mmask32, __m256i, __m256i);
extern __mmask64 __cdecl _mm512_bitshuffle_epi64_mask(__m512i, __m512i);
extern __mmask64 __cdecl _mm512_mask_bitshuffle_epi64_mask(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_gf2p8affineinv_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affineinv_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affineinv_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affineinv_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affineinv_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affineinv_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affineinv_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affineinv_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affineinv_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8affine_epi64_epi8(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_gf2p8affine_epi64_epi8(__m128i, __mmask16, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_gf2p8affine_epi64_epi8(__mmask16, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_gf2p8affine_epi64_epi8(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_gf2p8affine_epi64_epi8(__m256i, __mmask32, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_gf2p8affine_epi64_epi8(__mmask32, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_gf2p8affine_epi64_epi8(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_gf2p8affine_epi64_epi8(__m512i, __mmask64, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_gf2p8affine_epi64_epi8(__mmask64, __m512i, __m512i, int);
extern __m128i __cdecl _mm_gf2p8mul_epi8(__m128i, __m128i);
extern __m128i __cdecl _mm_mask_gf2p8mul_epi8(__m128i, __mmask16, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_gf2p8mul_epi8(__mmask16, __m128i, __m128i);
extern __m256i __cdecl _mm256_gf2p8mul_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mask_gf2p8mul_epi8(__m256i, __mmask32, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_gf2p8mul_epi8(__mmask32, __m256i, __m256i);
extern __m512i __cdecl _mm512_gf2p8mul_epi8(__m512i, __m512i);
extern __m512i __cdecl _mm512_mask_gf2p8mul_epi8(__m512i, __mmask64, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_gf2p8mul_epi8(__mmask64, __m512i, __m512i);


extern __m128i __cdecl _mm_shldi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shldi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shldi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shldi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shldi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shldi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shldi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shldi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shldi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shldv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shldv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shldv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shldv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shldv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shldv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shldv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shldv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shldv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shldv_epi64(__mmask8, __m512i, __m512i, __m512i);


extern __m128i __cdecl _mm_shrdi_epi16(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi16(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi16(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi16(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi16(__m256i, __mmask16, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi16(__mmask16, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi16(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi16(__m512i, __mmask32, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi16(__mmask32, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi32(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi32(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi32(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi32(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi32(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi32(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi32(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi32(__m512i, __mmask16, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi32(__mmask16, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdi_epi64(__m128i, __m128i, int);
extern __m128i __cdecl _mm_mask_shrdi_epi64(__m128i, __mmask8, __m128i, __m128i, int);
extern __m128i __cdecl _mm_maskz_shrdi_epi64(__mmask8, __m128i, __m128i, int);
extern __m256i __cdecl _mm256_shrdi_epi64(__m256i, __m256i, int);
extern __m256i __cdecl _mm256_mask_shrdi_epi64(__m256i, __mmask8, __m256i, __m256i, int);
extern __m256i __cdecl _mm256_maskz_shrdi_epi64(__mmask8, __m256i, __m256i, int);
extern __m512i __cdecl _mm512_shrdi_epi64(__m512i, __m512i, int);
extern __m512i __cdecl _mm512_mask_shrdi_epi64(__m512i, __mmask8, __m512i, __m512i, int);
extern __m512i __cdecl _mm512_maskz_shrdi_epi64(__mmask8, __m512i, __m512i, int);
extern __m128i __cdecl _mm_shrdv_epi16(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi16(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi16(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi16(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi16(__m256i, __mmask16, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi16(__mmask16, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi16(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi16(__m512i, __mmask32, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi16(__mmask32, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi32(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi32(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi32(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi32(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi32(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi32(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi32(__m512i, __mmask16, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi32(__mmask16, __m512i, __m512i, __m512i);
extern __m128i __cdecl _mm_shrdv_epi64(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_mask_shrdv_epi64(__m128i, __mmask8, __m128i, __m128i);
extern __m128i __cdecl _mm_maskz_shrdv_epi64(__mmask8, __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_shrdv_epi64(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_mask_shrdv_epi64(__m256i, __mmask8, __m256i, __m256i);
extern __m256i __cdecl _mm256_maskz_shrdv_epi64(__mmask8, __m256i, __m256i, __m256i);
extern __m512i __cdecl _mm512_shrdv_epi64(__m512i, __m512i, __m512i);
extern __m512i __cdecl _mm512_mask_shrdv_epi64(__m512i, __mmask8, __m512i, __m512i);
extern __m512i __cdecl _mm512_maskz_shrdv_epi64(__mmask8, __m512i, __m512i, __m512i);






extern __m512i _mm512_div_epi8(__m512i, __m512i);
extern __m512i _mm512_div_epi16(__m512i, __m512i);
extern __m512i _mm512_div_epi32(__m512i, __m512i);
extern __m512i _mm512_div_epi64(__m512i, __m512i);
extern __m512i _mm512_div_epu8(__m512i, __m512i);
extern __m512i _mm512_div_epu16(__m512i, __m512i);
extern __m512i _mm512_div_epu32(__m512i, __m512i);
extern __m512i _mm512_div_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_div_epi32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_div_epu32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_rem_epi8(__m512i, __m512i);
extern __m512i _mm512_rem_epi16(__m512i, __m512i);
extern __m512i _mm512_rem_epi32(__m512i, __m512i);
extern __m512i _mm512_rem_epi64(__m512i, __m512i);
extern __m512i _mm512_rem_epu8(__m512i, __m512i);
extern __m512i _mm512_rem_epu16(__m512i, __m512i);
extern __m512i _mm512_rem_epu32(__m512i, __m512i);
extern __m512i _mm512_rem_epu64(__m512i, __m512i);
extern __m512i _mm512_mask_rem_epi32(__m512i , __mmask16, __m512i, __m512i);
extern __m512i _mm512_mask_rem_epu32(__m512i , __mmask16, __m512i, __m512i);


extern __m512  _mm512_sin_ps(__m512);
extern __m512  _mm512_mask_sin_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sin_pd(__m512d);
extern __m512d _mm512_mask_sin_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cos_ps(__m512);
extern __m512  _mm512_mask_cos_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cos_pd(__m512d);
extern __m512d _mm512_mask_cos_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_sincos_ps(__m512  * , __m512);
extern __m512  _mm512_mask_sincos_ps(__m512  * , __m512  , __m512  , __mmask16, __m512);
extern __m512d _mm512_sincos_pd(__m512d * , __m512d);
extern __m512d _mm512_mask_sincos_pd(__m512d * , __m512d , __m512d , __mmask8, __m512d);
extern __m512  _mm512_tan_ps(__m512);
extern __m512  _mm512_mask_tan_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tan_pd(__m512d);
extern __m512d _mm512_mask_tan_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_asin_ps(__m512);
extern __m512  _mm512_mask_asin_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_asin_pd(__m512d);
extern __m512d _mm512_mask_asin_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_acos_ps(__m512);
extern __m512  _mm512_mask_acos_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_acos_pd(__m512d);
extern __m512d _mm512_mask_acos_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atan_ps(__m512);
extern __m512  _mm512_mask_atan_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_atan_pd(__m512d);
extern __m512d _mm512_mask_atan_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atan2_ps(__m512, __m512);
extern __m512  _mm512_mask_atan2_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_atan2_pd(__m512d, __m512d);
extern __m512d _mm512_mask_atan2_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_sind_ps(__m512);
extern __m512  _mm512_mask_sind_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sind_pd(__m512d);
extern __m512d _mm512_mask_sind_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cosd_ps(__m512);
extern __m512  _mm512_mask_cosd_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cosd_pd(__m512d);
extern __m512d _mm512_mask_cosd_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_tand_ps(__m512);
extern __m512  _mm512_mask_tand_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tand_pd(__m512d);
extern __m512d _mm512_mask_tand_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_sinh_ps(__m512);
extern __m512  _mm512_mask_sinh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_sinh_pd(__m512d);
extern __m512d _mm512_mask_sinh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cosh_ps(__m512);
extern __m512  _mm512_mask_cosh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cosh_pd(__m512d);
extern __m512d _mm512_mask_cosh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_tanh_ps(__m512);
extern __m512  _mm512_mask_tanh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_tanh_pd(__m512d);
extern __m512d _mm512_mask_tanh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_asinh_ps(__m512);
extern __m512  _mm512_mask_asinh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_asinh_pd(__m512d);
extern __m512d _mm512_mask_asinh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_acosh_ps(__m512);
extern __m512  _mm512_mask_acosh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_acosh_pd(__m512d);
extern __m512d _mm512_mask_acosh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_atanh_ps(__m512);
extern __m512  _mm512_mask_atanh_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_atanh_pd(__m512d);
extern __m512d _mm512_mask_atanh_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log_ps(__m512);
extern __m512  _mm512_mask_log_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log_pd(__m512d);
extern __m512d _mm512_mask_log_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log1p_ps(__m512);
extern __m512  _mm512_mask_log1p_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log1p_pd(__m512d);
extern __m512d _mm512_mask_log1p_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log10_ps(__m512);
extern __m512  _mm512_mask_log10_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log10_pd(__m512d);
extern __m512d _mm512_mask_log10_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_log2_ps(__m512);
extern __m512  _mm512_mask_log2_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_log2_pd(__m512d);
extern __m512d _mm512_mask_log2_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_logb_ps(__m512);
extern __m512  _mm512_mask_logb_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_logb_pd(__m512d);
extern __m512d _mm512_mask_logb_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp_ps(__m512);
extern __m512  _mm512_mask_exp_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp_pd(__m512d);
extern __m512d _mm512_mask_exp_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp10_ps(__m512);
extern __m512  _mm512_mask_exp10_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp10_pd(__m512d);
extern __m512d _mm512_mask_exp10_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_exp2_ps(__m512);
extern __m512  _mm512_mask_exp2_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_exp2_pd(__m512d);
extern __m512d _mm512_mask_exp2_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_expm1_ps(__m512);
extern __m512  _mm512_mask_expm1_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_expm1_pd(__m512d);
extern __m512d _mm512_mask_expm1_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_pow_ps(__m512, __m512);
extern __m512  _mm512_mask_pow_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_pow_pd(__m512d, __m512d);
extern __m512d _mm512_mask_pow_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_trunc_ps(__m512);
extern __m512  _mm512_mask_trunc_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_trunc_pd(__m512d);
extern __m512d _mm512_mask_trunc_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_floor_ps(__m512);
extern __m512  _mm512_mask_floor_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_floor_pd(__m512d);
extern __m512d _mm512_mask_floor_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_ceil_ps(__m512);
extern __m512  _mm512_mask_ceil_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_ceil_pd(__m512d);
extern __m512d _mm512_mask_ceil_pd(__m512d , __mmask8, __m512d);
extern __m512 _mm512_svml_round_ps(__m512);
extern __m512 _mm512_mask_svml_round_ps(__m512 , __mmask16, __m512);
extern __m512d _mm512_svml_round_pd(__m512d);
extern __m512d _mm512_mask_svml_round_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_fmod_ps(__m512, __m512);
extern __m512  _mm512_mask_fmod_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_fmod_pd(__m512d, __m512d);
extern __m512d _mm512_mask_fmod_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_rint_ps(__m512);
extern __m512  _mm512_mask_rint_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_rint_pd(__m512d);
extern __m512d _mm512_mask_rint_pd(__m512d , __mmask8, __m512d);






extern __m512  _mm512_invsqrt_ps(__m512);
extern __m512  _mm512_mask_invsqrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_invsqrt_pd(__m512d);
extern __m512d _mm512_mask_invsqrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cbrt_ps(__m512);
extern __m512  _mm512_mask_cbrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cbrt_pd(__m512d);
extern __m512d _mm512_mask_cbrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_invcbrt_ps(__m512);
extern __m512  _mm512_mask_invcbrt_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_invcbrt_pd(__m512d);
extern __m512d _mm512_mask_invcbrt_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_hypot_ps(__m512, __m512);
extern __m512  _mm512_mask_hypot_ps(__m512  , __mmask16, __m512, __m512);
extern __m512d _mm512_hypot_pd(__m512d, __m512d);
extern __m512d _mm512_mask_hypot_pd(__m512d , __mmask8, __m512d, __m512d);
extern __m512  _mm512_cdfnorm_ps(__m512);
extern __m512  _mm512_mask_cdfnorm_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cdfnorm_pd(__m512d);
extern __m512d _mm512_mask_cdfnorm_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_cdfnorminv_ps(__m512);
extern __m512  _mm512_mask_cdfnorminv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_cdfnorminv_pd(__m512d);
extern __m512d _mm512_mask_cdfnorminv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erf_ps(__m512);
extern __m512  _mm512_mask_erf_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erf_pd(__m512d);
extern __m512d _mm512_mask_erf_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfc_ps(__m512);
extern __m512  _mm512_mask_erfc_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfc_pd(__m512d);
extern __m512d _mm512_mask_erfc_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfcinv_ps(__m512);
extern __m512  _mm512_mask_erfcinv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfcinv_pd(__m512d);
extern __m512d _mm512_mask_erfcinv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_erfinv_ps(__m512);
extern __m512  _mm512_mask_erfinv_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_erfinv_pd(__m512d);
extern __m512d _mm512_mask_erfinv_pd(__m512d , __mmask8, __m512d);
extern __m512  _mm512_nearbyint_ps(__m512);
extern __m512  _mm512_mask_nearbyint_ps(__m512  , __mmask16, __m512);
extern __m512d _mm512_nearbyint_pd(__m512d);
extern __m512d _mm512_mask_nearbyint_pd(__m512d , __mmask8, __m512d);


typedef __m128i __m128bh;
typedef __m256i __m256bh;
typedef __m512i __m512bh;
typedef unsigned short __bfloat16;

extern __m128bh _mm_cvtneps_pbh(__m128);
extern __m128bh _mm_mask_cvtneps_pbh(__m128bh, __mmask8, __m128);
extern __m128bh _mm_maskz_cvtneps_pbh(__mmask8, __m128);
extern __m128bh _mm_cvtne2ps_pbh(__m128, __m128);
extern __m128bh _mm_mask_cvtne2ps_pbh(__m128bh, __mmask8, __m128, __m128);
extern __m128bh _mm_maskz_cvtne2ps_pbh(__mmask8, __m128, __m128);
extern __m128   _mm_dpbf16_ps(__m128, __m128bh, __m128bh);
extern __m128   _mm_mask_dpbf16_ps(__m128, __mmask8, __m128bh, __m128bh);
extern __m128   _mm_maskz_dpbf16_ps(__mmask8, __m128, __m128bh, __m128bh);
extern __m128bh _mm256_cvtneps_pbh(__m256);
extern __m128bh _mm256_mask_cvtneps_pbh(__m128bh, __mmask8, __m256);
extern __m128bh _mm256_maskz_cvtneps_pbh(__mmask8, __m256);
extern __m256bh _mm256_cvtne2ps_pbh(__m256, __m256);
extern __m256bh _mm256_mask_cvtne2ps_pbh(__m256bh, __mmask16, __m256, __m256);
extern __m256bh _mm256_maskz_cvtne2ps_pbh(__mmask16, __m256, __m256);
extern __m256   _mm256_dpbf16_ps(__m256, __m256bh, __m256bh);
extern __m256   _mm256_mask_dpbf16_ps(__m256, __mmask8, __m256bh, __m256bh);
extern __m256   _mm256_maskz_dpbf16_ps(__mmask8, __m256, __m256bh, __m256bh);
extern __m256bh _mm512_cvtneps_pbh(__m512);
extern __m256bh _mm512_mask_cvtneps_pbh(__m256bh, __mmask16, __m512);
extern __m256bh _mm512_maskz_cvtneps_pbh(__mmask16, __m512);
extern __m512bh _mm512_cvtne2ps_pbh(__m512, __m512);
extern __m512bh _mm512_mask_cvtne2ps_pbh(__m512bh, __mmask32, __m512, __m512);
extern __m512bh _mm512_maskz_cvtne2ps_pbh(__mmask32, __m512, __m512);
extern __m512   _mm512_dpbf16_ps(__m512, __m512bh, __m512bh);
extern __m512   _mm512_mask_dpbf16_ps(__m512, __mmask16, __m512bh, __m512bh);
extern __m512   _mm512_maskz_dpbf16_ps(__mmask16, __m512, __m512bh, __m512bh);
extern __bfloat16 _mm_cvtness_sbh(float);
extern float      _mm_cvtsbh_ss(__bfloat16);
extern __m128     _mm_cvtpbh_ps(__m128bh);
extern __m128     _mm_mask_cvtpbh_ps(__m128, __mmask8, __m128bh);
extern __m128     _mm_maskz_cvtpbh_ps(__mmask8, __m128bh);
extern __m256     _mm256_cvtpbh_ps(__m128bh);
extern __m256     _mm256_mask_cvtpbh_ps(__m256, __mmask8, __m128bh);
extern __m256     _mm256_maskz_cvtpbh_ps(__mmask8, __m128bh);
extern __m512     _mm512_cvtpbh_ps(__m256bh);
extern __m512     _mm512_mask_cvtpbh_ps(__m512, __mmask16, __m256bh);
extern __m512     _mm512_maskz_cvtpbh_ps(__mmask16, __m256bh);




















extern __mmask8  __cdecl _kadd_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kadd_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kadd_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kadd_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kand_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kand_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kand_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kand_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kandn_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kandn_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kandn_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kandn_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _knot_mask8(__mmask8);
extern __mmask16 __cdecl _knot_mask16(__mmask16);
extern __mmask32 __cdecl _knot_mask32(__mmask32);
extern __mmask64 __cdecl _knot_mask64(__mmask64);
extern __mmask8  __cdecl _kor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kxnor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kxnor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kxnor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kxnor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kxor_mask8(__mmask8, __mmask8);
extern __mmask16 __cdecl _kxor_mask16(__mmask16, __mmask16);
extern __mmask32 __cdecl _kxor_mask32(__mmask32, __mmask32);
extern __mmask64 __cdecl _kxor_mask64(__mmask64, __mmask64);
extern __mmask8  __cdecl _kshiftli_mask8(__mmask8, unsigned int);
extern __mmask16 __cdecl _kshiftli_mask16(__mmask16, unsigned int);
extern __mmask32 __cdecl _kshiftli_mask32(__mmask32, unsigned int);
extern __mmask64 __cdecl _kshiftli_mask64(__mmask64, unsigned int);
extern __mmask8  __cdecl _kshiftri_mask8(__mmask8, unsigned int);
extern __mmask16 __cdecl _kshiftri_mask16(__mmask16, unsigned int);
extern __mmask32 __cdecl _kshiftri_mask32(__mmask32, unsigned int);
extern __mmask64 __cdecl _kshiftri_mask64(__mmask64, unsigned int);
extern __mmask8  __cdecl _load_mask8(__mmask8 *);
extern __mmask16 __cdecl _load_mask16(__mmask16 *);
extern __mmask32 __cdecl _load_mask32(__mmask32 *);
extern __mmask64 __cdecl _load_mask64(__mmask64 *);
extern void      __cdecl _store_mask8(__mmask8 *, __mmask8);
extern void      __cdecl _store_mask16(__mmask16 *, __mmask16);
extern void      __cdecl _store_mask32(__mmask32 *, __mmask32);
extern void      __cdecl _store_mask64(__mmask64 *, __mmask64);
extern unsigned int     __cdecl _cvtmask8_u32(__mmask8);
extern unsigned int     __cdecl _cvtmask16_u32(__mmask16);
extern unsigned int     __cdecl _cvtmask32_u32(__mmask32);
extern unsigned __int64 __cdecl _cvtmask64_u64(__mmask64);
extern __mmask8         __cdecl _cvtu32_mask8(unsigned int);
extern __mmask16        __cdecl _cvtu32_mask16(unsigned int);
extern __mmask32        __cdecl _cvtu32_mask32(unsigned int);
extern __mmask64        __cdecl _cvtu64_mask64(unsigned __int64);
extern __mmask16        __cdecl _mm512_kmov(__mmask16);
extern unsigned char __cdecl _kortest_mask8_u8(__mmask8, __mmask8, unsigned char *);
extern unsigned char __cdecl _kortest_mask16_u8(__mmask16, __mmask16, unsigned char *);
extern unsigned char __cdecl _kortest_mask32_u8(__mmask32, __mmask32, unsigned char *);
extern unsigned char __cdecl _kortest_mask64_u8(__mmask64, __mmask64, unsigned char *);
extern unsigned char __cdecl _ktest_mask8_u8(__mmask8, __mmask8, unsigned char *);
extern unsigned char __cdecl _ktest_mask16_u8(__mmask16, __mmask16, unsigned char *);
extern unsigned char __cdecl _ktest_mask32_u8(__mmask32, __mmask32, unsigned char *);
extern unsigned char __cdecl _ktest_mask64_u8(__mmask64, __mmask64, unsigned char *);





































extern __m512  __cdecl _mm512_mask_exp2a23_round_ps(__m512, __mmask16, __m512, int);
extern __m512  __cdecl _mm512_maskz_exp2a23_round_ps(__mmask16, __m512, int);
extern __m512d __cdecl _mm512_mask_exp2a23_round_pd(__m512d, __mmask8, __m512d, int);
extern __m512d __cdecl _mm512_maskz_exp2a23_round_pd(__mmask8, __m512d, int);


















extern __m512  __cdecl _mm512_mask_rcp28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rcp28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rcp28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rcp28_round_pd(__mmask8, __m512d, const int);


















extern __m512  __cdecl _mm512_mask_rsqrt28_round_ps(__m512, __mmask16, __m512, const int);
extern __m512  __cdecl _mm512_maskz_rsqrt28_round_ps(__mmask16, __m512, const int);
extern __m512d __cdecl _mm512_mask_rsqrt28_round_pd(__m512d, __mmask8, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_rsqrt28_round_pd(__mmask8, __m512d, const int);


















extern void __cdecl _mm512_prefetch_i32gather_pd(__m256i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32gather_ps(__m512i index, void const* mv, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_pd(void* base_addr, __m256i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i32scatter_ps(void* mv, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_pd(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64gather_ps(__m512i vindex, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_pd(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_prefetch_i64scatter_ps(void* base_addr, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_pd(__m256i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32gather_ps(__m512i vindex, __mmask16 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_pd(void* base_addr, __mmask8 mask, __m256i vinde, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i32scatter_ps(void* mv, __mmask16 k, __m512i index, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_pd(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64gather_ps(__m512i vindex, __mmask8 mask, void const* base_addr, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_pd(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);
extern void __cdecl _mm512_mask_prefetch_i64scatter_ps(void* base_addr, __mmask8 mask, __m512i vindex, int scale, const int hint);


extern void __cdecl _mm_2intersect_epi32(__m128i, __m128i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm256_2intersect_epi32(__m256i, __m256i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm512_2intersect_epi32(__m512i, __m512i, __mmask16 *, __mmask16 *);
extern void __cdecl _mm_2intersect_epi64(__m128i, __m128i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm256_2intersect_epi64(__m256i, __m256i, __mmask8 *, __mmask8 *);
extern void __cdecl _mm512_2intersect_epi64(__m512i, __m512i, __mmask8 *, __mmask8 *);




typedef int __tile;

extern void __cdecl _tile_loadconfig(const void *);
extern void __cdecl _tile_storeconfig(void *);
extern void __cdecl _tile_release(void);

extern void __cdecl _tile_loadd(__tile dst, const void *base, int stride);
extern void __cdecl _tile_loaddrs(__tile dst, const void *base, int stride);
extern void __cdecl _tile_loaddrst1(__tile dst, const void *base, int stride);
extern void __cdecl _tile_stream_loadd(__tile dst, const void *base, int stride);
extern void __cdecl _tile_stored(__tile src, void *base, int stride);
extern void __cdecl _tile_zero(__tile dst);

extern void __cdecl _tile_dpbf16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpfp16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbssd(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbsud(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbusd(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbuud(__tile dst, __tile src1, __tile src2);


extern void __cdecl _tile_cmmimfp16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_cmmrlfp16ps(__tile dst, __tile src1, __tile src2);


extern void __cdecl _tile_dpbf8ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dpbhf8ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dphbf8ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_dphf8ps(__tile dst, __tile src1, __tile src2);


extern void __cdecl _tile_mmultf32ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_tmmultf32ps(__tile dst, __tile src1, __tile src2);


extern void __cdecl _tile_2rpntlvwz0(__tile dst, const void *base, int stride);
extern void __cdecl _tile_2rpntlvwz0t1(__tile dst, const void *base, int stride);
extern void __cdecl _tile_2rpntlvwz1(__tile dst, const void *base, int stride);
extern void __cdecl _tile_2rpntlvwz1t1(__tile dst, const void *base, int stride);
extern void __cdecl _tile_transposed(__tile dst, __tile src1);


extern void __cdecl _tile_2rpntlvwz0rs(__tile dst, const void *base, int stride);
extern void __cdecl _tile_2rpntlvwz0rst1(__tile dst, const void *base, int stride);
extern void __cdecl _tile_2rpntlvwz1rs(__tile dst, const void *base, int stride);
extern void __cdecl _tile_2rpntlvwz1rst1(__tile dst, const void *base, int stride);


extern void __cdecl _tile_conjtcmmimfp16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_conjtfp16(__tile dst, __tile src1);
extern void __cdecl _tile_tcmmimfp16ps(__tile dst, __tile src1, __tile src2);
extern void __cdecl _tile_tcmmrlfp16ps(__tile dst, __tile src1, __tile src2);


extern void __cdecl _tile_tdpbf16ps(__tile dst, __tile src1, __tile src2);


extern void __cdecl _tile_tdpfp16ps(__tile dst, __tile src1, __tile src2);

#line 5223 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


typedef __m128i __m128h;
typedef __m256i __m256h;
typedef __m512i __m512h;




extern __m512   __cdecl _tile_cvtrowd2ps(__tile dst, unsigned int a);
extern __m512   __cdecl _tile_cvtrowd2psi(__tile dst, const unsigned int);
extern __m512bh __cdecl _tile_cvtrowps2bf16h(__tile dst, unsigned int a);
extern __m512bh __cdecl _tile_cvtrowps2bf16hi(__tile dst, const unsigned int);
extern __m512bh __cdecl _tile_cvtrowps2bf16l(__tile dst, unsigned int a);
extern __m512bh __cdecl _tile_cvtrowps2bf16li(__tile dst, const unsigned int);
extern __m512h  __cdecl _tile_cvtrowps2phh(__tile dst, unsigned int a);
extern __m512h  __cdecl _tile_cvtrowps2phhi(__tile dst, const unsigned int);
extern __m512h  __cdecl _tile_cvtrowps2phl(__tile dst, unsigned int a);
extern __m512h  __cdecl _tile_cvtrowps2phli(__tile dst, const unsigned int);
extern __m512   __cdecl _tile_movrow(__tile dst, unsigned int a);
extern __m512   __cdecl _tile_movrowi(__tile dst, const unsigned int);

#line 5246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern __m128h __cdecl _mm_add_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_add_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_add_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_add_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_add_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_add_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_add_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_add_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_add_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_add_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_add_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_add_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_add_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_add_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_add_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_add_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_add_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_add_round_sh(__mmask8, __m128h, __m128h, int);







extern __mmask8 __cdecl _mm_cmp_ph_mask(__m128h, __m128h, const int);
extern __mmask8 __cdecl _mm_mask_cmp_ph_mask(__mmask8, __m128h, __m128h, const int);
extern __mmask16 __cdecl _mm256_cmp_ph_mask(__m256h, __m256h, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_ph_mask(__mmask16, __m256h, __m256h, const int);
extern __mmask32 __cdecl _mm512_cmp_ph_mask(__m512h, __m512h, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_ph_mask(__mmask32, __m512h, __m512h, const int);
extern __mmask32 __cdecl _mm512_cmp_round_ph_mask(__m512h, __m512h, const int, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_round_ph_mask(__mmask32, __m512h, __m512h, const int, const int);


extern __mmask8 __cdecl _mm_cmp_sh_mask(__m128h, __m128h, const int);
extern __mmask8 __cdecl _mm_mask_cmp_sh_mask(__mmask8, __m128h, __m128h, const int);
extern __mmask8 __cdecl _mm_cmp_round_sh_mask(__m128h, __m128h, const int, const int);
extern __mmask8 __cdecl _mm_mask_cmp_round_sh_mask(__mmask8, __m128h, __m128h, const int, const int);


extern int __cdecl _mm_comi_sh(__m128h, __m128h, const int);
extern int __cdecl _mm_comi_round_sh(__m128h, __m128h, const int, const int);


extern __m128h __cdecl _mm_cvtepi32_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepi32_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepi32_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepi32_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepi32_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepi32_ph(__mmask8, __m256i);
extern __m256h __cdecl _mm512_cvtepi32_ph (__m512i);
extern __m256h __cdecl _mm512_mask_cvtepi32_ph (__m256h, __mmask16, __m512i);
extern __m256h __cdecl _mm512_maskz_cvtepi32_ph (__mmask16, __m512i);
extern __m256h __cdecl _mm512_cvt_roundepi32_ph(__m512i, int);
extern __m256h __cdecl _mm512_mask_cvt_roundepi32_ph(__m256h, __mmask16, __m512i, int);
extern __m256h __cdecl _mm512_maskz_cvt_roundepi32_ph(__mmask16, __m512i, int);


extern __m128h __cdecl _mm_cvtpd_ph(__m128d);
extern __m128h __cdecl _mm_mask_cvtpd_ph(__m128h, __mmask8, __m128d);
extern __m128h __cdecl _mm_maskz_cvtpd_ph(__mmask8, __m128d);
extern __m128h __cdecl _mm256_cvtpd_ph(__m256d);
extern __m128h __cdecl _mm256_mask_cvtpd_ph(__m128h, __mmask8, __m256d);
extern __m128h __cdecl _mm256_maskz_cvtpd_ph(__mmask8, __m256d);
extern __m128h __cdecl _mm512_cvtpd_ph (__m512d);
extern __m128h __cdecl _mm512_mask_cvtpd_ph (__m128h, __mmask8, __m512d);
extern __m128h __cdecl _mm512_maskz_cvtpd_ph (__mmask8, __m512d);
extern __m128h __cdecl _mm512_cvt_roundpd_ph(__m512d, int);
extern __m128h __cdecl _mm512_mask_cvt_roundpd_ph(__m128h, __mmask8, __m512d, int);
extern __m128h __cdecl _mm512_maskz_cvt_roundpd_ph(__mmask8, __m512d, int);


extern __m128i __cdecl _mm_cvtph_epi32(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epi32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epi32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epi32(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epi32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epi32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epi32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvtph_epi32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvtph_epi32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvt_roundph_epi32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi32(__mmask16, __m256h, int);


extern __m128d __cdecl _mm_cvtph_pd(__m128h);
extern __m128d __cdecl _mm_mask_cvtph_pd(__m128d, __mmask8, __m128h);
extern __m128d __cdecl _mm_maskz_cvtph_pd(__mmask8, __m128h);
extern __m256d __cdecl _mm256_cvtph_pd(__m128h);
extern __m256d __cdecl _mm256_mask_cvtph_pd(__m256d, __mmask8, __m128h);
extern __m256d __cdecl _mm256_maskz_cvtph_pd(__mmask8, __m128h);
extern __m512d __cdecl _mm512_cvtph_pd (__m128h);
extern __m512d __cdecl _mm512_mask_cvtph_pd (__m512d, __mmask8, __m128h);
extern __m512d __cdecl _mm512_maskz_cvtph_pd (__mmask8, __m128h);
extern __m512d __cdecl _mm512_cvt_roundph_pd(__m128h, int);
extern __m512d __cdecl _mm512_mask_cvt_roundph_pd(__m512d, __mmask8, __m128h, int);
extern __m512d __cdecl _mm512_maskz_cvt_roundph_pd(__mmask8, __m128h, int);


extern __m128 __cdecl _mm_cvtxph_ps(__m128h);
extern __m128 __cdecl _mm_mask_cvtxph_ps(__m128, __mmask8, __m128h);
extern __m128 __cdecl _mm_maskz_cvtxph_ps(__mmask8, __m128h);
extern __m256 __cdecl _mm256_cvtxph_ps(__m128h);
extern __m256 __cdecl _mm256_mask_cvtxph_ps(__m256, __mmask8, __m128h);
extern __m256 __cdecl _mm256_maskz_cvtxph_ps(__mmask8, __m128h);
extern __m512 __cdecl _mm512_cvtxph_ps(__m256h);
extern __m512 __cdecl _mm512_mask_cvtxph_ps(__m512, __mmask16, __m256h);
extern __m512 __cdecl _mm512_maskz_cvtxph_ps(__mmask16, __m256h);
extern __m512 __cdecl _mm512_cvtx_roundph_ps(__m256h, int);
extern __m512 __cdecl _mm512_mask_cvtx_roundph_ps(__m512, __mmask16, __m256h, int);
extern __m512 __cdecl _mm512_maskz_cvtx_roundph_ps(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvtph_epi64(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epi64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epi64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epi64(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epi64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epi64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epi64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvtph_epi64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvtph_epi64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvt_roundph_epi64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvtph_epu32(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epu32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epu32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epu32(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epu32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epu32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epu32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvtph_epu32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvtph_epu32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvt_roundph_epu32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu32(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvtph_epu64(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epu64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epu64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epu64(__m128h);
extern __m256i __cdecl _mm256_mask_cvtph_epu64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvtph_epu64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtph_epu64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvtph_epu64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvtph_epu64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvt_roundph_epu64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvtph_epu16(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epu16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epu16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epu16(__m256h);
extern __m256i __cdecl _mm256_mask_cvtph_epu16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvtph_epu16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtph_epu16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvtph_epu16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvtph_epu16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvt_roundph_epu16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epu16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epu16(__mmask32, __m512h, int);


extern __m128i __cdecl _mm_cvtph_epi16(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_epi16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_epi16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvtph_epi16(__m256h);
extern __m256i __cdecl _mm256_mask_cvtph_epi16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvtph_epi16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtph_epi16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvtph_epi16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvtph_epi16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvt_roundph_epi16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvt_roundph_epi16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvt_roundph_epi16(__mmask32, __m512h, int);


extern __m128h __cdecl _mm_cvtxps_ph(__m128);
extern __m128h __cdecl _mm_mask_cvtxps_ph(__m128h, __mmask8, __m128);
extern __m128h __cdecl _mm_maskz_cvtxps_ph(__mmask8, __m128);
extern __m128h __cdecl _mm256_cvtxps_ph(__m256);
extern __m128h __cdecl _mm256_mask_cvtxps_ph(__m128h, __mmask8, __m256);
extern __m128h __cdecl _mm256_maskz_cvtxps_ph(__mmask8, __m256);
extern __m256h __cdecl _mm512_cvtxps_ph(__m512);
extern __m256h __cdecl _mm512_mask_cvtxps_ph(__m256h, __mmask16, __m512);
extern __m256h __cdecl _mm512_maskz_cvtxps_ph(__mmask16, __m512);
extern __m256h __cdecl _mm512_cvtx_roundps_ph(__m512, int);
extern __m256h __cdecl _mm512_mask_cvtx_roundps_ph(__m256h, __mmask16, __m512, int);
extern __m256h __cdecl _mm512_maskz_cvtx_roundps_ph(__mmask16, __m512, int);


extern __m128h __cdecl _mm_cvtepi64_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepi64_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepi64_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepi64_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepi64_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepi64_ph(__mmask8, __m256i);
extern __m128h __cdecl _mm512_cvtepi64_ph (__m512i);
extern __m128h __cdecl _mm512_mask_cvtepi64_ph (__m128h, __mmask8, __m512i);
extern __m128h __cdecl _mm512_maskz_cvtepi64_ph (__mmask8, __m512i);
extern __m128h __cdecl _mm512_cvt_roundepi64_ph(__m512i, int);
extern __m128h __cdecl _mm512_mask_cvt_roundepi64_ph(__m128h, __mmask8, __m512i, int);
extern __m128h __cdecl _mm512_maskz_cvt_roundepi64_ph(__mmask8, __m512i, int);


extern __m128h __cdecl _mm_cvtsd_sh(__m128h, __m128d);
extern __m128h __cdecl _mm_mask_cvtsd_sh(__m128h, __mmask8, __m128h, __m128d);
extern __m128h __cdecl _mm_maskz_cvtsd_sh(__mmask8, __m128h, __m128d);
extern __m128h __cdecl _mm_cvt_roundsd_sh(__m128h, __m128d, const int);
extern __m128h __cdecl _mm_mask_cvt_roundsd_sh(__m128h, __mmask8, __m128h, __m128d, const int);
extern __m128h __cdecl _mm_maskz_cvt_roundsd_sh(__mmask8, __m128h, __m128d, const int);


extern __m128d __cdecl _mm_cvtsh_sd(__m128d, __m128h);
extern __m128d __cdecl _mm_mask_cvtsh_sd(__m128d, __mmask8, __m128d, __m128h);
extern __m128d __cdecl _mm_maskz_cvtsh_sd(__mmask8, __m128d, __m128h);
extern __m128d __cdecl _mm_cvt_roundsh_sd(__m128d, __m128h, const int);
extern __m128d __cdecl _mm_mask_cvt_roundsh_sd(__m128d, __mmask8, __m128d, __m128h, const int);
extern __m128d __cdecl _mm_maskz_cvt_roundsh_sd(__mmask8, __m128d, __m128h, const int);


extern int __cdecl _mm_cvtsh_i32(__m128h);
extern __int64 __cdecl _mm_cvtsh_i64(__m128h);
extern int __cdecl _mm_cvt_roundsh_i32(__m128h, int);
extern __int64 __cdecl _mm_cvt_roundsh_i64(__m128h, int);


extern __m128 __cdecl _mm_cvtsh_ss(__m128, __m128h);
extern __m128 __cdecl _mm_mask_cvtsh_ss(__m128, __mmask8, __m128, __m128h);
extern __m128 __cdecl _mm_maskz_cvtsh_ss(__mmask8, __m128, __m128h);
extern __m128 __cdecl _mm_cvt_roundsh_ss(__m128, __m128h, const int);
extern __m128 __cdecl _mm_mask_cvt_roundsh_ss(__m128, __mmask8, __m128, __m128h, const int);
extern __m128 __cdecl _mm_maskz_cvt_roundsh_ss(__mmask8, __m128, __m128h, const int);


extern unsigned int __cdecl _mm_cvtsh_u32(__m128h);
extern unsigned __int64 __cdecl _mm_cvtsh_u64(__m128h);
extern unsigned int __cdecl _mm_cvt_roundsh_u32(__m128h, int);
extern unsigned __int64 __cdecl _mm_cvt_roundsh_u64(__m128h, int);


extern __m128h __cdecl _mm_cvti32_sh(__m128h, int);
extern __m128h __cdecl _mm_cvti64_sh(__m128h, __int64);
extern __m128h __cdecl _mm_cvt_roundi32_sh(__m128h, int, int);
extern __m128h __cdecl _mm_cvt_roundi64_sh(__m128h, __int64, int);


extern __m128h __cdecl _mm_cvtss_sh(__m128h, __m128);
extern __m128h __cdecl _mm_mask_cvtss_sh(__m128h, __mmask8, __m128h, __m128);
extern __m128h __cdecl _mm_maskz_cvtss_sh(__mmask8, __m128h, __m128);
extern __m128h __cdecl _mm_cvt_roundss_sh(__m128h, __m128, const int);
extern __m128h __cdecl _mm_mask_cvt_roundss_sh(__m128h, __mmask8, __m128h, __m128, const int);
extern __m128h __cdecl _mm_maskz_cvt_roundss_sh(__mmask8, __m128h, __m128, const int);


extern __m128i __cdecl _mm_cvttph_epi32(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epi32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epi32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epi32(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epi32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epi32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epi32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvttph_epi32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvttph_epi32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtt_roundph_epi32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi32(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvttph_epi64(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epi64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epi64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epi64(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epi64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epi64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epi64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvttph_epi64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvttph_epi64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtt_roundph_epi64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvttph_epu32(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epu32(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epu32(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epu32(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epu32(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epu32(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epu32 (__m256h);
extern __m512i __cdecl _mm512_mask_cvttph_epu32 (__m512i, __mmask16, __m256h);
extern __m512i __cdecl _mm512_maskz_cvttph_epu32 (__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvtt_roundph_epu32(__m256h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu32(__m512i, __mmask16, __m256h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu32(__mmask16, __m256h, int);


extern __m128i __cdecl _mm_cvttph_epu64(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epu64(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epu64(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epu64(__m128h);
extern __m256i __cdecl _mm256_mask_cvttph_epu64(__m256i, __mmask8, __m128h);
extern __m256i __cdecl _mm256_maskz_cvttph_epu64(__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvttph_epu64 (__m128h);
extern __m512i __cdecl _mm512_mask_cvttph_epu64 (__m512i, __mmask8, __m128h);
extern __m512i __cdecl _mm512_maskz_cvttph_epu64 (__mmask8, __m128h);
extern __m512i __cdecl _mm512_cvtt_roundph_epu64(__m128h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu64(__m512i, __mmask8, __m128h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu64(__mmask8, __m128h, int);


extern __m128i __cdecl _mm_cvttph_epu16(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epu16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epu16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epu16(__m256h);
extern __m256i __cdecl _mm256_mask_cvttph_epu16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvttph_epu16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvttph_epu16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvttph_epu16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvttph_epu16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvtt_roundph_epu16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epu16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epu16(__mmask32, __m512h, int);


extern __m128i __cdecl _mm_cvttph_epi16(__m128h);
extern __m128i __cdecl _mm_mask_cvttph_epi16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvttph_epi16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_cvttph_epi16(__m256h);
extern __m256i __cdecl _mm256_mask_cvttph_epi16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_cvttph_epi16(__mmask16, __m256h);
extern __m512i __cdecl _mm512_cvttph_epi16 (__m512h);
extern __m512i __cdecl _mm512_mask_cvttph_epi16 (__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_cvttph_epi16 (__mmask32, __m512h);
extern __m512i __cdecl _mm512_cvtt_roundph_epi16(__m512h, int);
extern __m512i __cdecl _mm512_mask_cvtt_roundph_epi16(__m512i, __mmask32, __m512h, int);
extern __m512i __cdecl _mm512_maskz_cvtt_roundph_epi16(__mmask32, __m512h, int);


extern int __cdecl _mm_cvttsh_i32(__m128h);
extern __int64 __cdecl _mm_cvttsh_i64(__m128h);
extern int __cdecl _mm_cvtt_roundsh_i32(__m128h, int);
extern __int64 __cdecl _mm_cvtt_roundsh_i64(__m128h, int);


extern unsigned int __cdecl _mm_cvttsh_u32(__m128h);
extern unsigned __int64 __cdecl _mm_cvttsh_u64(__m128h);
extern unsigned int __cdecl _mm_cvtt_roundsh_u32(__m128h, int);
extern unsigned __int64 __cdecl _mm_cvtt_roundsh_u64(__m128h, int);


extern __m128h __cdecl _mm_cvtepu32_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepu32_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepu32_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepu32_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepu32_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepu32_ph(__mmask8, __m256i);
extern __m256h __cdecl _mm512_cvtepu32_ph (__m512i);
extern __m256h __cdecl _mm512_mask_cvtepu32_ph (__m256h, __mmask16, __m512i);
extern __m256h __cdecl _mm512_maskz_cvtepu32_ph (__mmask16, __m512i);
extern __m256h __cdecl _mm512_cvt_roundepu32_ph(__m512i, int);
extern __m256h __cdecl _mm512_mask_cvt_roundepu32_ph(__m256h, __mmask16, __m512i, int);
extern __m256h __cdecl _mm512_maskz_cvt_roundepu32_ph(__mmask16, __m512i, int);


extern __m128h __cdecl _mm_cvtepu64_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepu64_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepu64_ph(__mmask8, __m128i);
extern __m128h __cdecl _mm256_cvtepu64_ph(__m256i);
extern __m128h __cdecl _mm256_mask_cvtepu64_ph(__m128h, __mmask8, __m256i);
extern __m128h __cdecl _mm256_maskz_cvtepu64_ph(__mmask8, __m256i);
extern __m128h __cdecl _mm512_cvtepu64_ph (__m512i);
extern __m128h __cdecl _mm512_mask_cvtepu64_ph (__m128h, __mmask8, __m512i);
extern __m128h __cdecl _mm512_maskz_cvtepu64_ph (__mmask8, __m512i);
extern __m128h __cdecl _mm512_cvt_roundepu64_ph(__m512i, int);
extern __m128h __cdecl _mm512_mask_cvt_roundepu64_ph(__m128h, __mmask8, __m512i, int);
extern __m128h __cdecl _mm512_maskz_cvt_roundepu64_ph(__mmask8, __m512i, int);


extern __m128h __cdecl _mm_cvtu32_sh(__m128h, unsigned int);
extern __m128h __cdecl _mm_cvtu64_sh(__m128h, unsigned __int64);
extern __m128h __cdecl _mm_cvt_roundu32_sh(__m128h, unsigned int, int);
extern __m128h __cdecl _mm_cvt_roundu64_sh(__m128h, unsigned __int64, int);


extern __m128h __cdecl _mm_cvtepu16_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepu16_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepu16_ph(__mmask8, __m128i);
extern __m256h __cdecl _mm256_cvtepu16_ph(__m256i);
extern __m256h __cdecl _mm256_mask_cvtepu16_ph(__m256h, __mmask16, __m256i);
extern __m256h __cdecl _mm256_maskz_cvtepu16_ph(__mmask16, __m256i);
extern __m512h __cdecl _mm512_cvtepu16_ph (__m512i);
extern __m512h __cdecl _mm512_mask_cvtepu16_ph (__m512h, __mmask32, __m512i);
extern __m512h __cdecl _mm512_maskz_cvtepu16_ph (__mmask32, __m512i);
extern __m512h __cdecl _mm512_cvt_roundepu16_ph(__m512i, int);
extern __m512h __cdecl _mm512_mask_cvt_roundepu16_ph(__m512h, __mmask32, __m512i, int);
extern __m512h __cdecl _mm512_maskz_cvt_roundepu16_ph(__mmask32, __m512i, int);


extern __m128h __cdecl _mm_cvtepi16_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvtepi16_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvtepi16_ph(__mmask8, __m128i);
extern __m256h __cdecl _mm256_cvtepi16_ph(__m256i);
extern __m256h __cdecl _mm256_mask_cvtepi16_ph(__m256h, __mmask16, __m256i);
extern __m256h __cdecl _mm256_maskz_cvtepi16_ph(__mmask16, __m256i);
extern __m512h __cdecl _mm512_cvtepi16_ph (__m512i);
extern __m512h __cdecl _mm512_mask_cvtepi16_ph (__m512h, __mmask32, __m512i);
extern __m512h __cdecl _mm512_maskz_cvtepi16_ph (__mmask32, __m512i);
extern __m512h __cdecl _mm512_cvt_roundepi16_ph(__m512i, int);
extern __m512h __cdecl _mm512_mask_cvt_roundepi16_ph(__m512h, __mmask32, __m512i, int);
extern __m512h __cdecl _mm512_maskz_cvt_roundepi16_ph(__mmask32, __m512i, int);


extern __m128h __cdecl _mm_div_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_div_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_div_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_div_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_div_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_div_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_div_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_div_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_div_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_div_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_div_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_div_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_div_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_div_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_div_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_div_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_div_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_div_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_fmaddsub_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmaddsub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmaddsub_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmaddsub_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmaddsub_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmaddsub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmaddsub_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmaddsub_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmaddsub_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmaddsub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmaddsub_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmaddsub_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmaddsub_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmaddsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmaddsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmaddsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fmsubadd_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmsubadd_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmsubadd_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmsubadd_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmsubadd_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmsubadd_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmsubadd_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmsubadd_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmsubadd_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmsubadd_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmsubadd_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmsubadd_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmsubadd_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmsubadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmsubadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmsubadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __mmask8 __cdecl _mm_fpclass_ph_mask(__m128h, int);
extern __mmask8 __cdecl _mm_mask_fpclass_ph_mask(__mmask8, __m128h, int);
extern __mmask16 __cdecl _mm256_fpclass_ph_mask(__m256h, int);
extern __mmask16 __cdecl _mm256_mask_fpclass_ph_mask(__mmask16, __m256h, int);
extern __mmask32 __cdecl _mm512_fpclass_ph_mask(__m512h, int);
extern __mmask32 __cdecl _mm512_mask_fpclass_ph_mask(__mmask32, __m512h, int);


extern __mmask8 __cdecl _mm_fpclass_sh_mask(__m128h, int);
extern __mmask8 __cdecl _mm_mask_fpclass_sh_mask(__mmask8, __m128h, int);


extern __m128h __cdecl _mm_fmadd_pch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_pch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_pch(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmadd_pch(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmadd_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmadd_pch(__m256h, __m256h, __m256h, __mmask8);
extern __m256h __cdecl _mm256_maskz_fmadd_pch(__mmask8, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmadd_pch(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmadd_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmadd_pch(__m512h, __m512h, __m512h, __mmask16);
extern __m512h __cdecl _mm512_maskz_fmadd_pch(__mmask16, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmadd_round_pch(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmadd_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmadd_round_pch(__m512h, __m512h, __m512h, __mmask16, const int);
extern __m512h __cdecl _mm512_maskz_fmadd_round_pch(__mmask16, __m512h, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fcmadd_pch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmadd_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fcmadd_pch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fcmadd_pch(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fcmadd_pch(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fcmadd_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fcmadd_pch(__m256h, __m256h, __m256h, __mmask8);
extern __m256h __cdecl _mm256_maskz_fcmadd_pch(__mmask8, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fcmadd_pch(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fcmadd_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fcmadd_pch(__m512h, __m512h, __m512h, __mmask16);
extern __m512h __cdecl _mm512_maskz_fcmadd_pch(__mmask16, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fcmadd_round_pch(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fcmadd_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fcmadd_round_pch(__m512h, __m512h, __m512h, __mmask16, const int);
extern __m512h __cdecl _mm512_maskz_fcmadd_round_pch(__mmask16, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fcmadd_sch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmadd_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fcmadd_sch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fcmadd_sch(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fcmadd_round_sch(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fcmadd_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fcmadd_round_sch(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fcmadd_round_sch(__mmask8, __m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmadd_sch(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_sch(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_sch(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fmadd_round_sch(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmadd_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fmadd_round_sch(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fmadd_round_sch(__mmask8, __m128h, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_fcmul_pch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmul_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fcmul_pch(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_fcmul_pch(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fcmul_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_fcmul_pch(__mmask8, __m256h, __m256h);
extern __m512h __cdecl _mm512_fcmul_pch(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fcmul_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_fcmul_pch(__mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_fcmul_round_pch(__m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fcmul_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_fcmul_round_pch(__mmask16, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fmul_pch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmul_pch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fmul_pch(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmul_pch(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmul_pch(__m256h, __mmask8, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_fmul_pch(__mmask8, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmul_pch(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmul_pch(__m512h, __mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_fmul_pch(__mmask16, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmul_round_pch(__m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmul_round_pch(__m512h, __mmask16, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_fmul_round_pch(__mmask16, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fcmul_sch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fcmul_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fcmul_sch(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_fcmul_round_sch(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fcmul_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_fcmul_round_sch(__mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmul_sch(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmul_sch(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_fmul_sch(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_fmul_round_sch(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmul_round_sch(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_fmul_round_sch(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_fnmadd_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmadd_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmadd_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmadd_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fnmadd_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fnmadd_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fnmadd_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fnmadd_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fnmadd_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fnmadd_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fnmadd_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fnmadd_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fnmadd_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fnmadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fnmadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fnmadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fmadd_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmadd_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmadd_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmadd_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmadd_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmadd_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmadd_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmadd_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmadd_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmadd_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmadd_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmadd_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmadd_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fnmadd_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmadd_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmadd_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmadd_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fnmadd_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fnmadd_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fnmadd_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fnmadd_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmadd_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmadd_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmadd_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmadd_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fmadd_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmadd_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fmadd_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fmadd_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_fnmsub_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmsub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmsub_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmsub_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fnmsub_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fnmsub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fnmsub_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fnmsub_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fnmsub_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fnmsub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fnmsub_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fnmsub_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fnmsub_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fnmsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fnmsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fnmsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);
extern __m128h __cdecl _mm_fmsub_ph(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmsub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmsub_ph(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmsub_ph(__mmask8, __m128h, __m128h, __m128h);
extern __m256h __cdecl _mm256_fmsub_ph(__m256h, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask_fmsub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_mask3_fmsub_ph(__m256h, __m256h, __m256h, __mmask16);
extern __m256h __cdecl _mm256_maskz_fmsub_ph(__mmask16, __m256h, __m256h, __m256h);
extern __m512h __cdecl _mm512_fmsub_ph(__m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask_fmsub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mask3_fmsub_ph(__m512h, __m512h, __m512h, __mmask32);
extern __m512h __cdecl _mm512_maskz_fmsub_ph(__mmask32, __m512h, __m512h, __m512h);
extern __m512h __cdecl _mm512_fmsub_round_ph(__m512h, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_fmsub_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask3_fmsub_round_ph(__m512h, __m512h, __m512h, __mmask32, const int);
extern __m512h __cdecl _mm512_maskz_fmsub_round_ph(__mmask32, __m512h, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_fnmsub_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fnmsub_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fnmsub_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fnmsub_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fnmsub_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fnmsub_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fnmsub_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fnmsub_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_fmsub_sh(__m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_mask_fmsub_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mask3_fmsub_sh(__m128h, __m128h, __m128h, __mmask8);
extern __m128h __cdecl _mm_maskz_fmsub_sh(__mmask8, __m128h, __m128h, __m128h);
extern __m128h __cdecl _mm_fmsub_round_sh(__m128h, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_fmsub_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask3_fmsub_round_sh(__m128h, __m128h, __m128h, __mmask8, const int);
extern __m128h __cdecl _mm_maskz_fmsub_round_sh(__mmask8, __m128h, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_getexp_ph(__m128h);
extern __m128h __cdecl _mm_mask_getexp_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_getexp_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_getexp_ph(__m256h);
extern __m256h __cdecl _mm256_mask_getexp_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_getexp_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_getexp_ph(__m512h);
extern __m512h __cdecl _mm512_mask_getexp_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_getexp_ph(__mmask32, __m512h);
extern __m512h __cdecl _mm512_getexp_round_ph(__m512h, const int);
extern __m512h __cdecl _mm512_mask_getexp_round_ph(__m512h, __mmask32, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_getexp_round_ph(__mmask32, __m512h, const int);


extern __m128h __cdecl _mm_getexp_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_getexp_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_getexp_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_getexp_round_sh(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_getexp_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_getexp_round_sh(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_getmant_ph(__m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_mask_getmant_ph(__m128h, __mmask8, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_maskz_getmant_ph(__mmask8, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256h __cdecl _mm256_getmant_ph(__m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256h __cdecl _mm256_mask_getmant_ph(__m256h, __mmask16, __m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256h __cdecl _mm256_maskz_getmant_ph(__mmask16, __m256h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_getmant_ph(__m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_mask_getmant_ph(__m512h, __mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_maskz_getmant_ph(__mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512h __cdecl _mm512_getmant_round_ph(__m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m512h __cdecl _mm512_mask_getmant_round_ph(__m512h, __mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m512h __cdecl _mm512_maskz_getmant_round_ph(__mmask32, __m512h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);


extern __m128h __cdecl _mm_getmant_sh(__m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_mask_getmant_sh(__m128h, __mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_maskz_getmant_sh(__mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128h __cdecl _mm_getmant_round_sh(__m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m128h __cdecl _mm_mask_getmant_round_sh(__m128h, __mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);
extern __m128h __cdecl _mm_maskz_getmant_round_sh(__mmask8, __m128h, __m128h, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM, const int);


extern __m128h __cdecl _mm_max_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_max_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_max_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_max_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_max_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_max_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_max_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_max_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_max_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_max_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_max_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_max_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_max_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_max_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_max_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_max_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_max_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_max_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_min_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_min_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_min_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_min_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_min_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_min_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_min_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_min_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_min_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_min_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_min_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_min_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_min_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_min_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_min_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_min_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_min_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_min_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_load_sh(void const*);
extern __m128h __cdecl _mm_mask_load_sh(__m128h, __mmask8, void const*);
extern __m128h __cdecl _mm_maskz_load_sh(__mmask8, void const*);
extern void __cdecl _mm_store_sh(void*, __m128h);
extern void __cdecl _mm_mask_store_sh(void*, __mmask8, __m128h);
extern __m128h __cdecl _mm_move_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_move_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_move_sh(__mmask8, __m128h, __m128h);


extern __m128i __cdecl _mm_cvtsi16_si128(short);
extern short __cdecl _mm_cvtsi128_si16(__m128i);


extern __m128h __cdecl _mm_mul_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_mul_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_mul_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_mul_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_mul_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_mul_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_mul_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_mul_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_mul_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_mul_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_mul_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_mul_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_mul_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_mul_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_mul_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_mul_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_mul_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_mul_round_sh(__mmask8, __m128h, __m128h, int);


extern __m128h __cdecl _mm_rcp_ph(__m128h);
extern __m128h __cdecl _mm_mask_rcp_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_rcp_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_rcp_ph(__m256h);
extern __m256h __cdecl _mm256_mask_rcp_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_rcp_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_rcp_ph(__m512h);
extern __m512h __cdecl _mm512_mask_rcp_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_rcp_ph(__mmask32, __m512h);


extern __m128h __cdecl _mm_rcp_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_rcp_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_rcp_sh(__mmask8, __m128h, __m128h);


extern __m128h __cdecl _mm_reduce_ph(__m128h, int);
extern __m128h __cdecl _mm_mask_reduce_ph(__m128h, __mmask8, __m128h, int);
extern __m128h __cdecl _mm_maskz_reduce_ph(__mmask8, __m128h, int);
extern __m256h __cdecl _mm256_reduce_ph(__m256h, int);
extern __m256h __cdecl _mm256_mask_reduce_ph(__m256h, __mmask16, __m256h, int);
extern __m256h __cdecl _mm256_maskz_reduce_ph(__mmask16, __m256h, int);
extern __m512h __cdecl _mm512_reduce_ph(__m512h, int);
extern __m512h __cdecl _mm512_mask_reduce_ph(__m512h, __mmask32, __m512h, int);
extern __m512h __cdecl _mm512_maskz_reduce_ph(__mmask32, __m512h, int);
extern __m512h __cdecl _mm512_reduce_round_ph(__m512h, int, const int);
extern __m512h __cdecl _mm512_mask_reduce_round_ph(__m512h, __mmask32, __m512h, int, const int);
extern __m512h __cdecl _mm512_maskz_reduce_round_ph(__mmask32, __m512h, int, const int);


extern __m128h __cdecl _mm_reduce_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_reduce_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_reduce_sh(__mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_reduce_round_sh(__m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_mask_reduce_round_sh(__m128h, __mmask8, __m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_maskz_reduce_round_sh(__mmask8, __m128h, __m128h, int, const int);


extern __m128h __cdecl _mm_roundscale_ph(__m128h, int);
extern __m128h __cdecl _mm_mask_roundscale_ph(__m128h, __mmask8, __m128h, int);
extern __m128h __cdecl _mm_maskz_roundscale_ph(__mmask8, __m128h, int);
extern __m256h __cdecl _mm256_roundscale_ph(__m256h, int);
extern __m256h __cdecl _mm256_mask_roundscale_ph(__m256h, __mmask16, __m256h, int);
extern __m256h __cdecl _mm256_maskz_roundscale_ph(__mmask16, __m256h, int);
extern __m512h __cdecl _mm512_roundscale_ph(__m512h, int);
extern __m512h __cdecl _mm512_mask_roundscale_ph(__m512h, __mmask32, __m512h, int);
extern __m512h __cdecl _mm512_maskz_roundscale_ph(__mmask32, __m512h, int);
extern __m512h __cdecl _mm512_roundscale_round_ph(__m512h, int, const int);
extern __m512h __cdecl _mm512_mask_roundscale_round_ph(__m512h, __mmask32, __m512h, int, const int);
extern __m512h __cdecl _mm512_maskz_roundscale_round_ph(__mmask32, __m512h, int, const int);


extern __m128h __cdecl _mm_roundscale_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_roundscale_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_roundscale_sh(__mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_roundscale_round_sh(__m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_mask_roundscale_round_sh(__m128h, __mmask8, __m128h, __m128h, int, const int);
extern __m128h __cdecl _mm_maskz_roundscale_round_sh(__mmask8, __m128h, __m128h, int, const int);


extern __m128h __cdecl _mm_rsqrt_ph(__m128h);
extern __m128h __cdecl _mm_mask_rsqrt_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_rsqrt_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_rsqrt_ph(__m256h);
extern __m256h __cdecl _mm256_mask_rsqrt_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_rsqrt_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_rsqrt_ph(__m512h);
extern __m512h __cdecl _mm512_mask_rsqrt_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_rsqrt_ph(__mmask32, __m512h);


extern __m128h __cdecl _mm_rsqrt_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_rsqrt_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_rsqrt_sh(__mmask8, __m128h, __m128h);


extern __m128h __cdecl _mm_scalef_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_scalef_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_scalef_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_scalef_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_scalef_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_scalef_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_scalef_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_scalef_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_scalef_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_scalef_round_ph(__m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_scalef_round_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_scalef_round_ph(__mmask32, __m512h, __m512h, const int);


extern __m128h __cdecl _mm_scalef_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_scalef_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_scalef_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_scalef_round_sh(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_scalef_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_scalef_round_sh(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_sqrt_ph(__m128h);
extern __m128h __cdecl _mm_mask_sqrt_ph(__m128h, __mmask8, __m128h);
extern __m128h __cdecl _mm_maskz_sqrt_ph(__mmask8, __m128h);
extern __m256h __cdecl _mm256_sqrt_ph(__m256h);
extern __m256h __cdecl _mm256_mask_sqrt_ph(__m256h, __mmask16, __m256h);
extern __m256h __cdecl _mm256_maskz_sqrt_ph(__mmask16, __m256h);
extern __m512h __cdecl _mm512_sqrt_ph(__m512h);
extern __m512h __cdecl _mm512_mask_sqrt_ph(__m512h, __mmask32, __m512h);
extern __m512h __cdecl _mm512_maskz_sqrt_ph(__mmask32, __m512h);
extern __m512h __cdecl _mm512_sqrt_round_ph(__m512h, const int);
extern __m512h __cdecl _mm512_mask_sqrt_round_ph(__m512h, __mmask32, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_sqrt_round_ph(__mmask32, __m512h, const int);


extern __m128h __cdecl _mm_sqrt_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_sqrt_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_sqrt_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_sqrt_round_sh(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_sqrt_round_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_sqrt_round_sh(__mmask8, __m128h, __m128h, const int);


extern __m128h __cdecl _mm_sub_ph(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_sub_ph(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_sub_ph(__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_sub_ph(__m256h, __m256h);
extern __m256h __cdecl _mm256_mask_sub_ph(__m256h, __mmask16, __m256h, __m256h);
extern __m256h __cdecl _mm256_maskz_sub_ph(__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_sub_ph(__m512h, __m512h);
extern __m512h __cdecl _mm512_mask_sub_ph(__m512h, __mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_maskz_sub_ph(__mmask32, __m512h, __m512h);
extern __m512h __cdecl _mm512_sub_round_ph(__m512h, __m512h, int);
extern __m512h __cdecl _mm512_mask_sub_round_ph(__m512h, __mmask32, __m512h, __m512h, int);
extern __m512h __cdecl _mm512_maskz_sub_round_ph(__mmask32, __m512h, __m512h, int);


extern __m128h __cdecl _mm_sub_sh(__m128h, __m128h);
extern __m128h __cdecl _mm_mask_sub_sh(__m128h, __mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_maskz_sub_sh(__mmask8, __m128h, __m128h);
extern __m128h __cdecl _mm_sub_round_sh(__m128h, __m128h, int);
extern __m128h __cdecl _mm_mask_sub_round_sh(__m128h, __mmask8, __m128h, __m128h, int);
extern __m128h __cdecl _mm_maskz_sub_round_sh(__mmask8, __m128h, __m128h, int);

extern __m128h __cdecl _mm_mask_blend_ph (__mmask8, __m128h, __m128h);
extern __m256h __cdecl _mm256_mask_blend_ph (__mmask16, __m256h, __m256h);
extern __m512h __cdecl _mm512_mask_blend_ph (__mmask32, __m512h, __m512h);


extern __m256  __cdecl _mm256_rsqrt14_ps(__m256);
extern __m256d __cdecl _mm256_rsqrt14_pd(__m256d);
extern __m128  __cdecl _mm_rsqrt14_ps(__m128);
extern __m128d __cdecl _mm_rsqrt14_pd(__m128d);


extern float  __cdecl __getexp_ss(float);
extern double __cdecl __getexp_sd(double);
extern float  __cdecl __getmant_ss(float, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern double __cdecl __getmant_sd(double, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern float  __cdecl __scalef_ss(float, float);
extern double __cdecl __scalef_sd(double, double);


extern __m512i __cdecl _mm512_sm4key4_epi32(__m512i, __m512i);
extern __m512i __cdecl _mm512_sm4rnds4_epi32(__m512i, __m512i);
























































































































































extern __m128i __cdecl _mm_loadrs_epi8(void const *);
extern __m128i __cdecl _mm_mask_loadrs_epi8(__m128i, __mmask16, void const *);
extern __m128i __cdecl _mm_maskz_loadrs_epi8(__mmask16, void const *);

extern __m256i __cdecl _mm256_loadrs_epi8(void const *);
extern __m256i __cdecl _mm256_mask_loadrs_epi8(__m256i, __mmask32, void const *);
extern __m256i __cdecl _mm256_maskz_loadrs_epi8(__mmask32, void const *);

extern __m512i __cdecl _mm512_loadrs_epi8(void const *);
extern __m512i __cdecl _mm512_mask_loadrs_epi8(__m512i, __mmask64, void const *);
extern __m512i __cdecl _mm512_maskz_loadrs_epi8(__mmask64, void const *);

extern __m128i __cdecl _mm_loadrs_epi16(void const *);
extern __m128i __cdecl _mm_mask_loadrs_epi16(__m128i, __mmask8, void const *);
extern __m128i __cdecl _mm_maskz_loadrs_epi16(__mmask8, void const *);

extern __m256i __cdecl _mm256_loadrs_epi16(void const *);
extern __m256i __cdecl _mm256_mask_loadrs_epi16(__m256i, __mmask16, void const *);
extern __m256i __cdecl _mm256_maskz_loadrs_epi16(__mmask16, void const *);

extern __m512i __cdecl _mm512_loadrs_epi16(void const *);
extern __m512i __cdecl _mm512_mask_loadrs_epi16(__m512i, __mmask32, void const *);
extern __m512i __cdecl _mm512_maskz_loadrs_epi16(__mmask32, void const *);

extern __m128i __cdecl _mm_loadrs_epi32(void const *);
extern __m128i __cdecl _mm_mask_loadrs_epi32(__m128i, __mmask8, void const *);
extern __m128i __cdecl _mm_maskz_loadrs_epi32(__mmask8, void const *);

extern __m256i __cdecl _mm256_loadrs_epi32(void const *);
extern __m256i __cdecl _mm256_mask_loadrs_epi32(__m256i, __mmask8, void const *);
extern __m256i __cdecl _mm256_maskz_loadrs_epi32(__mmask8, void const *);

extern __m512i __cdecl _mm512_loadrs_epi32(void const *);
extern __m512i __cdecl _mm512_mask_loadrs_epi32(__m512i, __mmask16, void const *);
extern __m512i __cdecl _mm512_maskz_loadrs_epi32(__mmask16, void const *);

extern __m128i __cdecl _mm_loadrs_epi64(void const *);
extern __m128i __cdecl _mm_mask_loadrs_epi64(__m128i, __mmask8, void const *);
extern __m128i __cdecl _mm_maskz_loadrs_epi64(__mmask8, void const *);

extern __m256i __cdecl _mm256_loadrs_epi64(void const *);
extern __m256i __cdecl _mm256_mask_loadrs_epi64(__m256i, __mmask8, void const *);
extern __m256i __cdecl _mm256_maskz_loadrs_epi64(__mmask8, void const *);

extern __m512i __cdecl _mm512_loadrs_epi64(void const *);
extern __m512i __cdecl _mm512_mask_loadrs_epi64(__m512i, __mmask8, void const *);
extern __m512i __cdecl _mm512_maskz_loadrs_epi64(__mmask8, void const *);
#line 6423 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern __m128bh  __cdecl _mm_add_pbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_add_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_maskz_add_pbh(__mmask8, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_add_pbh(__m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_add_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_add_pbh(__mmask16, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_add_pbh(__m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_add_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_add_pbh(__mmask32, __m512bh, __m512bh);
extern __mmask8  __cdecl _mm_cmp_pbh_mask(__m128bh, __m128bh, const int);
extern __mmask8  __cdecl _mm_mask_cmp_pbh_mask(__mmask8, __m128bh, __m128bh, const int);
extern __mmask16 __cdecl _mm256_cmp_pbh_mask(__m256bh, __m256bh, const int);
extern __mmask16 __cdecl _mm256_mask_cmp_pbh_mask(__mmask16, __m256bh, __m256bh, const int);
extern __mmask32 __cdecl _mm512_cmp_pbh_mask(__m512bh, __m512bh, const int);
extern __mmask32 __cdecl _mm512_mask_cmp_pbh_mask(__mmask32, __m512bh, __m512bh, const int);
extern int       __cdecl _mm_comeq_sbh(__m128bh, __m128bh);
extern int       __cdecl _mm_comlt_sbh(__m128bh, __m128bh);
extern int       __cdecl _mm_comle_sbh(__m128bh, __m128bh);
extern int       __cdecl _mm_comgt_sbh(__m128bh, __m128bh);
extern int       __cdecl _mm_comge_sbh(__m128bh, __m128bh);
extern int       __cdecl _mm_comneq_sbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_div_pbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_div_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_maskz_div_pbh(__mmask8, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_div_pbh(__m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_div_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_div_pbh(__mmask16, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_div_pbh(__m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_div_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_div_pbh(__mmask32, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_fmadd_pbh(__m128bh, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_fmadd_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask3_fmadd_pbh(__m128bh, __m128bh, __m128bh, __mmask8);
extern __m128bh  __cdecl _mm_maskz_fmadd_pbh(__mmask8, __m128bh, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_fmadd_pbh(__m256bh, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_fmadd_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask3_fmadd_pbh(__m256bh, __m256bh, __m256bh, __mmask16);
extern __m256bh  __cdecl _mm256_maskz_fmadd_pbh(__mmask16, __m256bh, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_fmadd_pbh(__m512bh, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_fmadd_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask3_fmadd_pbh(__m512bh, __m512bh, __m512bh, __mmask32);
extern __m512bh  __cdecl _mm512_maskz_fmadd_pbh(__mmask32, __m512bh, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_fmsub_pbh(__m128bh, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_fmsub_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask3_fmsub_pbh(__m128bh, __m128bh, __m128bh, __mmask8);
extern __m128bh  __cdecl _mm_maskz_fmsub_pbh(__mmask8, __m128bh, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_fmsub_pbh(__m256bh, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_fmsub_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask3_fmsub_pbh(__m256bh, __m256bh, __m256bh, __mmask16);
extern __m256bh  __cdecl _mm256_maskz_fmsub_pbh(__mmask16, __m256bh, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_fmsub_pbh(__m512bh, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_fmsub_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask3_fmsub_pbh(__m512bh, __m512bh, __m512bh, __mmask32);
extern __m512bh  __cdecl _mm512_maskz_fmsub_pbh(__mmask32, __m512bh, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_fnmadd_pbh(__m128bh, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_fnmadd_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask3_fnmadd_pbh(__m128bh, __m128bh, __m128bh, __mmask8);
extern __m128bh  __cdecl _mm_maskz_fnmadd_pbh(__mmask8, __m128bh, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_fnmadd_pbh(__m256bh, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_fnmadd_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask3_fnmadd_pbh(__m256bh, __m256bh, __m256bh, __mmask16);
extern __m256bh  __cdecl _mm256_maskz_fnmadd_pbh(__mmask16, __m256bh, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_fnmadd_pbh(__m512bh, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_fnmadd_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask3_fnmadd_pbh(__m512bh, __m512bh, __m512bh, __mmask32);
extern __m512bh  __cdecl _mm512_maskz_fnmadd_pbh(__mmask32, __m512bh, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_fnmsub_pbh(__m128bh, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_fnmsub_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask3_fnmsub_pbh(__m128bh, __m128bh, __m128bh, __mmask8);
extern __m128bh  __cdecl _mm_maskz_fnmsub_pbh(__mmask8, __m128bh, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_fnmsub_pbh(__m256bh, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_fnmsub_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask3_fnmsub_pbh(__m256bh, __m256bh, __m256bh, __mmask16);
extern __m256bh  __cdecl _mm256_maskz_fnmsub_pbh(__mmask16, __m256bh, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_fnmsub_pbh(__m512bh, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_fnmsub_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask3_fnmsub_pbh(__m512bh, __m512bh, __m512bh, __mmask32);
extern __m512bh  __cdecl _mm512_maskz_fnmsub_pbh(__mmask32, __m512bh, __m512bh, __m512bh);
extern __mmask8  __cdecl _mm_fpclass_pbh_mask(__m128bh, const int);
extern __mmask8  __cdecl _mm_mask_fpclass_pbh_mask(__mmask8, __m128bh, const int);
extern __mmask16 __cdecl _mm256_fpclass_pbh_mask(__m256bh, const int);
extern __mmask16 __cdecl _mm256_mask_fpclass_pbh_mask(__mmask16, __m256bh, const int);
extern __mmask32 __cdecl _mm512_fpclass_pbh_mask(__m512bh, const int);
extern __mmask32 __cdecl _mm512_mask_fpclass_pbh_mask(__mmask32, __m512bh, const int);
extern __m128bh  __cdecl _mm_getexp_pbh(__m128bh);
extern __m128bh  __cdecl _mm_mask_getexp_pbh(__m128bh, __mmask8, __m128bh);
extern __m128bh  __cdecl _mm_maskz_getexp_pbh(__mmask8, __m128bh);
extern __m256bh  __cdecl _mm256_getexp_pbh(__m256bh);
extern __m256bh  __cdecl _mm256_mask_getexp_pbh(__m256bh, __mmask16, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_getexp_pbh(__mmask16, __m256bh);
extern __m512bh  __cdecl _mm512_getexp_pbh(__m512bh);
extern __m512bh  __cdecl _mm512_mask_getexp_pbh(__m512bh, __mmask32, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_getexp_pbh(__mmask32, __m512bh);
extern __m128bh  __cdecl _mm_getmant_pbh(__m128bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128bh  __cdecl _mm_mask_getmant_pbh(__m128bh, __mmask8, __m128bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128bh  __cdecl _mm_maskz_getmant_pbh(__mmask8, __m128bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256bh  __cdecl _mm256_getmant_pbh(__m256bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256bh  __cdecl _mm256_mask_getmant_pbh(__m256bh, __mmask16, __m256bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m256bh  __cdecl _mm256_maskz_getmant_pbh(__mmask16, __m256bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512bh  __cdecl _mm512_getmant_pbh(__m512bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512bh  __cdecl _mm512_mask_getmant_pbh(__m512bh, __mmask32, __m512bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m512bh  __cdecl _mm512_maskz_getmant_pbh(__mmask32, __m512bh, _MM_MANTISSA_NORM_ENUM, _MM_MANTISSA_SIGN_ENUM);
extern __m128bh  __cdecl _mm_max_pbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_max_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_maskz_max_pbh(__mmask8, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_max_pbh(__m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_max_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_max_pbh(__mmask16, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_max_pbh(__m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_max_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_max_pbh(__mmask32, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_min_pbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_min_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_maskz_min_pbh(__mmask8, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_min_pbh(__m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_min_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_min_pbh(__mmask16, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_min_pbh(__m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_min_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_min_pbh(__mmask32, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_mul_pbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_mul_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_maskz_mul_pbh(__mmask8, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_mul_pbh(__m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_mul_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_mul_pbh(__mmask16, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_mul_pbh(__m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_mul_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_mul_pbh(__mmask32, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_rcp_pbh(__m128bh);
extern __m128bh  __cdecl _mm_mask_rcp_pbh(__m128bh, __mmask8, __m128bh);
extern __m128bh  __cdecl _mm_maskz_rcp_pbh(__mmask8, __m128bh);
extern __m256bh  __cdecl _mm256_rcp_pbh(__m256bh);
extern __m256bh  __cdecl _mm256_mask_rcp_pbh(__m256bh, __mmask16, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_rcp_pbh(__mmask16, __m256bh);
extern __m512bh  __cdecl _mm512_rcp_pbh(__m512bh);
extern __m512bh  __cdecl _mm512_mask_rcp_pbh(__m512bh, __mmask32, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_rcp_pbh(__mmask32, __m512bh);
extern __m128bh  __cdecl _mm_reduce_pbh(__m128bh, int);
extern __m128bh  __cdecl _mm_mask_reduce_pbh(__m128bh, __mmask8, __m128bh, int);
extern __m128bh  __cdecl _mm_maskz_reduce_pbh(__mmask8, __m128bh, int);
extern __m256bh  __cdecl _mm256_reduce_pbh(__m256bh, int);
extern __m256bh  __cdecl _mm256_mask_reduce_pbh(__m256bh, __mmask16, __m256bh, int);
extern __m256bh  __cdecl _mm256_maskz_reduce_pbh(__mmask16, __m256bh, int);
extern __m512bh  __cdecl _mm512_reduce_pbh(__m512bh, int);
extern __m512bh  __cdecl _mm512_mask_reduce_pbh(__m512bh, __mmask32, __m512bh, int);
extern __m512bh  __cdecl _mm512_maskz_reduce_pbh(__mmask32, __m512bh, int);
extern __m128bh  __cdecl _mm_rndscale_pbh(__m128bh, int);
extern __m128bh  __cdecl _mm_mask_rndscale_pbh(__m128bh, __mmask8, __m128bh, int);
extern __m128bh  __cdecl _mm_maskz_rndscale_pbh(__mmask8, __m128bh, int);
extern __m256bh  __cdecl _mm256_rndscale_pbh(__m256bh, int);
extern __m256bh  __cdecl _mm256_mask_rndscale_pbh(__m256bh, __mmask16, __m256bh, int);
extern __m256bh  __cdecl _mm256_maskz_rndscale_pbh(__mmask16, __m256bh, int);
extern __m512bh  __cdecl _mm512_rndscale_pbh(__m512bh, int);
extern __m512bh  __cdecl _mm512_mask_rndscale_pbh(__m512bh, __mmask32, __m512bh, int);
extern __m512bh  __cdecl _mm512_maskz_rndscale_pbh(__mmask32, __m512bh, int);
extern __m128bh  __cdecl _mm_rsqrt_pbh(__m128bh);
extern __m128bh  __cdecl _mm_mask_rsqrt_pbh(__m128bh, __mmask8, __m128bh);
extern __m128bh  __cdecl _mm_maskz_rsqrt_pbh(__mmask8, __m128bh);
extern __m256bh  __cdecl _mm256_rsqrt_pbh(__m256bh);
extern __m256bh  __cdecl _mm256_mask_rsqrt_pbh(__m256bh, __mmask16, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_rsqrt_pbh(__mmask16, __m256bh);
extern __m512bh  __cdecl _mm512_rsqrt_pbh(__m512bh);
extern __m512bh  __cdecl _mm512_mask_rsqrt_pbh(__m512bh, __mmask32, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_rsqrt_pbh(__mmask32, __m512bh);
extern __m128bh  __cdecl _mm_scalef_pbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_scalef_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_maskz_scalef_pbh(__mmask8, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_scalef_pbh(__m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_scalef_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_scalef_pbh(__mmask16, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_scalef_pbh(__m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_scalef_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_scalef_pbh(__mmask32, __m512bh, __m512bh);
extern __m128bh  __cdecl _mm_sqrt_pbh(__m128bh);
extern __m128bh  __cdecl _mm_mask_sqrt_pbh(__m128bh, __mmask8, __m128bh);
extern __m128bh  __cdecl _mm_maskz_sqrt_pbh(__mmask8, __m128bh);
extern __m256bh  __cdecl _mm256_sqrt_pbh(__m256bh);
extern __m256bh  __cdecl _mm256_mask_sqrt_pbh(__m256bh, __mmask16, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_sqrt_pbh(__mmask16, __m256bh);
extern __m512bh  __cdecl _mm512_sqrt_pbh(__m512bh);
extern __m512bh  __cdecl _mm512_mask_sqrt_pbh(__m512bh, __mmask32, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_sqrt_pbh(__mmask32, __m512bh);
extern __m128bh  __cdecl _mm_sub_pbh(__m128bh, __m128bh);
extern __m128bh  __cdecl _mm_mask_sub_pbh(__m128bh, __mmask8, __m128bh, __m128bh);
extern __m128bh  __cdecl _mm_maskz_sub_pbh(__mmask8, __m128bh, __m128bh);
extern __m256bh  __cdecl _mm256_sub_pbh(__m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_mask_sub_pbh(__m256bh, __mmask16, __m256bh, __m256bh);
extern __m256bh  __cdecl _mm256_maskz_sub_pbh(__mmask16, __m256bh, __m256bh);
extern __m512bh  __cdecl _mm512_sub_pbh(__m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_mask_sub_pbh(__m512bh, __mmask32, __m512bh, __m512bh);
extern __m512bh  __cdecl _mm512_maskz_sub_pbh(__mmask32, __m512bh, __m512bh);


extern __m128h __cdecl _mm_cvtx2ps_ph(__m128, __m128);
extern __m128h __cdecl _mm_mask_cvtx2ps_ph(__m128h, __mmask8, __m128, __m128);
extern __m128h __cdecl _mm_maskz_cvtx2ps_ph(__mmask8, __m128, __m128);
extern __m256h __cdecl _mm256_cvtx2ps_ph(__m256, __m256);
extern __m256h __cdecl _mm256_mask_cvtx2ps_ph(__m256h, __mmask16, __m256, __m256);
extern __m256h __cdecl _mm256_maskz_cvtx2ps_ph(__mmask16, __m256, __m256);
extern __m512h __cdecl _mm512_cvtx2ps_ph(__m512, __m512);
extern __m512h __cdecl _mm512_mask_cvtx2ps_ph(__m512h, __mmask32, __m512, __m512);
extern __m512h __cdecl _mm512_maskz_cvtx2ps_ph(__mmask32, __m512, __m512);
extern __m512h __cdecl _mm512_cvtx_round2ps_ph(__m512, __m512, const int);
extern __m512h __cdecl _mm512_mask_cvtx_round2ps_ph(__m512h, __mmask32, __m512, __m512, const int);
extern __m512h __cdecl _mm512_maskz_cvtx_round2ps_ph(__mmask32, __m512, __m512, const int);
extern __m128i __cdecl _mm_cvtbiasph_pbf8(__m128i, __m128h);
extern __m128i __cdecl _mm_mask_cvtbiasph_pbf8(__m128i, __mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm_maskz_cvtbiasph_pbf8(__mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm256_cvtbiasph_pbf8(__m256i, __m256h);
extern __m128i __cdecl _mm256_mask_cvtbiasph_pbf8(__m128i, __mmask16, __m256i, __m256h);
extern __m128i __cdecl _mm256_maskz_cvtbiasph_pbf8(__mmask16, __m256i, __m256h);
extern __m256i __cdecl _mm512_cvtbiasph_pbf8(__m512i, __m512h);
extern __m256i __cdecl _mm512_mask_cvtbiasph_pbf8(__m256i, __mmask32, __m512i, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtbiasph_pbf8(__mmask32, __m512i, __m512h);
extern __m128i __cdecl _mm_cvtbiassph_pbf8(__m128i, __m128h);
extern __m128i __cdecl _mm_mask_cvtbiassph_pbf8(__m128i, __mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm_maskz_cvtbiassph_pbf8(__mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm256_cvtbiassph_pbf8(__m256i, __m256h);
extern __m128i __cdecl _mm256_mask_cvtbiassph_pbf8(__m128i, __mmask16, __m256i, __m256h);
extern __m128i __cdecl _mm256_maskz_cvtbiassph_pbf8(__mmask16, __m256i, __m256h);
extern __m256i __cdecl _mm512_cvtbiassph_pbf8(__m512i, __m512h);
extern __m256i __cdecl _mm512_mask_cvtbiassph_pbf8(__m256i, __mmask32, __m512i, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtbiassph_pbf8(__mmask32, __m512i, __m512h);
extern __m128i __cdecl _mm_cvtbiasph_phf8(__m128i, __m128h);
extern __m128i __cdecl _mm_mask_cvtbiasph_phf8(__m128i, __mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm_maskz_cvtbiasph_phf8(__mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm256_cvtbiasph_phf8(__m256i, __m256h);
extern __m128i __cdecl _mm256_mask_cvtbiasph_phf8(__m128i, __mmask16, __m256i, __m256h);
extern __m128i __cdecl _mm256_maskz_cvtbiasph_phf8(__mmask16, __m256i, __m256h);
extern __m256i __cdecl _mm512_cvtbiasph_phf8(__m512i, __m512h);
extern __m256i __cdecl _mm512_mask_cvtbiasph_phf8(__m256i, __mmask32, __m512i, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtbiasph_phf8(__mmask32, __m512i, __m512h);
extern __m128i __cdecl _mm_cvtbiassph_phf8(__m128i, __m128h);
extern __m128i __cdecl _mm_mask_cvtbiassph_phf8(__m128i, __mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm_maskz_cvtbiassph_phf8(__mmask8, __m128i, __m128h);
extern __m128i __cdecl _mm256_cvtbiassph_phf8(__m256i, __m256h);
extern __m128i __cdecl _mm256_mask_cvtbiassph_phf8(__m128i, __mmask16, __m256i, __m256h);
extern __m128i __cdecl _mm256_maskz_cvtbiassph_phf8(__mmask16, __m256i, __m256h);
extern __m256i __cdecl _mm512_cvtbiassph_phf8(__m512i, __m512h);
extern __m256i __cdecl _mm512_mask_cvtbiassph_phf8(__m256i, __mmask32, __m512i, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtbiassph_phf8(__mmask32, __m512i, __m512h);
extern __m128h __cdecl _mm_cvthf8_ph(__m128i);
extern __m128h __cdecl _mm_mask_cvthf8_ph(__m128h, __mmask8, __m128i);
extern __m128h __cdecl _mm_maskz_cvthf8_ph(__mmask8, __m128i);
extern __m256h __cdecl _mm256_cvthf8_ph(__m128i);
extern __m256h __cdecl _mm256_mask_cvthf8_ph(__m256h, __mmask16, __m128i);
extern __m256h __cdecl _mm256_maskz_cvthf8_ph(__mmask16, __m128i);
extern __m512h __cdecl _mm512_cvthf8_ph(__m256i);
extern __m512h __cdecl _mm512_mask_cvthf8_ph(__m512h, __mmask32, __m256i);
extern __m512h __cdecl _mm512_maskz_cvthf8_ph(__mmask32, __m256i);
extern __m128i __cdecl _mm_cvt2ph_bf8(__m128h, __m128h);
extern __m128i __cdecl _mm_mask_cvt2ph_bf8(__m128i, __mmask16, __m128h, __m128h);
extern __m128i __cdecl _mm_maskz_cvt2ph_bf8(__mmask16, __m128h, __m128h);
extern __m256i __cdecl _mm256_cvt2ph_bf8(__m256h, __m256h);
extern __m256i __cdecl _mm256_mask_cvt2ph_bf8(__m256i, __mmask32, __m256h, __m256h);
extern __m256i __cdecl _mm256_maskz_cvt2ph_bf8(__mmask32, __m256h, __m256h);
extern __m512i __cdecl _mm512_cvt2ph_bf8(__m512h, __m512h);
extern __m512i __cdecl _mm512_mask_cvt2ph_bf8(__m512i, __mmask64, __m512h, __m512h);
extern __m512i __cdecl _mm512_maskz_cvt2ph_bf8(__mmask64, __m512h, __m512h);
extern __m128i __cdecl _mm_cvts2ph_bf8(__m128h, __m128h);
extern __m128i __cdecl _mm_mask_cvts2ph_bf8(__m128i, __mmask16, __m128h, __m128h);
extern __m128i __cdecl _mm_maskz_cvts2ph_bf8(__mmask16, __m128h, __m128h);
extern __m256i __cdecl _mm256_cvts2ph_bf8(__m256h, __m256h);
extern __m256i __cdecl _mm256_mask_cvts2ph_bf8(__m256i, __mmask32, __m256h, __m256h);
extern __m256i __cdecl _mm256_maskz_cvts2ph_bf8(__mmask32, __m256h, __m256h);
extern __m512i __cdecl _mm512_cvts2ph_bf8(__m512h, __m512h);
extern __m512i __cdecl _mm512_mask_cvts2ph_bf8(__m512i, __mmask64, __m512h, __m512h);
extern __m512i __cdecl _mm512_maskz_cvts2ph_bf8(__mmask64, __m512h, __m512h);
extern __m128i __cdecl _mm_cvt2ph_hf8(__m128h, __m128h);
extern __m128i __cdecl _mm_mask_cvt2ph_hf8(__m128i, __mmask16, __m128h, __m128h);
extern __m128i __cdecl _mm_maskz_cvt2ph_hf8(__mmask16, __m128h, __m128h);
extern __m256i __cdecl _mm256_cvt2ph_hf8(__m256h, __m256h);
extern __m256i __cdecl _mm256_mask_cvt2ph_hf8(__m256i, __mmask32, __m256h, __m256h);
extern __m256i __cdecl _mm256_maskz_cvt2ph_hf8(__mmask32, __m256h, __m256h);
extern __m512i __cdecl _mm512_cvt2ph_hf8(__m512h, __m512h);
extern __m512i __cdecl _mm512_mask_cvt2ph_hf8(__m512i, __mmask64, __m512h, __m512h);
extern __m512i __cdecl _mm512_maskz_cvt2ph_hf8(__mmask64, __m512h, __m512h);
extern __m128i __cdecl _mm_cvts2ph_hf8(__m128h, __m128h);
extern __m128i __cdecl _mm_mask_cvts2ph_hf8(__m128i, __mmask16, __m128h, __m128h);
extern __m128i __cdecl _mm_maskz_cvts2ph_hf8(__mmask16, __m128h, __m128h);
extern __m256i __cdecl _mm256_cvts2ph_hf8(__m256h, __m256h);
extern __m256i __cdecl _mm256_mask_cvts2ph_hf8(__m256i, __mmask32, __m256h, __m256h);
extern __m256i __cdecl _mm256_maskz_cvts2ph_hf8(__mmask32, __m256h, __m256h);
extern __m512i __cdecl _mm512_cvts2ph_hf8(__m512h, __m512h);
extern __m512i __cdecl _mm512_mask_cvts2ph_hf8(__m512i, __mmask64, __m512h, __m512h);
extern __m512i __cdecl _mm512_maskz_cvts2ph_hf8(__mmask64, __m512h, __m512h);
extern __m128i __cdecl _mm_cvtph_bf8(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_bf8(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_bf8(__mmask8, __m128h);
extern __m128i __cdecl _mm256_cvtph_bf8(__m256h);
extern __m128i __cdecl _mm256_mask_cvtph_bf8(__m128i, __mmask16,  __m256h);
extern __m128i __cdecl _mm256_maskz_cvtph_bf8(__mmask16, __m256h);
extern __m256i __cdecl _mm512_cvtph_bf8(__m512h);
extern __m256i __cdecl _mm512_mask_cvtph_bf8(__m256i, __mmask32, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtph_bf8(__mmask32, __m512h);
extern __m128i __cdecl _mm_cvtsph_bf8(__m128h);
extern __m128i __cdecl _mm_mask_cvtsph_bf8(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtsph_bf8(__mmask8, __m128h);
extern __m128i __cdecl _mm256_cvtsph_bf8(__m256h);
extern __m128i __cdecl _mm256_mask_cvtsph_bf8(__m128i, __mmask16,  __m256h);
extern __m128i __cdecl _mm256_maskz_cvtsph_bf8(__mmask16, __m256h);
extern __m256i __cdecl _mm512_cvtsph_bf8(__m512h);
extern __m256i __cdecl _mm512_mask_cvtsph_bf8(__m256i, __mmask32, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtsph_bf8(__mmask32, __m512h);
extern __m128i __cdecl _mm_cvtph_hf8(__m128h);
extern __m128i __cdecl _mm_mask_cvtph_hf8(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtph_hf8(__mmask8, __m128h);
extern __m128i __cdecl _mm256_cvtph_hf8(__m256h);
extern __m128i __cdecl _mm256_mask_cvtph_hf8(__m128i, __mmask16,  __m256h);
extern __m128i __cdecl _mm256_maskz_cvtph_hf8(__mmask16, __m256h);
extern __m256i __cdecl _mm512_cvtph_hf8(__m512h);
extern __m256i __cdecl _mm512_mask_cvtph_hf8(__m256i, __mmask32, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtph_hf8(__mmask32, __m512h);
extern __m128i __cdecl _mm_cvtsph_hf8(__m128h);
extern __m128i __cdecl _mm_mask_cvtsph_hf8(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_cvtsph_hf8(__mmask8, __m128h);
extern __m128i __cdecl _mm256_cvtsph_hf8(__m256h);
extern __m128i __cdecl _mm256_mask_cvtsph_hf8(__m128i, __mmask16,  __m256h);
extern __m128i __cdecl _mm256_maskz_cvtsph_hf8(__mmask16, __m256h);
extern __m256i __cdecl _mm512_cvtsph_hf8(__m512h);
extern __m256i __cdecl _mm512_mask_cvtsph_hf8(__m256i, __mmask32, __m512h);
extern __m256i __cdecl _mm512_maskz_cvtsph_hf8(__mmask32, __m512h);



extern unsigned int __cdecl _mm_cvttsss_u32(__m128);
extern unsigned int __cdecl _mm_cvtts_roundss_u32(__m128, const int);

extern unsigned long long __cdecl _mm_cvttsss_u64(__m128);
extern unsigned long long __cdecl _mm_cvtts_roundss_u64(__m128, const int); 
#line 6757 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern int       __cdecl _mm_cvttsss_i32(__m128);
extern int       __cdecl _mm_cvtts_roundss_i32(__m128, const int);

extern long long   __cdecl _mm_cvtts_roundss_i64(__m128, const int); 
extern long long   __cdecl _mm_cvttsss_i64(__m128);
#line 6765 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern unsigned int __cdecl _mm_cvttsds_u32(__m128d);
extern unsigned int __cdecl _mm_cvtts_roundsd_u32(__m128d, const int);

extern unsigned long long __cdecl _mm_cvttsds_u64(__m128d);
extern unsigned long long __cdecl _mm_cvtts_roundsd_u64(__m128d, const int); 
#line 6773 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern int       __cdecl _mm_cvttsds_i32(__m128d);
extern int       __cdecl _mm_cvtts_roundsd_i32(__m128d, const int);

extern long long   __cdecl _mm_cvtts_roundsd_i64(__m128d, const int);
extern long long   __cdecl _mm_cvttsds_i64(__m128d);
#line 6781 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


extern __m128i __cdecl _mm_cvttsps_epu64(__m128);
extern __m128i __cdecl _mm_mask_cvttsps_epu64(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_cvttsps_epu64(__mmask8, __m128);
extern __m256i __cdecl _mm256_cvttsps_epu64(__m128);
extern __m256i __cdecl _mm256_mask_cvttsps_epu64(__m256i, __mmask8, __m128);
extern __m256i __cdecl _mm256_maskz_cvttsps_epu64(__mmask8, __m128);
extern __m512i __cdecl _mm512_cvttsps_epu64(__m256);
extern __m512i __cdecl _mm512_mask_cvttsps_epu64(__m512i, __mmask8, __m256);
extern __m512i __cdecl _mm512_maskz_cvttsps_epu64(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvtts_roundps_epu64(__m256, const int);
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epu64(__m512i, __mmask8, __m256, const int);
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epu64(__mmask8, __m256, const int);


extern __m128i __cdecl _mm_cvttsps_epu32(__m128);
extern __m128i __cdecl _mm_mask_cvttsps_epu32(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_cvttsps_epu32(__mmask8, __m128);
extern __m256i __cdecl _mm256_cvttsps_epu32(__m256);
extern __m256i __cdecl _mm256_mask_cvttsps_epu32(__m256i, __mmask8, __m256);
extern __m256i __cdecl _mm256_maskz_cvttsps_epu32(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvttsps_epu32(__m512); 
extern __m512i __cdecl _mm512_mask_cvttsps_epu32(__m512i, __mmask16, __m512); 
extern __m512i __cdecl _mm512_maskz_cvttsps_epu32(__mmask16, __m512); 
extern __m512i __cdecl _mm512_cvtts_roundps_epu32(__m512, const int);
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epu32(__m512i, __mmask16, __m512, const int);
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epu32(__mmask16, __m512, const int);


extern __m128i __cdecl _mm_cvttsps_epi64(__m128);
extern __m128i __cdecl _mm_mask_cvttsps_epi64(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_cvttsps_epi64(__mmask8, __m128);
extern __m256i __cdecl _mm256_cvttsps_epi64(__m128);
extern __m256i __cdecl _mm256_mask_cvttsps_epi64(__m256i, __mmask8, __m128);
extern __m256i __cdecl _mm256_maskz_cvttsps_epi64(__mmask8, __m128);
extern __m512i __cdecl _mm512_cvttsps_epi64(__m256); 
extern __m512i __cdecl _mm512_mask_cvttsps_epi64(__m512i, __mmask8, __m256); 
extern __m512i __cdecl _mm512_maskz_cvttsps_epi64(__mmask8, __m256); 
extern __m512i __cdecl _mm512_cvtts_roundps_epi64(__m256, const int);
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epi64(__m512i, __mmask8, __m256, const int);
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epi64(__mmask8, __m256, const int);


extern __m128i __cdecl _mm_cvttsps_epi32(__m128);
extern __m128i __cdecl _mm_mask_cvttsps_epi32(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_cvttsps_epi32(__mmask8, __m128);
extern __m256i __cdecl _mm256_cvttsps_epi32(__m256);
extern __m256i __cdecl _mm256_mask_cvttsps_epi32(__m256i, __mmask8, __m256);
extern __m256i __cdecl _mm256_maskz_cvttsps_epi32(__mmask8, __m256);
extern __m512i __cdecl _mm512_cvttsps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_cvttsps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_cvttsps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_cvtts_roundps_epi32(__m512, const int);
extern __m512i __cdecl _mm512_mask_cvtts_roundps_epi32(__m512i, __mmask16, __m512, const int);
extern __m512i __cdecl _mm512_maskz_cvtts_roundps_epi32(__mmask16, __m512, const int);


extern __m128i __cdecl _mm_cvttspd_epu64(__m128d);
extern __m128i __cdecl _mm_mask_cvttspd_epu64(__m128i, __mmask8, __m128d);
extern __m128i __cdecl _mm_maskz_cvttspd_epu64(__mmask8, __m128d);
extern __m256i __cdecl _mm256_cvttspd_epu64(__m256d);
extern __m256i __cdecl _mm256_mask_cvttspd_epu64(__m256i, __mmask8, __m256d);
extern __m256i __cdecl _mm256_maskz_cvttspd_epu64(__mmask8, __m256d);
extern __m512i __cdecl _mm512_cvttspd_epu64(__m512d); 
extern __m512i __cdecl _mm512_mask_cvttspd_epu64(__m512i, __mmask8, __m512d); 
extern __m512i __cdecl _mm512_maskz_cvttspd_epu64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtts_roundpd_epu64(__m512d, const int);
extern __m512i __cdecl _mm512_mask_cvtts_roundpd_epu64(__m512i, __mmask8, __m512d, const int);
extern __m512i __cdecl _mm512_maskz_cvtts_roundpd_epu64(__mmask8, __m512d, const int);


extern __m128i __cdecl _mm_cvttspd_epu32(__m128d);
extern __m128i __cdecl _mm_mask_cvttspd_epu32(__m128i, __mmask8, __m128d);
extern __m128i __cdecl _mm_maskz_cvttspd_epu32(__mmask8, __m128d);
extern __m128i __cdecl _mm256_cvttspd_epu32(__m256d);
extern __m128i __cdecl _mm256_mask_cvttspd_epu32(__m128i, __mmask8, __m256d);
extern __m128i __cdecl _mm256_maskz_cvttspd_epu32(__mmask8, __m256d);
extern __m256i __cdecl _mm512_cvttspd_epu32(__m512d); 
extern __m256i __cdecl _mm512_mask_cvttspd_epu32(__m256i, __mmask8, __m512d); 
extern __m256i __cdecl _mm512_maskz_cvttspd_epu32(__mmask8, __m512d); 
extern __m256i __cdecl _mm512_cvtts_roundpd_epu32(__m512d, const int);
extern __m256i __cdecl _mm512_mask_cvtts_roundpd_epu32(__m256i, __mmask8, __m512d, const int);
extern __m256i __cdecl _mm512_maskz_cvtts_roundpd_epu32(__mmask8, __m512d, const int);


extern __m128i __cdecl _mm_cvttspd_epi64(__m128d);
extern __m128i __cdecl _mm_mask_cvttspd_epi64(__m128i, __mmask8, __m128d);
extern __m128i __cdecl _mm_maskz_cvttspd_epi64(__mmask8, __m128d);
extern __m256i __cdecl _mm256_cvttspd_epi64(__m256d);
extern __m256i __cdecl _mm256_mask_cvttspd_epi64(__m256i, __mmask8, __m256d);
extern __m256i __cdecl _mm256_maskz_cvttspd_epi64(__mmask8, __m256d);
extern __m512i __cdecl _mm512_cvttspd_epi64(__m512d); 
extern __m512i __cdecl _mm512_mask_cvttspd_epi64(__m512i, __mmask8, __m512d);
extern __m512i __cdecl _mm512_maskz_cvttspd_epi64(__mmask8, __m512d);
extern __m512i __cdecl _mm512_cvtts_roundpd_epi64(__m512d, const int);
extern __m512i __cdecl _mm512_mask_cvtts_roundpd_epi64(__m512i, __mmask8, __m512d, const int);
extern __m512i __cdecl _mm512_maskz_cvtts_roundpd_epi64(__mmask8, __m512d, const int);


extern __m128i __cdecl _mm_cvttspd_epi32(__m128d);
extern __m128i __cdecl _mm_mask_cvttspd_epi32(__m128i, __mmask8, __m128d);
extern __m128i __cdecl _mm_maskz_cvttspd_epi32(__mmask8, __m128d);
extern __m128i __cdecl _mm256_cvttspd_epi32(__m256d);
extern __m128i __cdecl _mm256_mask_cvttspd_epi32(__m128i, __mmask8, __m256d);
extern __m128i __cdecl _mm256_maskz_cvttspd_epi32(__mmask8, __m256d); 
extern __m256i __cdecl _mm512_cvttspd_epi32(__m512d);
extern __m256i __cdecl _mm512_mask_cvttspd_epi32(__m256i, __mmask8, __m512d); 
extern __m256i __cdecl _mm512_maskz_cvttspd_epi32(__mmask8, __m512d);
extern __m256i __cdecl _mm512_cvtts_roundpd_epi32(__m512d, const int);
extern __m256i __cdecl _mm512_mask_cvtts_roundpd_epi32(__m256i, __mmask8, __m512d, const int);
extern __m256i __cdecl _mm512_maskz_cvtts_roundpd_epi32(__mmask8, __m512d, const int);


extern __m128i __cdecl _mm_ipcvtbf16_epi16(__m128bh);
extern __m128i __cdecl _mm_mask_ipcvtbf16_epi16(__m128i, __mmask8, __m128bh);
extern __m128i __cdecl _mm_maskz_ipcvtbf16_epi16(__mmask8, __m128bh);
extern __m256i __cdecl _mm256_ipcvtbf16_epi16(__m256bh);
extern __m256i __cdecl _mm256_mask_ipcvtbf16_epi16(__m256i, __mmask16, __m256bh);
extern __m256i __cdecl _mm256_maskz_ipcvtbf16_epi16(__mmask16, __m256bh);
extern __m512i __cdecl _mm512_ipcvtbf16_epi16(__m512bh);
extern __m512i __cdecl _mm512_mask_ipcvtbf16_epi16(__m512i, __mmask32, __m512bh);
extern __m512i __cdecl _mm512_maskz_ipcvtbf16_epi16(__mmask32, __m512bh);


extern __m128i __cdecl _mm_ipcvttbf16_epi16(__m128bh);
extern __m128i __cdecl _mm_mask_ipcvttbf16_epi16(__m128i, __mmask8, __m128bh);
extern __m128i __cdecl _mm_maskz_ipcvttbf16_epi16(__mmask8, __m128bh);
extern __m256i __cdecl _mm256_ipcvttbf16_epi16(__m256bh);
extern __m256i __cdecl _mm256_mask_ipcvttbf16_epi16(__m256i, __mmask16, __m256bh);
extern __m256i __cdecl _mm256_maskz_ipcvttbf16_epi16(__mmask16, __m256bh);
extern __m512i __cdecl _mm512_ipcvttbf16_epi16(__m512bh);
extern __m512i __cdecl _mm512_mask_ipcvttbf16_epi16(__m512i, __mmask32, __m512bh);
extern __m512i __cdecl _mm512_maskz_ipcvttbf16_epi16(__mmask32, __m512bh);


extern __m128i __cdecl _mm_ipcvtbf16_epu16(__m128bh);
extern __m128i __cdecl _mm_mask_ipcvtbf16_epu16(__m128i, __mmask8, __m128bh);
extern __m128i __cdecl _mm_maskz_ipcvtbf16_epu16(__mmask8, __m128bh);
extern __m256i __cdecl _mm256_ipcvtbf16_epu16(__m256bh);
extern __m256i __cdecl _mm256_mask_ipcvtbf16_epu16(__m256i, __mmask16, __m256bh);
extern __m256i __cdecl _mm256_maskz_ipcvtbf16_epu16(__mmask16, __m256bh);
extern __m512i __cdecl _mm512_ipcvtbf16_epu16(__m512bh);
extern __m512i __cdecl _mm512_mask_ipcvtbf16_epu16(__m512i, __mmask32, __m512bh);
extern __m512i __cdecl _mm512_maskz_ipcvtbf16_epu16(__mmask32, __m512bh);


extern __m128i __cdecl _mm_ipcvttbf16_epu16(__m128bh);
extern __m128i __cdecl _mm_mask_ipcvttbf16_epu16(__m128i, __mmask8, __m128bh);
extern __m128i __cdecl _mm_maskz_ipcvttbf16_epu16(__mmask8, __m128bh);
extern __m256i __cdecl _mm256_ipcvttbf16_epu16(__m256bh);
extern __m256i __cdecl _mm256_mask_ipcvttbf16_epu16(__m256i, __mmask16, __m256bh);
extern __m256i __cdecl _mm256_maskz_ipcvttbf16_epu16(__mmask16, __m256bh);
extern __m512i __cdecl _mm512_ipcvttbf16_epu16(__m512bh);
extern __m512i __cdecl _mm512_mask_ipcvttbf16_epu16(__m512i, __mmask32, __m512bh);
extern __m512i __cdecl _mm512_maskz_ipcvttbf16_epu16(__mmask32, __m512bh);


extern __m128i __cdecl _mm_ipcvtph_epi16(__m128h);
extern __m128i __cdecl _mm_mask_ipcvtph_epi16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_ipcvtph_epi16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_ipcvtph_epi16(__m256h);
extern __m256i __cdecl _mm256_mask_ipcvtph_epi16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_ipcvtph_epi16( __mmask16, __m256h);
extern __m512i __cdecl _mm512_ipcvtph_epi16(__m512h);
extern __m512i __cdecl _mm512_mask_ipcvtph_epi16(__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_ipcvtph_epi16( __mmask32, __m512h);
extern __m512i __cdecl _mm512_ipcvt_roundph_epi16(__m512h, const int);
extern __m512i __cdecl _mm512_mask_ipcvt_roundph_epi16(__m512i, __mmask32, __m512h, const int);
extern __m512i __cdecl _mm512_maskz_ipcvt_roundph_epi16(__mmask32, __m512h, const int);


extern __m128i __cdecl _mm_ipcvttph_epi16(__m128h);
extern __m128i __cdecl _mm_mask_ipcvttph_epi16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_ipcvttph_epi16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_ipcvttph_epi16(__m256h);
extern __m256i __cdecl _mm256_mask_ipcvttph_epi16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_ipcvttph_epi16( __mmask16, __m256h);
extern __m512i __cdecl _mm512_ipcvttph_epi16(__m512h);
extern __m512i __cdecl _mm512_mask_ipcvttph_epi16(__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_ipcvttph_epi16( __mmask32, __m512h);
extern __m512i __cdecl _mm512_ipcvtt_roundph_epi16(__m512h, const int);
extern __m512i __cdecl _mm512_mask_ipcvtt_roundph_epi16(__m512i, __mmask32, __m512h, const int);
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundph_epi16(__mmask32, __m512h, const int);


extern __m128i __cdecl _mm_ipcvtph_epu16(__m128h);
extern __m128i __cdecl _mm_mask_ipcvtph_epu16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_ipcvtph_epu16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_ipcvtph_epu16(__m256h);
extern __m256i __cdecl _mm256_mask_ipcvtph_epu16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_ipcvtph_epu16( __mmask16, __m256h);
extern __m512i __cdecl _mm512_ipcvtph_epu16(__m512h);
extern __m512i __cdecl _mm512_mask_ipcvtph_epu16(__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_ipcvtph_epu16( __mmask32, __m512h);
extern __m512i __cdecl _mm512_ipcvt_roundph_epu16(__m512h, const int);
extern __m512i __cdecl _mm512_mask_ipcvt_roundph_epu16(__m512i, __mmask32, __m512h, const int);
extern __m512i __cdecl _mm512_maskz_ipcvt_roundph_epu16(__mmask32, __m512h, const int);


extern __m128i __cdecl _mm_ipcvttph_epu16(__m128h);
extern __m128i __cdecl _mm_mask_ipcvttph_epu16(__m128i, __mmask8, __m128h);
extern __m128i __cdecl _mm_maskz_ipcvttph_epu16(__mmask8, __m128h);
extern __m256i __cdecl _mm256_ipcvttph_epu16(__m256h);
extern __m256i __cdecl _mm256_mask_ipcvttph_epu16(__m256i, __mmask16, __m256h);
extern __m256i __cdecl _mm256_maskz_ipcvttph_epu16( __mmask16, __m256h);
extern __m512i __cdecl _mm512_ipcvttph_epu16(__m512h);
extern __m512i __cdecl _mm512_mask_ipcvttph_epu16(__m512i, __mmask32, __m512h);
extern __m512i __cdecl _mm512_maskz_ipcvttph_epu16( __mmask32, __m512h);
extern __m512i __cdecl _mm512_ipcvtt_roundph_epu16(__m512h, const int);
extern __m512i __cdecl _mm512_mask_ipcvtt_roundph_epu16(__m512i, __mmask32, __m512h, const int);
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundph_epu16(__mmask32, __m512h, const int);


extern __m128i __cdecl _mm_ipcvtps_epi32(__m128);
extern __m128i __cdecl _mm_mask_ipcvtps_epi32(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_ipcvtps_epi32(__mmask8, __m128);
extern __m256i __cdecl _mm256_ipcvtps_epi32(__m256);
extern __m256i __cdecl _mm256_mask_ipcvtps_epi32(__m256i, __mmask8, __m256);
extern __m256i __cdecl _mm256_maskz_ipcvtps_epi32(__mmask8, __m256);
extern __m512i __cdecl _mm512_ipcvtps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_ipcvtps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_ipcvtps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_ipcvt_roundps_epi32(__m512, const int);
extern __m512i __cdecl _mm512_mask_ipcvt_roundps_epi32(__m512i, __mmask16, __m512, const int);
extern __m512i __cdecl _mm512_maskz_ipcvt_roundps_epi32(__mmask16, __m512, const int);


extern __m128i __cdecl _mm_ipcvttps_epi32(__m128);
extern __m128i __cdecl _mm_mask_ipcvttps_epi32(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_ipcvttps_epi32(__mmask8, __m128);
extern __m256i __cdecl _mm256_ipcvttps_epi32(__m256);
extern __m256i __cdecl _mm256_mask_ipcvttps_epi32(__m256i, __mmask8, __m256);
extern __m256i __cdecl _mm256_maskz_ipcvttps_epi32(__mmask8, __m256);
extern __m512i __cdecl _mm512_ipcvttps_epi32(__m512);
extern __m512i __cdecl _mm512_mask_ipcvttps_epi32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_ipcvttps_epi32(__mmask16, __m512);
extern __m512i __cdecl _mm512_ipcvtt_roundps_epi32(__m512, const int);
extern __m512i __cdecl _mm512_mask_ipcvtt_roundps_epi32(__m512i, __mmask16, __m512, const int);
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundps_epi32(__mmask16, __m512, const int);


extern __m128i __cdecl _mm_ipcvtps_epu32(__m128);
extern __m128i __cdecl _mm_mask_ipcvtps_epu32(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_ipcvtps_epu32(__mmask8, __m128);
extern __m256i __cdecl _mm256_ipcvtps_epu32(__m256);
extern __m256i __cdecl _mm256_mask_ipcvtps_epu32(__m256i, __mmask8, __m256);
extern __m256i __cdecl _mm256_maskz_ipcvtps_epu32(__mmask8, __m256);
extern __m512i __cdecl _mm512_ipcvtps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_ipcvtps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_ipcvtps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_ipcvt_roundps_epu32(__m512, const int);
extern __m512i __cdecl _mm512_mask_ipcvt_roundps_epu32(__m512i, __mmask16, __m512, const int);
extern __m512i __cdecl _mm512_maskz_ipcvt_roundps_epu32(__mmask16, __m512, const int);


extern __m128i __cdecl _mm_ipcvttps_epu32(__m128);
extern __m128i __cdecl _mm_mask_ipcvttps_epu32(__m128i, __mmask8, __m128);
extern __m128i __cdecl _mm_maskz_ipcvttps_epu32(__mmask8, __m128);
extern __m256i __cdecl _mm256_ipcvttps_epu32(__m256);
extern __m256i __cdecl _mm256_mask_ipcvttps_epu32(__m256i, __mmask8, __m256);
extern __m256i __cdecl _mm256_maskz_ipcvttps_epu32(__mmask8, __m256);
extern __m512i __cdecl _mm512_ipcvttps_epu32(__m512);
extern __m512i __cdecl _mm512_mask_ipcvttps_epu32(__m512i, __mmask16, __m512);
extern __m512i __cdecl _mm512_maskz_ipcvttps_epu32(__mmask16, __m512);
extern __m512i __cdecl _mm512_ipcvtt_roundps_epu32(__m512, const int);
extern __m512i __cdecl _mm512_mask_ipcvtt_roundps_epu32(__m512i, __mmask16, __m512, const int);
extern __m512i __cdecl _mm512_maskz_ipcvtt_roundps_epu32(__mmask16, __m512, const int);



extern __m128bh __cdecl _mm_minmax_pbh(__m128bh, __m128bh, const int);
extern __m128bh __cdecl _mm_mask_minmax_pbh(__m128bh, __mmask8, __m128bh, __m128bh, const int);
extern __m128bh __cdecl _mm_maskz_minmax_pbh(__mmask8, __m128bh, __m128bh, const int);
extern __m256bh __cdecl _mm256_minmax_pbh(__m256bh, __m256bh, const int);
extern __m256bh __cdecl _mm256_mask_minmax_pbh(__m256bh, __mmask16, __m256bh, __m256bh, const int);
extern __m256bh __cdecl _mm256_maskz_minmax_pbh(__mmask16, __m256bh, __m256bh, const int);
extern __m512bh __cdecl _mm512_minmax_pbh(__m512bh, __m512bh, const int);
extern __m512bh __cdecl _mm512_mask_minmax_pbh(__m512bh, __mmask32, __m512bh, __m512bh, const int);
extern __m512bh __cdecl _mm512_maskz_minmax_pbh(__mmask32, __m512bh, __m512bh, const int);


extern __m128d __cdecl _mm_minmax_pd(__m128d, __m128d, const int);
extern __m128d __cdecl _mm_mask_minmax_pd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d __cdecl _mm_maskz_minmax_pd(__mmask8, __m128d, __m128d, const int);
extern __m256d __cdecl _mm256_minmax_pd(__m256d, __m256d, const int);
extern __m256d __cdecl _mm256_mask_minmax_pd(__m256d, __mmask8, __m256d, __m256d, const int);
extern __m256d __cdecl _mm256_maskz_minmax_pd(__mmask8, __m256d, __m256d, const int);
extern __m512d __cdecl _mm512_minmax_pd(__m512d, __m512d, const int);
extern __m512d __cdecl _mm512_mask_minmax_pd(__m512d, __mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_maskz_minmax_pd(__mmask8, __m512d, __m512d, const int);
extern __m512d __cdecl _mm512_minmax_round_pd(__m512d, __m512d, const int, const int);
extern __m512d __cdecl _mm512_mask_minmax_round_pd(__m512d, __mmask8, __m512d, __m512d, const int, const int);
extern __m512d __cdecl _mm512_maskz_minmax_round_pd(__mmask8, __m512d, __m512d, const int, const int);


extern __m128 __cdecl _mm_minmax_ps(__m128, __m128, const int);
extern __m128 __cdecl _mm_mask_minmax_ps(__m128, __mmask8, __m128, __m128, const int);
extern __m128 __cdecl _mm_maskz_minmax_ps(__mmask8, __m128, __m128, const int);
extern __m256 __cdecl _mm256_minmax_ps(__m256, __m256, const int);
extern __m256 __cdecl _mm256_mask_minmax_ps(__m256, __mmask8, __m256, __m256, const int);
extern __m256 __cdecl _mm256_maskz_minmax_ps(__mmask8, __m256, __m256, const int);
extern __m512 __cdecl _mm512_minmax_ps(__m512, __m512, const int);
extern __m512 __cdecl _mm512_mask_minmax_ps(__m512, __mmask16, __m512, __m512, const int);
extern __m512 __cdecl _mm512_maskz_minmax_ps(__mmask16, __m512, __m512, const int);
extern __m512 __cdecl _mm512_minmax_round_ps(__m512, __m512, const int, const int);
extern __m512 __cdecl _mm512_mask_minmax_round_ps(__m512, __mmask16, __m512, __m512, const int, const int);
extern __m512 __cdecl _mm512_maskz_minmax_round_ps(__mmask16, __m512, __m512, const int, const int);


extern __m128h __cdecl _mm_minmax_ph(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_minmax_ph(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_minmax_ph(__mmask8, __m128h, __m128h, const int);
extern __m256h __cdecl _mm256_minmax_ph(__m256h, __m256h, const int);
extern __m256h __cdecl _mm256_mask_minmax_ph(__m256h, __mmask16, __m256h, __m256h, const int);
extern __m256h __cdecl _mm256_maskz_minmax_ph(__mmask16, __m256h, __m256h, const int);
extern __m512h __cdecl _mm512_minmax_ph(__m512h, __m512h, const int);
extern __m512h __cdecl _mm512_mask_minmax_ph(__m512h, __mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_maskz_minmax_ph(__mmask32, __m512h, __m512h, const int);
extern __m512h __cdecl _mm512_minmax_round_ph(__m512h, __m512h, const int, const int);
extern __m512h __cdecl _mm512_mask_minmax_round_ph(__m512h, __mmask32, __m512h, __m512h, const int, const int);
extern __m512h __cdecl _mm512_maskz_minmax_round_ph(__mmask32, __m512h, __m512h, const int, const int);


extern __m128d __cdecl _mm_minmax_sd(__m128d, __m128d, const int);
extern __m128d __cdecl _mm_mask_minmax_sd(__m128d, __mmask8, __m128d, __m128d, const int);
extern __m128d __cdecl _mm_maskz_minmax_sd(__mmask8, __m128d, __m128d, const int);
extern __m128d __cdecl _mm_minmax_round_sd(__m128d, __m128d, const int, const int);
extern __m128d __cdecl _mm_mask_minmax_round_sd(__m128d, __mmask8, __m128d, __m128d, const int, const int);
extern __m128d __cdecl _mm_maskz_minmax_round_sd(__mmask8, __m128d, __m128d, const int, const int);
extern __m128h __cdecl _mm_minmax_sh(__m128h, __m128h, const int);
extern __m128h __cdecl _mm_mask_minmax_sh(__m128h, __mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_maskz_minmax_sh(__mmask8, __m128h, __m128h, const int);
extern __m128h __cdecl _mm_minmax_round_sh(__m128h, __m128h, const int, const int);
extern __m128h __cdecl _mm_mask_minmax_round_sh(__m128h, __mmask8, __m128h, __m128h, const int, const int);
extern __m128h __cdecl _mm_maskz_minmax_round_sh(__mmask8, __m128h, __m128h, const int, const int);
extern __m128 __cdecl _mm_minmax_ss(__m128, __m128, const int);
extern __m128 __cdecl _mm_mask_minmax_ss(__m128, __mmask8, __m128, __m128, const int);
extern __m128 __cdecl _mm_maskz_minmax_ss(__mmask8, __m128, __m128, const int);
extern __m128 __cdecl _mm_minmax_round_ss(__m128, __m128, const int, const int);
extern __m128 __cdecl _mm_mask_minmax_round_ss(__m128, __mmask8, __m128, __m128, const int, const int);
extern __m128 __cdecl _mm_maskz_minmax_round_ss(__mmask8, __m128, __m128, const int, const int);



extern __m128i __cdecl _mm_move_epi32(__m128i);
extern __m128i __cdecl _mm_move_epi16(__m128i);



extern int __cdecl _mm_comx_sd(__m128d, __m128d, const int);
extern int __cdecl _mm_comx_round_sd(__m128d, __m128d, const int, const int);
extern int __cdecl _mm_comx_sh(__m128h, __m128h, const int);
extern int __cdecl _mm_comx_round_sh(__m128h, __m128h, const int, const int);
extern int __cdecl _mm_comx_ss(__m128, __m128, const int);
extern int __cdecl _mm_comx_round_ss(__m128, __m128, const int, const int);
extern int __cdecl _mm_ucomx_sd(__m128d, __m128d, const int);
extern int __cdecl _mm_ucomx_round_sd(__m128d, __m128d, const int, const int);
extern int __cdecl _mm_ucomx_sh(__m128h, __m128h, const int);
extern int __cdecl _mm_ucomx_round_sh(__m128h, __m128h, const int, const int);
extern int __cdecl _mm_ucomx_ss(__m128, __m128, const int);
extern int __cdecl _mm_ucomx_round_ss(__m128, __m128, const int, const int);












































}
#line 7189 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"


#line 7192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\zmmintrin.h"
#pragma external_header(pop)
#line 2539 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern "C" {
#line 2543 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"




extern __m128i __cdecl _mm_madd52hi_avx_epu64(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52hi_avx_epu64(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_madd52lo_avx_epu64(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_madd52lo_avx_epu64(__m256i, __m256i, __m256i);


extern __m128 __cdecl _mm_bcstnebf16_ps(const __bfloat16 *);
extern __m256 __cdecl _mm256_bcstnebf16_ps(const __bfloat16 *);
extern __m128 __cdecl _mm_bcstnesh_ps(const void *);
extern __m256 __cdecl _mm256_bcstnesh_ps(const void *);
extern __m128 __cdecl _mm_cvtneebf16_ps(const __m128bh *);
extern __m256 __cdecl _mm256_cvtneebf16_ps(const __m256bh *);
extern __m128 __cdecl _mm_cvtneeph_ps(const __m128h *);
extern __m256 __cdecl _mm256_cvtneeph_ps(const __m256h *);
extern __m128 __cdecl _mm_cvtneobf16_ps(const __m128bh *);
extern __m256 __cdecl _mm256_cvtneobf16_ps(const __m256bh *);
extern __m128 __cdecl _mm_cvtneoph_ps(const __m128h *);
extern __m256 __cdecl _mm256_cvtneoph_ps(const __m256h *);
extern __m128bh __cdecl _mm_cvtneps_avx_pbh(__m128);
extern __m128bh __cdecl _mm256_cvtneps_avx_pbh(__m256);


extern __m128i __cdecl _mm_dpbssd_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbssd_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbssds_epi32( __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbssds_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbsud_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbsud_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbsuds_epi32( __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbsuds_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbuud_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbuud_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpbuuds_epi32( __m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpbuuds_epi32(__m256i, __m256i, __m256i);


extern void __cdecl _aadd_i32(int*, int);
extern void __cdecl _aand_i32(int*, int);
extern void __cdecl _aor_i32(int*, int);
extern void __cdecl _axor_i32(int*, int);

extern void __cdecl _aadd_i64(__int64*, __int64);
extern void __cdecl _aand_i64(__int64*, __int64);
extern void __cdecl _aor_i64(__int64*, __int64);
extern void __cdecl _axor_i64(__int64*, __int64);
#line 2593 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"




extern float  __cdecl __rsqrt14_ss(float);
extern double __cdecl __rsqrt14_sd(double);
extern float  __cdecl __rsqrt_ss(float);
extern float  __cdecl __sqrt_ss(float);
extern double __cdecl __sqrt_sd(double);
extern float  __cdecl __max_ss(float, float);
extern double __cdecl __max_sd(double, double);
extern float  __cdecl __min_ss(float, float);
extern double __cdecl __min_sd(double, double);




typedef enum {
  _CMPCCX_O,   
  _CMPCCX_NO,  
  _CMPCCX_B,   
  _CMPCCX_NB,  
  _CMPCCX_Z,   
  _CMPCCX_NZ,  
  _CMPCCX_BE,  
  _CMPCCX_NBE, 
  _CMPCCX_S,   
  _CMPCCX_NS,  
  _CMPCCX_P,   
  _CMPCCX_NP,  
  _CMPCCX_L,   
  _CMPCCX_NL,  
  _CMPCCX_LE,  
  _CMPCCX_NLE, 
} _CMPCCX_ENUM;

extern int __cdecl _cmpccxadd_epi32(void *, int, int, const int);
extern __int64 __cdecl _cmpccxadd_epi64(void *, __int64, __int64, const int);

#line 2633 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern double __round_sd(double, int);
extern float __round_ss(float, int);

extern __m128i __cdecl _mm_dpwsud_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwsud_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwsuds_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwsuds_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwusd_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwusd_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwusds_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwusds_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwuud_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwuud_epi32(__m256i, __m256i, __m256i);
extern __m128i __cdecl _mm_dpwuuds_epi32(__m128i, __m128i, __m128i);
extern __m256i __cdecl _mm256_dpwuuds_epi32(__m256i, __m256i, __m256i);



extern long long __cdecl _pbndkb(const void*, void*);
#line 2655 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


extern __m256i __cdecl _mm256_sha512msg1_epi64(__m256i, __m128i);
extern __m256i __cdecl _mm256_sha512msg2_epi64(__m256i, __m256i);
extern __m256i __cdecl _mm256_sha512rnds2_epi64(__m256i, __m256i, __m128i);


extern __m128i __cdecl _mm_sm3msg1_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_sm3msg2_epi32(__m128i, __m128i, __m128i);
extern __m128i __cdecl _mm_sm3rnds2_epi32(__m128i, __m128i, __m128i, const int);


extern __m128i __cdecl _mm_sm4key4_epi32(__m128i, __m128i);
extern __m256i __cdecl _mm256_sm4key4_epi32(__m256i, __m256i);
extern __m128i __cdecl _mm_sm4rnds4_epi32(__m128i, __m128i);
extern __m256i __cdecl _mm256_sm4rnds4_epi32(__m256i, __m256i);


extern unsigned __int64 __cdecl _urdmsr(unsigned __int64);
extern void __cdecl _uwrmsr(unsigned __int64, unsigned __int64);
#line 2676 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"

__m128i __iso_volatile_ia_load128(const volatile __m128i*);
__m256i __iso_volatile_ia_load256(const volatile __m256i*);
__m512i __iso_volatile_ia_load512(const volatile __m512i*);
void __iso_volatile_ia_store128(volatile __m128i*, __m128i);
void __iso_volatile_ia_store256(volatile __m256i*, __m256i);
void __iso_volatile_ia_store512(volatile __m512i*, __m512i);
__m128i __iso_volatile_ia_nt_load128(const volatile __m128i*);
__m256i __iso_volatile_ia_nt_load256(const volatile __m256i*);
__m512i __iso_volatile_ia_nt_load512(const volatile __m512i*);
void __iso_volatile_ia_nt_store128(volatile __m128i*, __m128i);
void __iso_volatile_ia_nt_store256(volatile __m256i*, __m256i);
void __iso_volatile_ia_nt_store512(volatile __m512i*, __m512i);



extern void _m_prefetchrs(const void *);


extern char  __cdecl _movrs_i8(const void *);
extern short __cdecl _movrs_i16(const void *);
extern int   __cdecl _movrs_i32(const void *);
extern long long __cdecl _movrs_i64(const void *);
#line 2700 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"


} 
#line 2704 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"

#line 2706 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
#line 2707 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
#line 2708 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\immintrin.h"
#pragma external_header(pop)
#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
        #pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"































#pragma once



#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"



#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"







#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"


extern "C" { 
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb(void);
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);

void __lwpval64(unsigned __int64, unsigned int, unsigned int);
unsigned char __lwpins64(unsigned __int64, unsigned int, unsigned int);
#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);

unsigned __int64 _bextr_u64(unsigned __int64, unsigned int, unsigned int);
unsigned __int64 _andn_u64(unsigned __int64, unsigned __int64);
unsigned __int64 _tzcnt_u64(unsigned __int64);
unsigned __int64 _lzcnt_u64(unsigned __int64);
unsigned __int64 _blsr_u64(unsigned __int64);
unsigned __int64 _blsmsk_u64(unsigned __int64);
unsigned __int64 _blsi_u64(unsigned __int64);
#line 295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);

unsigned __int64 _bextri_u64(unsigned __int64, unsigned int);
unsigned __int64 _blcfill_u64(unsigned __int64);
unsigned __int64 _blsfill_u64(unsigned __int64);
unsigned __int64 _blcs_u64(unsigned __int64);
unsigned __int64 _tzmsk_u64(unsigned __int64);
unsigned __int64 _blcic_u64(unsigned __int64);
unsigned __int64 _blsic_u64(unsigned __int64);
unsigned __int64 _t1mskc_u64(unsigned __int64);
unsigned __int64 _blcmsk_u64(unsigned __int64);
unsigned __int64 _blci_u64(unsigned __int64);
#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"

void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);

void _mm_clzero(void const *);
unsigned __int64 _rdpru(unsigned int);
  



















#line 346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"


typedef struct rmp_entry {
    unsigned __int64 guest_pa;
    unsigned __int8  assigned;
    unsigned __int8  page_size : 1;
    unsigned __int8  rmp_2mb_region_status : 1;
    unsigned __int8  reserved1 : 6;
    unsigned __int8  immutable;
    unsigned __int8  reserved2;
    unsigned __int32 asid;
} rmp_entry;

typedef struct rmpquery_result {
    unsigned __int8  target_perm_mask;
    unsigned __int8  vmsa;
    unsigned __int8  page_size;
} rmpquery_result;

unsigned int __rmpupdate(unsigned __int64, rmp_entry*);
unsigned int __pvalidate(unsigned __int64, unsigned __int8, unsigned __int8, unsigned __int8*);
unsigned int __psmash(unsigned __int64);
unsigned int __rmpadjust(unsigned __int64, unsigned __int8, unsigned __int8, unsigned __int8);
unsigned int __rmpquery(unsigned __int64, unsigned __int8, rmpquery_result*);
unsigned int __rmpread(unsigned __int64, rmp_entry*);

#line 373 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
#line 374 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"



void __svm_invlpgb(void*, int);
void __svm_tlbsync(void);



}; 
#line 384 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"

#line 386 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
#line 387 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
#line 388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\ammintrin.h"
#pragma external_header(pop)
#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
    #line 38 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"

    

#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"

    


#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"

    


#line 52 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"


extern "C" {
#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"




#pragma warning(push)
#pragma warning(disable: 28251)


void * _AddressOfReturnAddress(void);










int _cvt_dtoi_fast (double);
int _cvt_dtoi_sat (double);
int _cvt_dtoi_sent (double);
long long _cvt_dtoll_fast (double);
long long _cvt_dtoll_sat (double);
long long _cvt_dtoll_sent (double);
unsigned _cvt_dtoui_fast (double);
unsigned _cvt_dtoui_sat (double);
unsigned _cvt_dtoui_sent (double);
unsigned long long _cvt_dtoull_fast (double);
unsigned long long _cvt_dtoull_sat (double);
unsigned long long _cvt_dtoull_sent (double);
int _cvt_ftoi_fast (float);
int _cvt_ftoi_sat (float);
int _cvt_ftoi_sent (float);
long long _cvt_ftoll_fast (float);
long long _cvt_ftoll_sat (float);
long long _cvt_ftoll_sent (float);
unsigned _cvt_ftoui_fast (float);
unsigned _cvt_ftoui_sat (float);
unsigned _cvt_ftoui_sent (float);
unsigned long long _cvt_ftoull_fast (float);
unsigned long long _cvt_ftoull_sat (float);
unsigned long long _cvt_ftoull_sent (float);





long _interlockedadd(long volatile * _Addend, long _Value);

__int64 _interlockedadd64(__int64 volatile * _Addend, __int64 _Value);







short _InterlockedAnd16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedAnd64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedAnd8_np(char volatile * _Value, char _Mask);
long _InterlockedAnd_np(long volatile * _Value, long _Mask);
unsigned char _interlockedbittestandset(long volatile *, long);



unsigned char _InterlockedCompareExchange128_np(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);
short _InterlockedCompareExchange16_np(short volatile * _Destination, short _Exchange, short _Comparand);
__int64 _InterlockedCompareExchange64_np(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);
void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);


void * _InterlockedCompareExchangePointer_np(void * volatile * _Destination, void * _Exchange, void * _Comparand);

long _InterlockedCompareExchange_np(long volatile * _Destination, long _Exchange, long _Comparand);









void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);











short _InterlockedOr16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedOr64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedOr8_np(char volatile * _Value, char _Mask);
long _InterlockedOr_np(long volatile * _Value, long _Mask);
short _InterlockedXor16_np(short volatile * _Value, short _Mask);
__int64 _InterlockedXor64_np(__int64 volatile * _Value, __int64 _Mask);
char _InterlockedXor8_np(char volatile * _Value, char _Mask);
long _InterlockedXor_np(long volatile * _Value, long _Mask);








void _ReadBarrier(void);






void * _ReturnAddress(void);

void _WriteBarrier(void);









void __addgsbyte(unsigned long, unsigned char);
void __addgsdword(unsigned long, unsigned long);
void __addgsqword(unsigned long, unsigned __int64);
void __addgsword(unsigned long, unsigned short);




void __clts(void);
void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);
void __faststorefence(void);
unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);



void __incgsbyte(unsigned long);
void __incgsdword(unsigned long);
void __incgsqword(unsigned long);
void __incgsword(unsigned long);




unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);
void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);
void __movsq(unsigned long long *, unsigned long long const *, size_t);
void __movsw(unsigned short *, unsigned short const *, size_t);
__int64 __mulh(__int64, __int64);
void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);
unsigned __int64 __readcr0(void);

unsigned __int64 __readcr2(void);

unsigned __int64 __readcr3(void);

unsigned __int64 __readcr4(void);

unsigned __int64 __readcr8(void);

unsigned __int64 __readdr(unsigned int);

unsigned __int64 __readeflags(void);





unsigned char __readgsbyte(unsigned long);
unsigned long __readgsdword(unsigned long);
unsigned __int64 __readgsqword(unsigned long);
unsigned short __readgsword(unsigned long);
unsigned __int64 __readmsr(unsigned long);
void __readmsrlist(unsigned __int64, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __readpmc(unsigned long);




double __rint(double);
float __rintf(float);
double __nearbyint(double);
float __nearbyintf(float);
unsigned long __segmentlimit(unsigned long);

void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);
void __stosq(unsigned __int64 *, unsigned __int64, size_t);
void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);
void __vmx_off(void);
unsigned char __vmx_on(unsigned __int64 *);
unsigned char __vmx_vmclear(unsigned __int64 *);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned __int64 *);
void __vmx_vmptrst(unsigned __int64 *);
unsigned char __vmx_vmread(size_t, size_t *);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);
void __wbinvd(void);


void __writecr0(unsigned __int64);

void __writecr2(unsigned __int64);

void __writecr3(unsigned __int64);

void __writecr4(unsigned __int64);

void __writecr8(unsigned __int64);

void __writedr(unsigned int, unsigned __int64);

void __writeeflags(unsigned __int64);





void __writegsbyte(unsigned long, unsigned char);
void __writegsdword(unsigned long, unsigned long);
void __writegsqword(unsigned long, unsigned __int64);
void __writegsword(unsigned long, unsigned short);
void __writemsr(unsigned long, unsigned __int64);
void __writemsrlist(unsigned __int64, unsigned __int64 *, unsigned __int64 *);
void __writemsrns(unsigned long, unsigned __int64);




unsigned char _bittest64(__int64 const *, __int64);
unsigned char _bittestandcomplement(long *, long);
unsigned char _bittestandcomplement64(__int64 *, __int64);
unsigned char _bittestandreset(long *, long);
unsigned char _bittestandreset64(__int64 *, __int64);
unsigned char _bittestandset(long *, long);
unsigned char _bittestandset64(__int64 *, __int64);
[[nodiscard]]   unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
[[nodiscard]]   unsigned long __cdecl _byteswap_ulong(  unsigned long);
[[nodiscard]]   unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);
unsigned char _interlockedbittestandreset64(__int64 volatile *, __int64);






unsigned char _interlockedbittestandset64(__int64 volatile *, __int64);













[[nodiscard]]   unsigned long __cdecl _lrotl(  unsigned long,   int);
[[nodiscard]]   unsigned long __cdecl _lrotr(  unsigned long,   int);




























































void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);



































__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);



__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);

__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);

__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
void _mm_clzero(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);
unsigned __int64 _mm_crc32_u64(unsigned __int64, unsigned __int64);
unsigned int _mm_crc32_u8(unsigned int, unsigned char);


__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);

__m128 _mm_cvtpd_ps(__m128d);

__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);
__int64 _mm_cvtsd_si64(__m128d);
__int64 _mm_cvtsd_si64x(__m128d);
__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);
__int64 _mm_cvtsi128_si64(__m128i);
__int64 _mm_cvtsi128_si64x(__m128i);
__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);
__m128d _mm_cvtsi64_sd(__m128d, __int64);
__m128i _mm_cvtsi64_si128(__int64);
__m128 _mm_cvtsi64_ss(__m128, __int64);
__m128d _mm_cvtsi64x_sd(__m128d, __int64);
__m128i _mm_cvtsi64x_si128(__int64);
__m128 _mm_cvtsi64x_ss(__m128, __int64);
__m128d _mm_cvtss_sd(__m128d, __m128);
__int64 _mm_cvtss_si64(__m128);
__int64 _mm_cvtss_si64x(__m128);

int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);

__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);
__int64 _mm_cvttsd_si64(__m128d);
__int64 _mm_cvttsd_si64x(__m128d);
__int64 _mm_cvttss_si64(__m128);
__int64 _mm_cvttss_si64x(__m128);
__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);
__int64 _mm_extract_epi64(__m128i, int);
int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);


__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);

__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);


__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);

__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);
__m128i _mm_insert_epi64(__m128i, __int64, int);
__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);

void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);


__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);

__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);

__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
int _mm_popcnt_u32(unsigned int);
__int64 _mm_popcnt_u64(unsigned __int64);
void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);

__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);



__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);

__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);



__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);

__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);



__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);

void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);

__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);



__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);


#line 888 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
__m128i _mm_stream_load_si128(const __m128i *);
#line 890 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
void _mm_stream_pd(double *, __m128d);

void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);
void _mm_stream_si64x(__int64 *, __int64);
void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);

__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);
__int64 _mul128(__int64 _Multiplier, __int64 _Multiplicand, __int64 * _HighProduct);
int __cdecl _setjmp(jmp_buf);
int __cdecl _setjmpex(jmp_buf);
void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char _add_overflow_i8(unsigned char, signed char, signed char, signed char *);
unsigned char _add_overflow_i16(unsigned char, signed short, signed short, signed short *);
unsigned char _add_overflow_i32(unsigned char, signed int, signed int, signed int *);
unsigned char _add_overflow_i64(unsigned char, signed __int64, signed __int64, signed __int64 *);
unsigned char _sub_overflow_i8(unsigned char, signed char, signed char, signed char *);
unsigned char _sub_overflow_i16(unsigned char, signed short, signed short, signed short *);
unsigned char _sub_overflow_i32(unsigned char, signed int, signed int, signed int *);
unsigned char _sub_overflow_i64(unsigned char, signed __int64, signed __int64, signed __int64 *);
unsigned char _mul_overflow_i16(signed short, signed short, signed short *);
unsigned char _mul_overflow_i32(signed int, signed int, signed int *);
unsigned char _mul_overflow_i64(signed __int64, signed __int64, signed __int64 *);
unsigned char _mul_full_overflow_i8(signed char, signed char, signed short *);
unsigned char _mul_full_overflow_i16(signed short, signed short, signed short *, signed short *);
unsigned char _mul_full_overflow_i32(signed int, signed int, signed int *, signed int *);
unsigned char _mul_full_overflow_i64(signed __int64, signed __int64, signed __int64 *, signed __int64 *);
unsigned char _mul_full_overflow_u8(unsigned char, unsigned char, unsigned short *);
unsigned char _mul_full_overflow_u16(unsigned short, unsigned short, unsigned short *, unsigned short *);
unsigned char _mul_full_overflow_u32(unsigned int, unsigned int, unsigned int *, unsigned int *);
unsigned char _mul_full_overflow_u64(unsigned __int64, unsigned __int64, unsigned __int64 *, unsigned __int64 *);
void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);
unsigned __int64 _rdpru(unsigned int);





#line 983 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
unsigned int __rmpupdate(unsigned __int64, rmp_entry*);
unsigned int __psmash(unsigned __int64);
unsigned int __rmpadjust(unsigned __int64, unsigned __int8, unsigned __int8, unsigned __int8);
unsigned int __pvalidate(unsigned __int64, unsigned __int8, unsigned __int8, unsigned __int8*);
unsigned int __rmpquery(unsigned __int64, unsigned __int8, rmpquery_result*);
unsigned int __rmpread(unsigned __int64, rmp_entry*);
#line 990 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
void __svm_invlpgb(void*, int);
void __svm_tlbsync(void);
void * _AddressOfNextInstruction(void);
unsigned char __is_unorderedf(float, float);
unsigned char __is_unordered(double, double);
unsigned char __is_unorderedl(long double, long double);
unsigned char __is_nanf(float);
unsigned char __is_nan(double);
unsigned char __is_nanl(long double);
unsigned char __is_normalf(float);
unsigned char __is_normal(double);
unsigned char __is_normall(long double);
unsigned char __is_finitef(float);
unsigned char __is_finite(double);
unsigned char __is_finitel(long double);
unsigned char __is_infinityf(float);
unsigned char __is_infinity(double);
unsigned char __is_infinityl(long double);
unsigned char __is_subnormalf(float);
unsigned char __is_subnormal(double);
unsigned char __is_subnormall(long double);
float __fminf(float, float);
double __fmin(double, double);
long double __fminl(long double, long double);
float __fmaxf(float, float);
double __fmax(double, double);
long double __fmaxl(long double, long double);
signed char _sat_add_i8(signed char, signed char);
signed short _sat_add_i16(signed short, signed short);
signed int _sat_add_i32(signed int, signed int);
signed __int64 _sat_add_i64(signed __int64, signed __int64);
unsigned char _sat_add_u8(unsigned char, unsigned char);
unsigned short _sat_add_u16(unsigned short, unsigned short);
unsigned int _sat_add_u32(unsigned int, unsigned int);
unsigned __int64 _sat_add_u64(unsigned __int64, unsigned __int64);
signed char _sat_sub_i8(signed char, signed char);
signed short _sat_sub_i16(signed short, signed short);
signed int _sat_sub_i32(signed int, signed int);
signed __int64 _sat_sub_i64(signed __int64, signed __int64);
unsigned char _sat_sub_u8(unsigned char, unsigned char);
unsigned short _sat_sub_u16(unsigned short, unsigned short);
unsigned int _sat_sub_u32(unsigned int, unsigned int);
unsigned __int64 _sat_sub_u64(unsigned __int64, unsigned __int64);
long _InterlockedNand(long volatile *, long);



char _InterlockedNand8(char volatile *, char);



short _InterlockedNand16(short volatile *, short);



__int64 _InterlockedNand64(__int64 volatile *, __int64);



long _InterlockedMax(long volatile *, long);



char _InterlockedMax8(char volatile *, char);



short _InterlockedMax16(short volatile *, short);



__int64 _InterlockedMax64(__int64 volatile *, __int64);



long _InterlockedMin(long volatile *, long);



char _InterlockedMin8(char volatile *, char);



short _InterlockedMin16(short volatile *, short);



__int64 _InterlockedMin64(__int64 volatile *, __int64);



unsigned long _InterlockedUMax(unsigned long volatile *, unsigned long);



unsigned char _InterlockedUMax8(unsigned char volatile *, unsigned char);



unsigned short _InterlockedUMax16(unsigned short volatile *, unsigned short);



unsigned __int64 _InterlockedUMax64(unsigned __int64 volatile *, unsigned __int64);



unsigned long _InterlockedUMin(unsigned long volatile *, unsigned long);



unsigned char _InterlockedUMin8(unsigned char volatile *, unsigned char);



unsigned short _InterlockedUMin16(unsigned short volatile *, unsigned short);



unsigned __int64 _InterlockedUMin64(unsigned __int64 volatile *, unsigned __int64);




#pragma warning(pop) 



    





#line 1125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"

#line 1127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"


}
#line 1131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
#pragma warning(pop) 
#line 1133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"

#line 1135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\intrin.h"
#pragma external_header(pop)
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"


#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
          int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

    __declspec(dllimport) int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    
    
    extern int _Avx2WmemEnabled;
    __declspec(selectany) int _Avx2WmemEnabledWeakValue = 0;
    

#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
    #pragma comment(linker, "/alternatename:_Avx2WmemEnabled=_Avx2WmemEnabledWeakValue")
    #line 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
    #line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
    #line 217 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        size_t __count = 0;

    
    








































#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

        unsigned long __index = 0;
        wchar_t const* __s = _S;

    
        if (_Avx2WmemEnabled && _N >= 16)
        {
            __m256i __v2 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128(_C));

            do
            {
                __m256i __v1 = _mm256_loadu_si256((__m256i const*)__s);
                __v1 = _mm256_cmpeq_epi16(__v1, __v2);
                unsigned int __mask = (unsigned int)_mm256_movemask_epi8(__v1);
                if (__mask != 0)
                {
                    _BitScanForward(&__index, __mask);
                    __index >>= 1;
                    return (wchar_t const*)&_S[__count + __index];
                }
                __count += 16;
                __s += 16;
            } while (__count + 16 <= _N);
        }
    #line 294 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

        if (__count + 4 <= _N)
        {
            __m128i __v2 = _mm_set1_epi16((short)_C);

            while (__count + 8 <= _N)
            {
                __m128i __v1 = _mm_loadu_si128((__m128i const*)__s);
                __v1 = _mm_cmpeq_epi16(__v1, __v2);
                unsigned short __mask = (unsigned short)_mm_movemask_epi8(__v1);
                if (__mask != 0)
                {
                    _BitScanForward(&__index, __mask);
                    __index >>= 1;
                    return (wchar_t const*)&_S[__count + __index];
                }
                __count += 8;
                __s += 8;
            }

            if (__count + 4 <= _N)
            {
                __m128i __v1 = _mm_loadl_epi64((__m128i const*)(__s));
                __v1 = _mm_cmpeq_epi16(__v1, __v2);
                unsigned char __mask = (unsigned char)_mm_movemask_epi8(__v1);
                if (__mask != 0)
                {
                    _BitScanForward(&__index, __mask);
                    __index >>= 1;
                    return (wchar_t const*)&_S[__count + __index];
                }

                __count += 4;
            }
        }

    #line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
    #line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

        for (; __count < _N; ++__count)
        {
            if (_S[__count] == _C)
            {
                return (wchar_t const*)&_S[__count];
            }
        }

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        size_t __count = 0;

    
    








































#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

        unsigned long __index = 0;
        wchar_t const* __s1 = _S1;
        wchar_t const* __s2 = _S2;

    
        if (_Avx2WmemEnabled)
        {
            while (__count + 16 <= _N)
            {
                __m256i __v1 = _mm256_loadu_si256((__m256i const*)__s1);
                __m256i __v2 = _mm256_loadu_si256((__m256i const*)__s2);
                __v1 = _mm256_cmpeq_epi16(__v1, __v2);
                unsigned int __mask = (unsigned int)_mm256_movemask_epi8(__v1);
                if (__mask != 0xffffffff)
                {
                    _BitScanForward(&__index, ~__mask);
                    __index >>= 1;
                    return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
                }
                __count += 16;
                __s1 += 16;
                __s2 += 16;
            }
        }
    #line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

        while (__count + 8 <= _N)
        {
            __m128i __v1 = _mm_loadu_si128((__m128i const*)__s1);
            __m128i __v2 = _mm_loadu_si128((__m128i const*)__s2);
            __v1 = _mm_cmpeq_epi16(__v1, __v2);
            unsigned short __mask = (unsigned short)_mm_movemask_epi8(__v1);
            if (__mask != 0xffff)
            {
                _BitScanForward(&__index, (unsigned long)~__mask);
                __index >>= 1;
                return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
            }
            __count += 8;
            __s1 += 8;
            __s2 += 8;
        }

    















#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
        if (__count + 4 <= _N)
        {
            unsigned __int64 __v1 = *(unsigned __int64*)__s1;
            unsigned __int64 __v2 = *(unsigned __int64*)__s2;
            if (__v1 != __v2)
            {
                _BitScanForward64(&__index, (__v1 ^ __v2));
                __index >>= 4;
                return _S1[__count + __index] < _S2[__count + __index] ? -1 : 1;
            }

            __count += 4;
        }
    #line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
    #line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
    #line 472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

        for (; __count < _N; ++__count)
        {
            if (_S1[__count] != _S2[__count])
            {
                return _S1[__count] < _S2[__count] ? -1 : 1;
            }
        }

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"

#line 539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 545 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\wchar.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cwchar"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )





using _Mbstatet = mbstate_t;


 namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: mbstate_t;
 using :: size_t;
 using :: tm;
 using :: wint_t;

 using :: btowc;
 using :: fgetwc;
 using :: fgetws;
 using :: fputwc;
 using :: fputws;
 using :: fwide;
 using :: fwprintf;
 using :: fwscanf;
 using :: getwc;
 using :: getwchar;
 using :: mbrlen;
 using :: mbrtowc;
 using :: mbsrtowcs;
 using :: mbsinit;
 using :: putwc;
 using :: putwchar;
 using :: swprintf;
 using :: swscanf;
 using :: ungetwc;
 using :: vfwprintf;
 using :: vswprintf;
 using :: vwprintf;
 using :: wcrtomb;
 using :: wprintf;
 using :: wscanf;
 using :: wcsrtombs;
 using :: wcstol;
 using :: wcscat;
 using :: wcschr;
 using :: wcscmp;
 using :: wcscoll;
 using :: wcscpy;
 using :: wcscspn;
 using :: wcslen;
 using :: wcsncat;
 using :: wcsncmp;
 using :: wcsncpy;
 using :: wcspbrk;
 using :: wcsrchr;
 using :: wcsspn;
 using :: wcstod;
 using :: wcstoul;
 using :: wcsstr;
 using :: wcstok;
 using :: wcsxfrm;
 using :: wctob;
 using :: wmemchr;
 using :: wmemcmp;
 using :: wmemcpy;
 using :: wmemmove;
 using :: wmemset;
 using :: wcsftime;

 using :: vfwscanf;
 using :: vswscanf;
 using :: vwscanf;
 using :: wcstof;
 using :: wcstold;
 using :: wcstoll;
 using :: wcstoull;

#pragma warning(pop)
} 



#pragma warning(pop)
#pragma pack(pop)

#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cwchar"
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cwchar"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"




#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {

 enum  float_denorm_style {
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};

 enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};

struct _Num_base { 
    __pragma(warning(push)) __pragma(warning(disable : 4996))
     static constexpr float_denorm_style has_denorm = denorm_absent;
     static constexpr bool has_denorm_loss          = false;
    __pragma(warning(pop))

    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};

 template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {}; 

struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};

struct _Num_float_base : _Num_base { 
    __pragma(warning(push)) __pragma(warning(disable : 4996))
     static constexpr float_denorm_style has_denorm = denorm_present;
    __pragma(warning(pop))

    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2;
};

template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept {
        return false;
    }

    [[nodiscard]] static constexpr bool(max)() noexcept {
        return true;
    }

    [[nodiscard]] static constexpr bool lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr bool epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};

template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr signed char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr signed char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr signed char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char(max)() noexcept {
        return 0xff;
    }

    [[nodiscard]] static constexpr unsigned char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};















































template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr char16_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr char32_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr wchar_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept {
        return (-32768);
    }

    [[nodiscard]] static constexpr short(max)() noexcept {
        return 32767;
    }

    [[nodiscard]] static constexpr short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept {
        return (-2147483647 - 1);
    }

    [[nodiscard]] static constexpr int(max)() noexcept {
        return 2147483647;
    }

    [[nodiscard]] static constexpr int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept {
        return (-2147483647L - 1);
    }

    [[nodiscard]] static constexpr long(max)() noexcept {
        return 2147483647L;
    }

    [[nodiscard]] static constexpr long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept {
        return (-9223372036854775807i64 - 1);
    }

    [[nodiscard]] static constexpr long long(max)() noexcept {
        return 9223372036854775807i64;
    }

    [[nodiscard]] static constexpr long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};


template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr unsigned short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 717 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"

template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr unsigned int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long(max)() noexcept {
        return 0xffffffffUL;
    }

    [[nodiscard]] static constexpr unsigned long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long(max)() noexcept {
        return 0xffffffffffffffffui64;
    }

    [[nodiscard]] static constexpr unsigned long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};

template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept {
        return 1.175494351e-38F;
    }

    [[nodiscard]] static constexpr float(max)() noexcept {
        return 3.402823466e+38F;
    }

    [[nodiscard]] static constexpr float lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr float epsilon() noexcept {
        return 1.192092896e-07F;
    }

    [[nodiscard]] static constexpr float round_error() noexcept {
        return 0.5F;
    }

    [[nodiscard]] static constexpr float denorm_min() noexcept {
        return 1.401298464e-45F;
    }

    
    [[nodiscard]] static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    [[nodiscard]] static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    [[nodiscard]] static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }
    

    static constexpr int digits         = 24;
    static constexpr int digits10       = 6;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent   = (-125);
    static constexpr int min_exponent10 = (-37);
};

template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr double round_error() noexcept {
        return 0.5;
    }

    [[nodiscard]] static constexpr double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    
    [[nodiscard]] static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }
    

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};

template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr long double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr long double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr long double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    [[nodiscard]] static constexpr long double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    
    [[nodiscard]] static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }
    

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 2 + 53 * 301L / 1000;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};

} 


#pragma warning(pop)
#pragma pack(pop)
#line 1007 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"
#line 1008 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\limits"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"







#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



















#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new_debug.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )
#pragma warning(disable: 4985) 


extern "C++" {

#pragma pack(push, 8)













    namespace std
    {
         struct nothrow_t {
            explicit nothrow_t() = default;
        };

         extern nothrow_t const nothrow;
    }
#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"

 [[nodiscard]]     __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

 [[nodiscard]]       __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

 [[nodiscard]]     __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

 [[nodiscard]]       __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

 void __cdecl operator delete(
    void* _Block
    ) noexcept;

 void __cdecl operator delete(
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

 void __cdecl operator delete[](
    void* _Block
    ) noexcept;

 void __cdecl operator delete[](
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

 void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

 void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;
































































#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
     [[nodiscard]] [[msvc::constexpr]]      
    inline void* __cdecl operator new(size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

     inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"


    
     [[nodiscard]]      
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

     inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 189 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma pack(pop)

} 
#line 197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new_debug.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C++" {

#pragma pack(push, 8)






    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_new_debug.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;


























    

        __declspec(dllimport) int*  __cdecl __p__crtDbgFlag(void);
        __declspec(dllimport) long* __cdecl __p__crtBreakAlloc(void);

        
        

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );

    #line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"

    __declspec(dllimport) int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

    __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );

    __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(void);

    __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );

    __declspec(dllimport) void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );

    __declspec(dllimport) int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );

     
    __declspec(dllimport) int __cdecl _CrtReportBlockType(
          void const* _Block
        );

    __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );

    __declspec(dllimport) int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );

#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"
















































    












































    __declspec(dllimport) void __cdecl _aligned_free_dbg(
            void* _Block
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );

    __declspec(dllimport) void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
          char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );


     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
          wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );

    
    

    







#line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"

#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"





















    __declspec(dllimport) int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);

    __declspec(dllimport) int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);


    __declspec(dllimport) int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );

    __declspec(dllimport) int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );

    __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );

    __declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(void);

    __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );

    __declspec(dllimport) int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

    

        extern long _crtAssertBusy;

        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        
        
        
        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );

    #line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"

#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"







































    

    
    
    
        





    #line 741 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"

    
        
    #line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"

    
        
    #line 749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"

    



    



    
    

    
    

    
    

    
    

#line 771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"













    
#line 786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#pragma warning(pop) 
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\crtdbg.h"
#pragma external_header(pop)
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"




















    

#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
        
    #line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"



    

#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
        
    #line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"



    

#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
        
    #line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"





    


#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
        
        
    


#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"


    

#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
        
            
        

#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
    #line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"


    

#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"

#line 80 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
        
    #line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
#line 83 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\crtdefs.h"
#pragma external_header(pop)
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )












#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"















#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"






















































#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"











#line 127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"








#line 137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"


#pragma detect_mismatch("_MSC_VER", "1900")
#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"




#line 152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

#line 156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#line 158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"







#line 167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 175 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 179 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 183 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 191 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 195 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 199 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 211 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 223 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



























#line 251 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"















#line 268 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"





#line 274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 282 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"












#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"
















#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"









#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"



#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "d" "")






#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"

#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"

#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\use_ansi.h"
#pragma external_header(pop)
#line 284 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

















#line 302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"






#line 309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 314 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"






#line 321 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 322 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"




#line 327 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"



#line 331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 332 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"






#line 339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"






#line 347 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 348 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"




#line 353 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

#line 355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 356 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"





 namespace std {
enum _Uninitialized { 
    _Noinit
};

extern "C++" class __declspec(dllimport) _Lockit { 
public:













    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; 
    __thiscall ~_Lockit() noexcept; 
#line 385 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
     _Lockit(const _Lockit&)            = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};



































































#line 469 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
































#line 502 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
} 



#pragma warning(pop)
#pragma pack(pop)
#line 509 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#line 510 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\yvals.h"
#pragma external_header(pop)
#line 9 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"



#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstddef"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )










 namespace std {
 using :: ptrdiff_t;
 using :: size_t;
 using max_align_t = double; 
 using nullptr_t   = decltype(nullptr);



































































} 


using ::std:: max_align_t; 








#pragma warning(pop)
#pragma pack(pop)

#line 115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstddef"
#line 116 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstddef"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstring"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memory.h"










#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memory.h"

    












#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memory.h"

#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memory.h"





    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_memory.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 

#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"
    
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"





    
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );
    

    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );

#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\string.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

 using :: size_t;
 using :: memchr;
 using :: memcmp;
 using :: memcpy;
 using :: memmove;
 using :: memset;
 using :: strcat;
 using :: strchr;
 using :: strcmp;
 using :: strcoll;
 using :: strcpy;
 using :: strcspn;
 using :: strerror;
 using :: strlen;
 using :: strncat;
 using :: strncmp;
 using :: strncpy;
 using :: strpbrk;
 using :: strrchr;
 using :: strspn;
 using :: strstr;
 using :: strtok;
 using :: strxfrm;

#pragma warning(pop)
} 



#pragma warning(pop)
#pragma pack(pop)

#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstring"
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cstring"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )












 namespace std {
template <class>
constexpr bool _Always_false = false; 

template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { 
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<static_cast<bool>(_Next::value), _Next, _Rest...>::type;
};

 template <class... _Traits>
struct conjunction : true_type {}; 

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<static_cast<bool>(_First::value), _First, _Rest...>::type {
    
};

 template <class... _Traits>
constexpr bool conjunction_v = conjunction<_Traits...>::value;

 template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; 

 template <class _Trait>
constexpr bool negation_v = negation<_Trait>::value;

 template <class _Ty>
constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

 template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

 template <class... _Types>
using void_t = void;

template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t [[msvc::known_semantics]] = typename _Identity<_Ty>::type;


 template <class _Ty>
struct add_const { 
    using type = const _Ty;
};

 template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

 template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};

 template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

 template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};

 template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

template <class _Ty, class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

 template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

 template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

 template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

 template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

 template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept {
    static_assert(false, "Calling declval is ill-formed, see N4950 [declval]/2.");
}

 template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

 template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

 template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

 template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

 template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

 template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

template <class _Ty, class = void>
struct _Add_pointer { 
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};

 template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

 template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

 template <class>
constexpr bool is_array_v = false; 

template <class _Ty, size_t _Nx>
constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
constexpr bool is_array_v<_Ty[]> = true;

 template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};



















#line 248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class>
constexpr bool is_lvalue_reference_v = false; 

template <class _Ty>
constexpr bool is_lvalue_reference_v<_Ty&> = true;

 template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

 template <class>
constexpr bool is_rvalue_reference_v = false; 

template <class _Ty>
constexpr bool is_rvalue_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

 template <class>
constexpr bool is_reference_v = false; 

template <class _Ty>
constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
constexpr bool is_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

 template <class>
constexpr bool is_pointer_v = false; 

template <class _Ty>
constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
constexpr bool is_pointer_v<_Ty* const volatile> = true;

 template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

 template <class _Ty>
constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; 

 template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

 template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_union_v = __is_union(_Ty);

 template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_class_v = __is_class(_Ty);

 template <class _Ty>
constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; 

 template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    
};

 template <class _From, class _To>
constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

 template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_enum_v = __is_enum(_Ty);







#line 343 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; 

 template <class _Ty>
constexpr bool is_compound_v = !is_fundamental_v<_Ty>;







#line 357 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"



#line 361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

#line 363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"







#line 371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"





#line 377 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

























#line 403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"


























#line 430 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"









































#line 472 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

template <class... _Types>
struct _Arg_types {}; 

template <class _Ty1>
struct _Arg_types<_Ty1> {
    using argument_type  = _Ty1;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
    using first_argument_type   = _Ty1;
    using second_argument_type  = _Ty2;
};

template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type; 
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type; using result_type  = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };
















#line 533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"





 template <class _Ty>
constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#line 541 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

 template <class>
constexpr bool is_const_v = false; 

template <class _Ty>
constexpr bool is_const_v<const _Ty> = true;

 template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

 template <class>
constexpr bool is_volatile_v = false; 

template <class _Ty>
constexpr bool is_volatile_v<volatile _Ty> = true;

 template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

 template <class _Ty>
constexpr bool is_function_v = 
    !is_const_v<const _Ty> && !is_reference_v<_Ty>;

 template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {};

 template <class _Ty>
constexpr bool is_object_v = 
    is_const_v<const _Ty> && !is_void_v<_Ty>;

 template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {};

template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type           = _Ty2;
};





 template <class _Ty>
constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#line 595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};





 template <class _Ty>
constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#line 606 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; 

 template <class _Ty>
constexpr bool is_scalar_v = 
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

 template <class _Ty>
struct  is_pod : bool_constant<__is_pod(_Ty)> {}; 

 template <class _Ty>
 constexpr bool is_pod_v = __is_pod(_Ty);

 template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_empty_v = __is_empty(_Ty);

 template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

 template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_abstract_v = __is_abstract(_Ty);

 template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_final_v = __is_final(_Ty);

 template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);


 template <class _Ty>
struct  is_literal_type : bool_constant<__is_literal_type(_Ty)> {
    
};

 template <class _Ty>
 constexpr bool is_literal_type_v = __is_literal_type(_Ty);
#line 662 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_trivial : bool_constant<__is_trivial(_Ty)> {}; 

 template <class _Ty>
constexpr bool is_trivial_v = __is_trivial(_Ty);

 template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    
};

 template <class _Ty>
constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

 template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    
};

 template <class _Ty>
constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);


























#line 711 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    
};

 template <class _Ty>
constexpr bool is_default_constructible_v = __is_constructible(_Ty);

template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};

 template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; 

 template <class _To, class _From>
constexpr bool is_assignable_v = __is_assignable(_To, _From);


template <class _To, class _From>
struct _Is_assignable_no_precondition_check : bool_constant<__is_assignable_no_precondition_check(_To, _From)> {};



#line 769 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
constexpr bool is_copy_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
constexpr bool _Is_copy_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);






#line 795 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
constexpr bool _Is_move_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty);






#line 819 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    
};

 template <class _Ty>
constexpr bool is_destructible_v = __is_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    
};

 template <class _Ty>
constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

 template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

 template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
constexpr bool is_trivially_copy_assignable_v =
    __is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    
};

 template <class _Ty>
constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
    
};

 template <class _Ty>
constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    
};

 template <class _Ty>
constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

 template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

 template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
constexpr bool is_nothrow_copy_assignable_v =
    __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    
    
};

 template <class _Ty>
constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { 
                                
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

 template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; 

 template <class _Ty>
constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

 template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; 

 template <class _Ty>
constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

template <class _Ty>
constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

template <bool>
struct _Select { 
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; 

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = 
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_signed { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

 template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

template <size_t>
struct _Make_unsigned2; 

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = 
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_unsigned { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

 template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

 template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; 

 template <class _Ty>
constexpr size_t alignment_of_v = alignof(_Ty);

template <class _Ty, size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; 

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "To suppress this error, please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to confirm that you want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to get the old non-conforming behavior.");
#line 1138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next                 = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next                 = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next                 = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};


template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct _Aligned_storage { 
    using _Next                 = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
using _Aligned_storage_t = typename _Aligned_storage<_Len, _Align>::type;

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct  aligned_storage { 
    using type = _Aligned_storage_t<_Len, _Align>;
};

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t  = _Aligned_storage_t<_Len, _Align>;

template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; 

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; 

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    
};

 template <size_t _Len, class... _Types>
struct  aligned_union {
    
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = _Aligned_storage_t<_Max_len, alignment_value>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
 template <size_t _Len, class... _Types>
using aligned_union_t  = typename aligned_union<_Len, _Types...>::type;
__pragma(warning(pop))

template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template <class _Ty>
struct _Underlying_type<_Ty, false> {};

 template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {}; 

 template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;

 template <class _Ty>
constexpr size_t rank_v = 0; 

template <class _Ty, size_t _Nx>
constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

 template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

 template <class _Ty, unsigned int _Ix = 0>
constexpr size_t extent_v = 0; 

template <class _Ty, size_t _Nx>
constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

 template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

 template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    
};

 template <class _Base, class _Derived>
constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

 template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

 template <class _Ty>
using decay_t = typename decay<_Ty>::type;

template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());















#line 1287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {};
#line 1290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

 template <class... _Ty>
struct common_type;

 template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};

template <class _Ty>
_Ty _Returns_exactly() noexcept; 

































































































































































#line 1491 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

template <class _Type, template <class...> class _Template>
constexpr bool _Is_specialization_v = false; 
template <template <class...> class _Template, class... _Types>
constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept {
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr 
    conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&, _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept {
    return ::std:: move(_Arg);
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

 template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

#pragma warning(push)
#pragma warning(disable : 5215) 
#pragma warning(disable : 5216) 






template <class _Ty>
[[nodiscard]] _Ty _Fake_copy_init(_Ty) noexcept;









#pragma warning(pop)

 template <class _Ty>
class reference_wrapper;





enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args)
        noexcept(noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...))) 
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
        noexcept(noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...))) 
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2)
        noexcept(noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...))) 
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
        noexcept(noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...))) 
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd) {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd) {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};

template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
struct _Invoker1;

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_same_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>
                        || is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>,
          _Invoker_pmf_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
          is_same_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>
              || is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>,
          _Invoker_pmd_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {};

 template <class _Callable>
constexpr auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
    -> decltype(static_cast<_Callable&&>(_Obj)()) {
    return static_cast<_Callable&&>(_Obj)();
}

 template <class _Callable, class _Ty1, class... _Types2>
constexpr auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2)
    noexcept(noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...))) 
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {


#line 1693 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
        auto& _Ref = _Arg1.get();
        return _Ref.*_Obj;
#line 1696 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
    } else {
        ;
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 

template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
constexpr bool _Is_nothrow_convertible_v = noexcept(::std:: _Fake_copy_init<_To>(::std:: declval<_From>()));

#pragma warning(pop)

template <class _From, class _To, bool _IsVoid>
constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    
};







#line 1730 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {};

template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))>>
    : true_type {};

template <class _From, class _To>
struct _Invoke_nothrow_convertible
    : bool_constant<noexcept(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))> {};

template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type                  = _Result;
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
            conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};

template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable>
using _Decltype_invoke_zero = decltype(::std:: declval<_Callable>()());

template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(::std:: declval<_Callable>()())> {};

template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...));

template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                          ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...))> {};

template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;


 template <class _Fty>
struct  result_of { 
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
                                       "result_of<CallableType(zero or more argument types)> instead.");
};







template <class _Callable, class... _Args> struct  result_of<_Callable __cdecl(_Args...)> : _Select_invoke_traits<_Callable, _Args...> { };    template <class _Callable, class... _Args> struct  result_of<_Callable __vectorcall(_Args...)> : _Select_invoke_traits<_Callable, _Args...> { };


__pragma(warning(push)) __pragma(warning(disable : 4996))
 template <class _Ty>
using result_of_t  = typename result_of<_Ty>::type;
__pragma(warning(pop))
#line 1819 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};










































#line 1873 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

























#line 1899 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

template <class _Ty>
struct _Function_args {}; 







template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)   > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)   > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const  > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const  > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile  > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile  > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile  > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile  > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  & > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  & > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const & > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const & > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile & > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile & > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile & > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile & > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  && > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  && > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const && > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const && > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile && > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile && > : _Arg_types<_Types...> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile && > : _Arg_types<_Types...> { using result_type  = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile && > : _Arg_types<_Types...> { using result_type  = _Ret; };








template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) > { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&&> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&&> { using result_type  = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&&> { using result_type  = _Ret; };


template <class _Ty, class = void>
struct _Weak_result_type {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
    using result_type  = typename _Ty::result_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    
    using argument_type  = typename _Ty::argument_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
    using first_argument_type   = typename _Ty::first_argument_type;
    using second_argument_type  = typename _Ty::second_argument_type;
};
__pragma(warning(pop))

template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;

template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept; 
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>>
    : true_type {}; 

 template <class _Ty>
class reference_wrapper

    : public _Weak_types<_Ty>
#line 1976 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
{
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    inline reference_wrapper(_Uty&& _Val) noexcept(
        noexcept(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) { 
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    inline operator _Ty&() const noexcept {
        return *_Ptr;
    }

    [[nodiscard]] inline _Ty& get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template <class... _Types>
    inline auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...))) 
        -> decltype(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)) {
        return ::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};




#line 2016 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

 template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

 template <class _Ty>
void ref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}

 template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

 template <class _Ty>
void cref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}



















#line 2062 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

template <class _Ty>
struct _Is_swappable;

template <class _Ty>
struct _Is_nothrow_swappable;



#line 2072 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
template <class _Ty, int _Enabled = 0>
#line 2074 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
inline void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>);

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
inline void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; 

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; 

template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    
};

template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};

template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
                                          && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    
    
};

template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    
    
};

template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};


































#line 2151 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

namespace _Has_ADL_swap_detail {


#line 2156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
    void swap();
#line 2158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;






template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    
};























#line 2203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"


































template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) != _Bitmask{};
}

template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_all(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) == _Elements;
}




 constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
 constexpr size_t _FNV_prime        = 1099511628211ULL;



#line 2256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivially_copyable_v<_Ty>, "Only trivially copyable types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivially_copyable_v<_Kty>, "Only trivially copyable types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivially_copyable_v<_Kty>, "Only trivially copyable types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

 template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { 
    using argument_type  = _Kty;
    using result_type    = size_t;

    [[nodiscard]] static size_t operator()(const _Kty& _Keyval) 
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))  {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                              = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&)            = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)                 = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&)      = delete;
};

 template <class _Kty>
struct hash : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty>
                                                    && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
    using argument_type  = float;
    using result_type    = size_t;
    [[nodiscard]] static size_t operator()(const float _Keyval)  noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};

template <>
struct hash<double> {
    using argument_type  = double;
    using result_type    = size_t;
    [[nodiscard]] static size_t operator()(const double _Keyval)  noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};

template <>
struct hash<long double> {
    using argument_type  = long double;
    using result_type    = size_t;
    [[nodiscard]] static size_t operator()(const long double _Keyval)  noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};

template <>
struct hash<nullptr_t> {
    using argument_type  = nullptr_t;
    using result_type    = size_t;
    [[nodiscard]] static size_t operator()(nullptr_t)  noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; 

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};

 template <class _Ty = void>
struct less {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left < _Right)))  {
        return _Left < _Right;
    }
};

template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};



template <class _FloatingType>
struct _Floating_type_traits;

template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits           = 24; 
    static constexpr int32_t _Exponent_bits           = 8; 
    static constexpr int32_t _Maximum_binary_exponent = 127; 
    static constexpr int32_t _Minimum_binary_exponent = -126; 
    static constexpr int32_t _Exponent_bias           = 127;
    static constexpr int32_t _Sign_shift              = 31; 
    static constexpr int32_t _Exponent_shift          = 23; 

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask             = 0x000000FFu; 
    static constexpr uint32_t _Normal_mantissa_mask      = 0x00FFFFFFu; 
    static constexpr uint32_t _Denormal_mantissa_mask    = 0x007FFFFFu; 
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; 
    static constexpr uint32_t _Shifted_sign_mask         = 0x80000000u; 
    static constexpr uint32_t _Shifted_exponent_mask     = 0x7F800000u; 

    static constexpr float _Minimum_value = 0x1.000000p-126f; 
    static constexpr float _Maximum_value = 0x1.FFFFFEp+127f; 
};

template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits           = 53; 
    static constexpr int32_t _Exponent_bits           = 11; 
    static constexpr int32_t _Maximum_binary_exponent = 1023; 
    static constexpr int32_t _Minimum_binary_exponent = -1022; 
    static constexpr int32_t _Exponent_bias           = 1023;
    static constexpr int32_t _Sign_shift              = 63; 
    static constexpr int32_t _Exponent_shift          = 52; 

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask             = 0x00000000000007FFu; 
    static constexpr uint64_t _Normal_mantissa_mask      = 0x001FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Denormal_mantissa_mask    = 0x000FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; 
    static constexpr uint64_t _Shifted_sign_mask         = 0x8000000000000000u; 
    static constexpr uint64_t _Shifted_exponent_mask     = 0x7FF0000000000000u; 

    static constexpr double _Minimum_value = 0x1.0000000000000p-1022; 
    static constexpr double _Maximum_value = 0x1.FFFFFFFFFFFFFp+1023; 
};

template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {};



template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To _Bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr auto _Float_abs_bits(const _Ty& _Xx) noexcept {
    using _Traits    = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_abs(const _Ty _Xx) noexcept { 
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_nan(const _Ty _Xx) noexcept { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_finite(const _Ty _Xx) noexcept { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}

template <bool _IsConst, class _Ty>
using _Maybe_const = conditional_t<_IsConst, const _Ty, _Ty>;

template <class _Ty, size_t _Size>
void _Swap_trivial_arrays(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept {
    
    
    
    
    
    
    auto _Left_ptr  = reinterpret_cast<unsigned char*>(&_Left);
    auto _Right_ptr = reinterpret_cast<unsigned char*>(&_Right);

    constexpr size_t _Part_size_bytes = 64;
    constexpr size_t _Size_bytes      = _Size * sizeof(_Ty);
    constexpr size_t _Size_tail       = _Size_bytes % _Part_size_bytes;
    constexpr size_t _Size_parts      = _Size_bytes - _Size_tail;

    if constexpr (_Size_parts != 0) {
        const auto _Stop = _Left_ptr + _Size_parts;
        do {
            unsigned char _Buf[_Part_size_bytes];
            :: memcpy(_Buf, _Left_ptr, _Part_size_bytes);
            :: memcpy(_Left_ptr, _Right_ptr, _Part_size_bytes);
            :: memcpy(_Right_ptr, _Buf, _Part_size_bytes);
            _Left_ptr += _Part_size_bytes;
            _Right_ptr += _Part_size_bytes;

        } while (_Left_ptr != _Stop);
    }

    if constexpr (_Size_tail != 0) {
        unsigned char _Buf[_Size_tail];
        :: memcpy(_Buf, _Left_ptr, _Size_tail);
        :: memcpy(_Left_ptr, _Right_ptr, _Size_tail);
        :: memcpy(_Right_ptr, _Buf, _Size_tail);
    }
}


__pragma(warning(push)) __pragma(warning(disable : 4996))
namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 {
    using ::std:: add_const;
    using ::std:: add_cv;
    using ::std:: add_pointer;
    using ::std:: add_volatile;
    using ::std:: aligned_storage;
    using ::std:: alignment_of;
    using ::std:: conditional;
    using ::std:: decay;
    using ::std:: enable_if;
    using ::std:: extent;
    using ::std:: false_type;
    using ::std:: has_virtual_destructor;
    using ::std:: integral_constant;
    using ::std:: is_abstract;
    using ::std:: is_arithmetic;
    using ::std:: is_array;
    using ::std:: is_base_of;
    using ::std:: is_class;
    using ::std:: is_compound;
    using ::std:: is_const;
    using ::std:: is_convertible;
    using ::std:: is_empty;
    using ::std:: is_enum;
    using ::std:: is_floating_point;
    using ::std:: is_function;
    using ::std:: is_fundamental;
    using ::std:: is_integral;
    using ::std:: is_member_function_pointer;
    using ::std:: is_member_object_pointer;
    using ::std:: is_member_pointer;
    using ::std:: is_object;
    using ::std:: is_pod;
    using ::std:: is_pointer;
    using ::std:: is_polymorphic;
    using ::std:: is_reference;
    using ::std:: is_same;
    using ::std:: is_scalar;
    using ::std:: is_signed;
    using ::std:: is_union;
    using ::std:: is_unsigned;
    using ::std:: is_void;
    using ::std:: is_volatile;
    using ::std:: make_signed;
    using ::std:: make_unsigned;
    using ::std:: rank;
    using ::std:: remove_all_extents;
    using ::std:: remove_const;
    using ::std:: remove_cv;
    using ::std:: remove_extent;
    using ::std:: remove_pointer;
    using ::std:: remove_reference;
    using ::std:: remove_volatile;
    using ::std:: true_type;
    using ::std:: cref;
    using ::std:: ref;
    using ::std:: reference_wrapper;

    using ::std:: result_of;
#line 2587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
    using ::std:: hash;
} 
__pragma(warning(pop))
#line 2591 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"

} 








#pragma warning(pop)
#pragma pack(pop)

#line 2605 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
#line 2606 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\type_traits"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {


 extern "C++"  [[nodiscard]]  bool __cdecl
    uncaught_exception() noexcept;
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
 extern "C++" [[nodiscard]]  int __cdecl uncaught_exceptions() noexcept;

} 




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_exception.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"







#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_terminate.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )(void);
typedef void (__cdecl* terminate_function)(void);








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_terminate.h"

#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\corecrt_terminate.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"




#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {


    typedef void (__cdecl* unexpected_handler )(void);

    




    
         __declspec(noreturn) void __cdecl unexpected() noexcept(false);

        
             unexpected_handler __cdecl set_unexpected(
                  unexpected_handler _NewUnexpectedHandler
                ) noexcept;
             unexpected_handler __cdecl _get_unexpected() noexcept;
        #line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"
    #line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"
#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"

struct _EXCEPTION_POINTERS;


    
        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );
    #line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"

    extern "C++" { 
         class type_info;
    } 

     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();
#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\eh.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_exception.h"







#pragma warning(push)
#pragma warning(disable:   4514 4820 )
#pragma warning(disable: 4577) 
#pragma warning(disable: 4643) 

#pragma pack(push, 8)

__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
         __std_exception_data const* _From,
      __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))


extern "C++" {

namespace std {

 class [[nodiscard]] exception
{
public:

    exception() noexcept
        : _Data()
    {
    }

    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }

    [[nodiscard]] virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

 class [[nodiscard]] bad_exception
    : public exception
{
public:

    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};

 class [[nodiscard]] bad_array_new_length;

 class [[nodiscard]] bad_alloc
    : public exception
{
public:

    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }

private:

    friend bad_array_new_length;

    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};

 class [[nodiscard]] bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};

} 

} 

#pragma pack(pop)

#pragma warning(pop) 
#line 156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vcruntime_exception.h"
#pragma external_header(pop)
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"

 namespace std {

 using ::terminate;


 using ::set_terminate;
 using ::terminate_handler;

 [[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept {
    
    return _get_terminate();
}
#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"


using ::unexpected;


using ::set_unexpected;
using ::unexpected_handler;

[[nodiscard]] inline unexpected_handler __cdecl get_unexpected() noexcept {
    
    return _get_unexpected();
}
#line 62 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"

} 















































































































































#line 209 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"

extern "C++"  void __cdecl __ExceptionPtrCreate(  void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrDestroy(  void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrCopy(  void*,   const void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrAssign(  void*,   const void*) noexcept;
extern "C++"  bool __cdecl __ExceptionPtrCompare(
      const void*,   const void*) noexcept;
extern "C++"  bool __cdecl __ExceptionPtrToBool(  const void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrSwap(  void*,   void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
extern "C++" [[noreturn]]  void __cdecl __ExceptionPtrRethrow(  const void*);
extern "C++"  void __cdecl __ExceptionPtrCopyException(
      void*,   const void*,   const void*) noexcept;

 namespace std {

 class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }

    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }

    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);





#line 243 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
    }

    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }

    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }

    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }

    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }

    static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }

    friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !_Lhs;
    }


    [[nodiscard]] friend bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept {
        return !_Rhs;
    }

    [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

    [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !(_Lhs == nullptr);
    }

    [[nodiscard]] friend bool operator!=(nullptr_t, const exception_ptr& _Rhs) noexcept {
        return !(nullptr == _Rhs);
    }
#line 303 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"

private:




    void* _Data1{};
    void* _Data2{};



};

 [[nodiscard]] inline exception_ptr current_exception() noexcept {
    exception_ptr _Retval;
    __ExceptionPtrCurrentException(&_Retval);
    return _Retval;
}

 [[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr) {
    __ExceptionPtrRethrow(&_Ptr);
}

template <class _Ex>
void* __GetExceptionInfo(_Ex);

 template <class _Ex>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
}

 class nested_exception { 
public:
    nested_exception() noexcept : _Exc(::std:: current_exception()) {}

    nested_exception(const nested_exception&) noexcept            = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}

    [[noreturn]] void rethrow_nested() const { 
        if (_Exc) {
            ::std:: rethrow_exception(_Exc);
        } else {
            ::std:: terminate(); 
        }
    }

    [[nodiscard]] exception_ptr nested_ptr() const noexcept { 
        return _Exc;
    }

private:
    exception_ptr _Exc;
};

template <class _Uty>
struct _With_nested_v2 : _Uty, nested_exception { 
    template <class _Ty>
    explicit _With_nested_v2(_Ty&& _Arg)
        : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception() {} 
};

 template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg) {
    
    using _Uty = decay_t<_Ty>;

    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        
        throw(_With_nested_v2<_Uty>(::std:: forward<_Ty>(_Arg)));
    } else {
        
        throw(::std:: forward<_Ty>(_Arg));
    }
}


 template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg) {
    
    constexpr bool _Can_use_dynamic_cast =
        is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>);

    if constexpr (_Can_use_dynamic_cast) {
        const auto _Nested = dynamic_cast<const nested_exception*>(::std:: addressof(_Arg));

        if (_Nested) {
            _Nested->rethrow_nested();
        }
    }
}



#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"

 class [[nodiscard]] bad_variant_access : public exception {
    
public:
    bad_variant_access() noexcept = default;

    [[nodiscard]] const char*  what() const noexcept override {
        return "bad variant access";
    }






#line 414 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
};

[[noreturn]] inline void _Throw_bad_variant_access() {
    throw(bad_variant_access{});
}

} 



#pragma warning(pop)
#pragma pack(pop)

#line 428 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
#line 429 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\exception"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {





#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"




















#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"

 using new_handler = void(__cdecl*)();

 extern "C++"  new_handler __cdecl set_new_handler(  new_handler) noexcept;
 extern "C++" [[nodiscard]]  new_handler __cdecl get_new_handler() noexcept;
} 



#pragma warning(pop)
#pragma pack(pop)

#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"
#line 62 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\new"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"














#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )

















#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"












#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
















#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"




#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"

 namespace std {
























#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
#line 108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"

using _Atomic_counter_t = unsigned long;

template <class _Integral, class _Ty>
[[nodiscard]] volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}

template <class _Integral, class _Ty>
[[nodiscard]] const volatile _Integral* _Atomic_address_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<const volatile _Integral&>(_Source);
}

} 



#pragma warning(pop)
#pragma pack(pop)
#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
#line 133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xatomic.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\initializer_list"











#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {
 template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    [[nodiscard]] constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    [[nodiscard]] constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
} 


#pragma warning(pop)
#pragma pack(pop)
#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\initializer_list"
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\initializer_list"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"





#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"



#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )














 namespace std {
 template <class _Ty, _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    [[nodiscard]] static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

 template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

 template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

 template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

 template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max) (const _Ty& _Left [[msvc::lifetimebound]], const _Ty& _Right [[msvc::lifetimebound]],
    _Pr _Pred) noexcept(noexcept(_Pred(_Left, _Right)))  {
    
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]   constexpr const _Ty& 
    (max) (const _Ty& _Left [[msvc::lifetimebound]], const _Ty& _Right [[msvc::lifetimebound]])
        noexcept(noexcept(_Left < _Right))  {
    
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>); 

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min) (const _Ty& _Left [[msvc::lifetimebound]], const _Ty& _Right [[msvc::lifetimebound]],
    _Pr _Pred) noexcept(noexcept(_Pred(_Right, _Left)))  {
    
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]   constexpr const _Ty& 
    (min) (const _Ty& _Left [[msvc::lifetimebound]], const _Ty& _Right [[msvc::lifetimebound]])
        noexcept(noexcept(_Right < _Left))  {
    
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>); 

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> >
inline void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    if (&_Left == &_Right) {
        return; 
    }

    if constexpr (_Is_trivially_swappable_v<_Ty>) {
        if (!::std:: _Is_constant_evaluated()) {
            ::std:: _Swap_trivial_arrays(_Left, _Right);
            return;
        }
    }

    _Ty* _First1 = _Left;
    _Ty* _Last1  = _First1 + _Size;
    _Ty* _First2 = _Right;
    for (; _First1 != _Last1; ++_First1, ++_First2) {
        swap(*_First1, *_First2); 
    }
}



#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template <class _Ty, int _Enabled >
#line 137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
inline void swap(_Ty& _Left, _Ty& _Right)
    noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}

 struct piecewise_construct_t { 
    explicit piecewise_construct_t() = default;
};

  constexpr piecewise_construct_t piecewise_construct{};

struct _Ignore { 
    template <class _Ty>
    constexpr const _Ignore& operator=(const _Ty&) const noexcept {
        
        return *this;
    }
};

  constexpr _Ignore ignore{};

 template <class... _Types>
class tuple;

 template <class _Ty1, class _Ty2>
struct pair;

 template <class _Ty, size_t _Size>
class array;

 template <class _Tuple>
struct tuple_size;

 template <class _Ty>
constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

 template <size_t _Index, class _Tuple>
struct tuple_element;

 template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;





































#line 245 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

 template <class _Ty1, class _Ty2>
struct pair { 
    using first_type  = _Ty1;
    using second_type = _Ty2;

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>) pair()
        noexcept(is_nothrow_default_constructible_v<_Uty1> && is_nothrow_default_constructible_v<_Uty2>) 
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>)
        pair(const _Ty1& _Val1, const _Ty2& _Val2)
            noexcept(is_nothrow_copy_constructible_v<_Uty1> && is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}



#line 268 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
    template <class _Other1, class _Other2,
#line 270 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {
    }

    pair(const pair&) = default;
    pair(pair&&)      = default;








#line 288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>,
            int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>)
        pair(const pair<_Other1, _Other2>& _Right)
            noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>
                     && is_nothrow_constructible_v<_Ty2, const _Other2&>) 
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}























#line 328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

    template <class... _Types1, class... _Types2>
    inline pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    inline pair& operator=(_Identity_t<const _Myself&> _Right)
        noexcept(conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }












#line 358 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    inline pair& operator=(_Identity_t<_Myself&&> _Right)
        noexcept(conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)  {
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }












#line 382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    inline pair& operator=(const pair<_Other1, _Other2>& _Right)
        noexcept(is_nothrow_assignable_v<_Ty1&, const _Other1&>
                 && is_nothrow_assignable_v<_Ty2&, const _Other2&>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }












#line 407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    inline pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, _Other1> && is_nothrow_assignable_v<_Ty2&, _Other2>)  {
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }



































#line 454 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

    inline void swap(pair& _Right)
        noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value) {
        using ::std:: swap;
        swap(first, _Right.first); 
        swap(second, _Right.second); 
    }









#line 471 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

    _Ty1 first; 
    _Ty2 second; 

private:
    template <class _Tuple1, class _Tuple2, size_t... _Indices1, size_t... _Indices2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indices1...>, index_sequence<_Indices2...>)
        : first(::std:: _Tuple_get<_Indices1>(::std:: move(_Val1))...),
          second(::std:: _Tuple_get<_Indices2>(::std:: move(_Val2))...) {}
};




#line 486 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

 template <class _Ty1, class _Ty2,
    enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
inline void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}








#line 501 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

 template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return _Left.first == _Right.first && _Left.second == _Right.second;
}











#line 518 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return !(_Left == _Right);
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return _Right < _Left;
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return !(_Left < _Right);
}
#line 543 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
















#line 560 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

template <class _Ty>
struct _Unrefwrap_helper { 
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { 
    using type = _Ty&;
};


template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
    noexcept(is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>
             && is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)  {
    
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}

namespace  rel_ops {
     template <class _Ty>
     [[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left == _Right);
    }

     template <class _Ty>
     [[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right) {
        return _Right < _Left;
    }

     template <class _Ty>
     [[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Right < _Left);
    }

     template <class _Ty>
     [[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left < _Right);
    }
} 

template <class _Tuple, class = void>
struct _Tuple_size_sfinae {}; 

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {}; 

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct  tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct  tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct  [[msvc::known_semantics]] tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct  [[msvc::known_semantics]] tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {}; 

template <size_t _Idx, class _Ty, size_t _Size>
struct [[msvc::known_semantics]] tuple_element<_Idx, array<_Ty, _Size>> {
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};

template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {}; 

template <size_t _Index>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<>> { 
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<0, tuple<_This, _Rest...>> { 
    using type = _This;
    
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {}; 

template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {}; 

template <size_t _Idx, class _Ty1, class _Ty2>
struct [[msvc::known_semantics]] tuple_element<_Idx, pair<_Ty1, _Ty2>> {
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<_Ty1>(_Pr.first);
    } else {
        return ::std:: forward<_Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty2>(_Pr.second);
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<const _Ty1>(_Pr.first);
    } else {
        return ::std:: forward<const _Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty2>(_Pr.second);
}

 template <class _Ty, class _Other = _Ty>
inline _Ty exchange(_Ty& _Val, _Other&& _New_val)
    noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {
    
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { 
    return _Val;
}

 template <class _Ty>
void as_const(const _Ty&&) = delete;




















#line 806 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool _Cmp_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    ; 
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left == _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Left == static_cast<make_unsigned_t<_Ty2>>(_Right) && _Right >= 0;
    } else {
        return static_cast<make_unsigned_t<_Ty1>>(_Left) == _Right && _Left >= 0;
    }
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool _Cmp_not_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: _Cmp_equal(_Left, _Right);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool _Cmp_less(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    ; 
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left < _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Right > 0 && _Left < static_cast<make_unsigned_t<_Ty2>>(_Right);
    } else {
        return _Left < 0 || static_cast<make_unsigned_t<_Ty1>>(_Left) < _Right;
    }
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool _Cmp_greater(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return ::std:: _Cmp_less(_Right, _Left);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool _Cmp_less_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: _Cmp_less(_Right, _Left);
}

template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool _Cmp_greater_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: _Cmp_less(_Left, _Right);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty _Min_limit() noexcept { 
    ; 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>((_Unsigned_max >> 1) + 1); 
    } else {
        return 0;
    }
}

template <class _Ty>
[[nodiscard]] constexpr _Ty _Max_limit() noexcept { 
    ; 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>(_Unsigned_max >> 1);
    } else {
        return static_cast<_Ty>(-1);
    }
}

template <class _Rx, class _Ty>
[[nodiscard]] constexpr bool _In_range(const _Ty _Value) noexcept {
    ; 

    constexpr auto _Ty_min = _Min_limit<_Ty>();
    constexpr auto _Rx_min = _Min_limit<_Rx>();

    if constexpr (::std:: _Cmp_less(_Ty_min, _Rx_min)) {
        if (_Value < _Ty{_Rx_min}) {
            return false;
        }
    }

    constexpr auto _Ty_max = _Max_limit<_Ty>();
    constexpr auto _Rx_max = _Max_limit<_Rx>();

    if constexpr (::std:: _Cmp_greater(_Ty_max, _Rx_max)) {
        if (_Value > _Ty{_Rx_max}) {
            return false;
        }
    }

    return true;
}






















































#line 952 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"






















#line 975 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"


namespace [[deprecated( "warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]] tr1 {
    using ::std:: get;
    using ::std:: tuple_element;
    using ::std:: tuple_size;
} 
#line 983 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"

} 









#pragma warning(pop)
#pragma pack(pop)
#line 997 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
#line 998 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\utility"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {
template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {}; 

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {};

 struct allocator_arg_t { 
    explicit allocator_arg_t() = default;
};

  constexpr allocator_arg_t allocator_arg{};

 template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {};

 template <class _Ty, class _Alloc>
constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;


 struct input_iterator_tag {};

 struct output_iterator_tag {};

 struct forward_iterator_tag : input_iterator_tag {};

 struct bidirectional_iterator_tag : forward_iterator_tag {};

 struct random_access_iterator_tag : bidirectional_iterator_tag {};


































































































































































































































































































































































































































#line 468 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"
template <class, class = void>
struct _Iterator_traits_base {}; 

template <class _Iter>
struct _Iterator_traits_base<_Iter,
    void_t<typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type,
        typename _Iter::pointer, typename _Iter::reference>> {
    
    using iterator_category = typename _Iter::iterator_category;
    using value_type        = typename _Iter::value_type;
    using difference_type   = typename _Iter::difference_type;
    using pointer           = typename _Iter::pointer;
    using reference         = typename _Iter::reference;
};

template <class _Ty, bool = is_object_v<_Ty>>
struct _Iterator_traits_pointer_base { 
    using iterator_category = random_access_iterator_tag;
    using value_type        = remove_cv_t<_Ty>;
    using difference_type   = ptrdiff_t;
    using pointer           = _Ty*;
    using reference         = _Ty&;
};

template <class _Ty>
struct _Iterator_traits_pointer_base<_Ty, false> {}; 

template <class _Iter>
struct iterator_traits : _Iterator_traits_base<_Iter> {}; 

template <class _Ty>
struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty> {}; 

template <class _Ty>
constexpr bool _Integer_like = _Is_nonbool_integral<_Ty>;
#line 504 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"

 constexpr auto _Meta_npos = ~size_t{0};

constexpr size_t _Meta_find_index_i_(const bool* const _Ptr, const size_t _Count, size_t _Idx = 0) {
    
    for (; _Idx < _Count; ++_Idx) {
        if (_Ptr[_Idx]) {
            return _Idx;
        }
    }

    return _Meta_npos;
}

template <class _List, class _Ty>
struct _Meta_find_unique_index_ {
    using type = integral_constant<size_t, _Meta_npos>;
};
template <class _List, class _Ty>
using _Meta_find_unique_index =
    
    typename _Meta_find_unique_index_<_List, _Ty>::type;

constexpr size_t _Meta_find_unique_index_i_2(const bool* const _Ptr, const size_t _Count, const size_t _First) {
    
    return _First != _Meta_npos && ::std:: _Meta_find_index_i_(_Ptr, _Count, _First + 1) == _Meta_npos ? _First
                                                                                                    : _Meta_npos;
}

constexpr size_t _Meta_find_unique_index_i_(const bool* const _Ptr, const size_t _Count) {
    
    return ::std:: _Meta_find_unique_index_i_2(_Ptr, _Count, ::std:: _Meta_find_index_i_(_Ptr, _Count));
}

template <template <class...> class _List, class _First, class... _Rest, class _Ty>
struct _Meta_find_unique_index_<_List<_First, _Rest...>, _Ty> {
    static constexpr bool _Bools[] = {is_same_v<_First, _Ty>, is_same_v<_Rest, _Ty>...};
    using type = integral_constant<size_t, ::std:: _Meta_find_unique_index_i_(_Bools, 1 + sizeof...(_Rest))>;
};
} 



#pragma warning(pop)
#pragma pack(pop)
#line 550 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"
#line 551 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\__msvc_iter_core.hpp"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )






















#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"


#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"






#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"






#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"




#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"


extern "C" {







__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;

__declspec(noalias) size_t __stdcall __std_count_trivial_1(
    const void* _First, const void* _Last, uint8_t _Val) noexcept;
__declspec(noalias) size_t __stdcall __std_count_trivial_2(
    const void* _First, const void* _Last, uint16_t _Val) noexcept;
__declspec(noalias) size_t __stdcall __std_count_trivial_4(
    const void* _First, const void* _Last, uint32_t _Val) noexcept;
__declspec(noalias) size_t __stdcall __std_count_trivial_8(
    const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_last_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
const void* __stdcall __std_find_last_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
const void* __stdcall __std_find_last_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
const void* __stdcall __std_find_last_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_search_1(
    const void* _First1, const void* _Last1, const void* _First2, size_t _Count2) noexcept;
const void* __stdcall __std_search_2(
    const void* _First1, const void* _Last1, const void* _First2, size_t _Count2) noexcept;

const void* __stdcall __std_find_end_1(
    const void* _First1, const void* _Last1, const void* _First2, size_t _Count2) noexcept;
const void* __stdcall __std_find_end_2(
    const void* _First1, const void* _Last1, const void* _First2, size_t _Count2) noexcept;

const void* __stdcall __std_min_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_f(const void* _First, const void* _Last, bool _Unused) noexcept;
const void* __stdcall __std_min_element_d(const void* _First, const void* _Last, bool _Unused) noexcept;

const void* __stdcall __std_max_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_f(const void* _First, const void* _Last, bool _Unused) noexcept;
const void* __stdcall __std_max_element_d(const void* _First, const void* _Last, bool _Unused) noexcept;

__declspec(noalias) int8_t __stdcall __std_min_1i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint8_t __stdcall __std_min_1u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) int16_t __stdcall __std_min_2i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint16_t __stdcall __std_min_2u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) int32_t __stdcall __std_min_4i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint32_t __stdcall __std_min_4u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) int64_t __stdcall __std_min_8i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint64_t __stdcall __std_min_8u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) float __stdcall __std_min_f(const void* _First, const void* _Last) noexcept;
__declspec(noalias) double __stdcall __std_min_d(const void* _First, const void* _Last) noexcept;
__declspec(noalias) int8_t __stdcall __std_max_1i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint8_t __stdcall __std_max_1u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) int16_t __stdcall __std_max_2i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint16_t __stdcall __std_max_2u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) int32_t __stdcall __std_max_4i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint32_t __stdcall __std_max_4u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) int64_t __stdcall __std_max_8i(const void* _First, const void* _Last) noexcept;
__declspec(noalias) uint64_t __stdcall __std_max_8u(const void* _First, const void* _Last) noexcept;
__declspec(noalias) float __stdcall __std_max_f(const void* _First, const void* _Last) noexcept;
__declspec(noalias) double __stdcall __std_max_d(const void* _First, const void* _Last) noexcept;

__declspec(noalias) size_t __stdcall __std_mismatch_1(const void* _First1, const void* _First2, size_t _Count) noexcept;
__declspec(noalias) size_t __stdcall __std_mismatch_2(const void* _First1, const void* _First2, size_t _Count) noexcept;
__declspec(noalias) size_t __stdcall __std_mismatch_4(const void* _First1, const void* _First2, size_t _Count) noexcept;
__declspec(noalias) size_t __stdcall __std_mismatch_8(const void* _First1, const void* _First2, size_t _Count) noexcept;
} 

 namespace std {
template <size_t _Nx>
__declspec(noalias) void _Reverse_vectorized(void* _First, void* _Last) noexcept {
    if constexpr (_Nx == 1) {
        ::__std_reverse_trivially_swappable_1(_First, _Last);
    } else if constexpr (_Nx == 2) {
        ::__std_reverse_trivially_swappable_2(_First, _Last);
    } else if constexpr (_Nx == 4) {
        ::__std_reverse_trivially_swappable_4(_First, _Last);
    } else if constexpr (_Nx == 8) {
        ::__std_reverse_trivially_swappable_8(_First, _Last);
    } else {
        ; 
    }
}

template <class _Ty, class _TVal>
__declspec(noalias) size_t _Count_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {
    if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {

        return ::__std_count_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val));


#line 176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    } else if constexpr (sizeof(_Ty) == 1) {
        return ::__std_count_trivial_1(_First, _Last, static_cast<uint8_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 2) {
        return ::__std_count_trivial_2(_First, _Last, static_cast<uint16_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 4) {
        return ::__std_count_trivial_4(_First, _Last, static_cast<uint32_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 8) {
        return ::__std_count_trivial_8(_First, _Last, static_cast<uint64_t>(_Val));
    } else {
        ; 
    }
}

template <class _Ty, class _TVal>
_Ty* _Find_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {
    if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {

        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));



#line 199 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
    } else {
        ; 
    }
}

template <class _Ty, class _TVal>
_Ty* _Find_last_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {
    if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {

        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));



#line 226 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_last_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_last_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_last_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_last_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
    } else {
        ; 
    }
}


 constexpr ptrdiff_t _Threshold_find_first_of = 16;

template <class _Ty1, class _Ty2>
_Ty1* _Search_vectorized(_Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, const size_t _Count2) noexcept {
    ;
    if constexpr (sizeof(_Ty1) == 1) {
        return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_1(_First1, _Last1, _First2, _Count2)));
    } else if constexpr (sizeof(_Ty1) == 2) {
        return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_search_2(_First1, _Last1, _First2, _Count2)));
    } else {
        ; 
    }
}

template <class _Ty1, class _Ty2>
_Ty1* _Find_end_vectorized(
    _Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, const size_t _Count2) noexcept {
    ;
    if constexpr (sizeof(_Ty1) == 1) {
        return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_find_end_1(_First1, _Last1, _First2, _Count2)));
    } else if constexpr (sizeof(_Ty1) == 2) {
        return const_cast<_Ty1*>(static_cast<const _Ty1*>(::__std_find_end_2(_First1, _Last1, _First2, _Count2)));
    } else {
        ; 
    }
}

template <class _Ty>
_Ty* _Min_element_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_f(_First, _Last, false)));
    } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_d(_First, _Last, false)));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_8(_First, _Last, _Signed)));
    } else {
        ; 
    }
}

template <class _Ty>
_Ty* _Max_element_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_f(_First, _Last, false)));
    } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_d(_First, _Last, false)));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_8(_First, _Last, _Signed)));
    } else {
        ; 
    }
}

template <class _Ty>
auto _Min_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_pointer_v<_Ty>) {

        return reinterpret_cast<void*>(::__std_min_8u(_First, _Last));


#line 323 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    } else if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return ::__std_min_f(_First, _Last);
    } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return ::__std_min_d(_First, _Last);
    } else if constexpr (sizeof(_Ty) == 1) {
        if constexpr (_Signed) {
            return ::__std_min_1i(_First, _Last);
        } else {
            return ::__std_min_1u(_First, _Last);
        }
    } else if constexpr (sizeof(_Ty) == 2) {
        if constexpr (_Signed) {
            return ::__std_min_2i(_First, _Last);
        } else {
            return ::__std_min_2u(_First, _Last);
        }
    } else if constexpr (sizeof(_Ty) == 4) {
        if constexpr (_Signed) {
            return ::__std_min_4i(_First, _Last);
        } else {
            return ::__std_min_4u(_First, _Last);
        }
    } else if constexpr (sizeof(_Ty) == 8) {
        if constexpr (_Signed) {
            return ::__std_min_8i(_First, _Last);
        } else {
            return ::__std_min_8u(_First, _Last);
        }
    } else {
        ; 
    }
}

template <class _Ty>
auto _Max_vectorized(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_pointer_v<_Ty>) {

        return reinterpret_cast<void*>(::__std_max_8u(_First, _Last));


#line 366 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    } else if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return ::__std_max_f(_First, _Last);
    } else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return ::__std_max_d(_First, _Last);
    } else if constexpr (sizeof(_Ty) == 1) {
        if constexpr (_Signed) {
            return ::__std_max_1i(_First, _Last);
        } else {
            return ::__std_max_1u(_First, _Last);
        }
    } else if constexpr (sizeof(_Ty) == 2) {
        if constexpr (_Signed) {
            return ::__std_max_2i(_First, _Last);
        } else {
            return ::__std_max_2u(_First, _Last);
        }
    } else if constexpr (sizeof(_Ty) == 4) {
        if constexpr (_Signed) {
            return ::__std_max_4i(_First, _Last);
        } else {
            return ::__std_max_4u(_First, _Last);
        }
    } else if constexpr (sizeof(_Ty) == 8) {
        if constexpr (_Signed) {
            return ::__std_max_8i(_First, _Last);
        } else {
            return ::__std_max_8u(_First, _Last);
        }
    } else {
        ; 
    }
}

template <size_t _Element_size>
inline size_t 
    _Mismatch_vectorized(const void* const _First1, const void* const _First2, const size_t _Count) noexcept {
    if constexpr (_Element_size == 1) {
        return __std_mismatch_1(_First1, _First2, _Count);
    } else if constexpr (_Element_size == 2) {
        return __std_mismatch_2(_First1, _First2, _Count);
    } else if constexpr (_Element_size == 4) {
        return __std_mismatch_4(_First1, _First2, _Count);
    } else if constexpr (_Element_size == 8) {
        return __std_mismatch_8(_First1, _First2, _Count);
    } else {
        ; 
    }
}
} 

#line 417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 namespace std {

template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { 
    using type = _First;
};

template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { 
    using type = _Ty<_Newfirst, _Rest...>;
};

template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};










#line 466 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Ty, class... _Types>
inline void _Construct_in_place(_Ty& _Obj, _Types&&... _Args)
    noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {




#line 475 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    {
        ::new (static_cast<void*>(::std:: addressof(_Obj))) _Ty(::std:: forward<_Types>(_Args)...);
    }
}

template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
    ::new (static_cast<void*>(::std:: addressof(_Obj))) _Ty;
}

template <class _Ty, class _Elem>
struct _Ptr_traits_base {
    using pointer         = _Ty;
    using element_type    = _Elem;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<_Elem>, char, _Elem>&;

    [[nodiscard]] static inline pointer pointer_to(_Reftype _Val)
        noexcept(noexcept(_Ty::pointer_to(_Val)))  { 
        return _Ty::pointer_to(_Val);
    }
};

template <class, class = void, class = void>
struct _Ptr_traits_sfinae_layer {};

template <class _Ty, class _Uty>
struct _Ptr_traits_sfinae_layer<_Ty, _Uty, void_t<typename _Get_first_parameter<_Ty>::type>>
    : _Ptr_traits_base<_Ty, typename _Get_first_parameter<_Ty>::type> {};

template <class _Ty>
struct _Ptr_traits_sfinae_layer<_Ty, void_t<typename _Ty::element_type>, void>
    : _Ptr_traits_base<_Ty, typename _Ty::element_type> {};

 template <class _Ty>
struct pointer_traits : _Ptr_traits_sfinae_layer<_Ty> {};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer         = _Ty*;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

    [[nodiscard]] static inline pointer pointer_to(_Reftype _Val) noexcept {
        return ::std:: addressof(_Val);
    }
};































#line 563 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Ty = void>
struct plus {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};

 template <class _Ty = void>
struct minus {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};

 template <class _Ty = void>
struct multiplies {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};

 template <class _Ty = void>
struct equal_to {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left == _Right)))  {
        return _Left == _Right;
    }
};

 template <class _Ty = void>
struct not_equal_to {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left != _Right)))  {
        return _Left != _Right;
    }
};

 template <class _Ty = void>
struct greater {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left > _Right)))  {
        return _Left > _Right;
    }
};

 template <class _Ty = void>
struct greater_equal {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left >= _Right)))  {
        return _Left >= _Right;
    }
};

 template <class _Ty = void>
struct less_equal {
    using first_argument_type   = _Ty;
    using second_argument_type  = _Ty;
    using result_type           = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left <= _Right)))  {
        return _Left <= _Right;
    }
};

template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <class _Fx>
struct _Ref_fn { 
    

    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) noexcept(
        _Select_invoke_traits<_Fx&, _Args...>::_Is_nothrow_invocable::value) { 
        if constexpr (is_member_pointer_v<_Fx>) {
            return ::std:: invoke(_Fn, ::std:: forward<_Args>(_Vals)...);
        } else {
            return _Fn(::std:: forward<_Args>(_Vals)...);
        }
    }

    _Fx& _Fn;
};

template <class _Fn>
[[nodiscard]] constexpr auto _Pass_fn(_Fn& _Func) noexcept {
    constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
        is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
    if constexpr (_Pass_by_value) {
        return _Func;
    } else {
        return _Ref_fn<_Fn>{_Func}; 
    }
}












#line 793 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

struct _Unused_parameter { 
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;



















































































































































































































































































































































































































































#line 1238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template <class _Iter>
using _Iter_ref_t = typename iterator_traits<_Iter>::reference;

template <class _Iter>
using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

template <class _Iter>
using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

template <class _Ty>
using _Make_unsigned_like_t = make_unsigned_t<_Ty>;
#line 1250 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;










#line 1267 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template <class _Ty, class = void>
constexpr bool _Is_iterator_v = false;

template <class _Ty>
constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};
#line 1276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Iter>
constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

template <class _Iter>
constexpr bool _Is_ranges_input_iter_v =


#line 1285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    _Is_cpp17_input_iter_v<_Iter>;

template <class _Iter>
constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

template <class _Iter>
constexpr bool _Is_ranges_fwd_iter_v =


#line 1295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    _Is_cpp17_fwd_iter_v<_Iter>;

template <class _Iter>
constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

template <class _Iter>
constexpr bool _Is_ranges_bidi_iter_v =


#line 1305 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    _Is_cpp17_bidi_iter_v<_Iter>;

template <class _Iter>
constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

template <class _Iter>
constexpr bool _Is_ranges_random_iter_v =


#line 1315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    _Is_cpp17_random_iter_v<_Iter>;









template <class, class = void>
struct _Is_checked_helper {}; 


template <class _Ty>
constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {
    
    if (!(_First <= _Last)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 1332, 0, "%s", "transposed pointer range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
}
#line 1335 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Iter, class = void>
constexpr bool _Allow_inheriting_unwrap_v = true;

template <class _Iter>
constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
    is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

template <class _Iter, class _Sentinel = _Iter, class = void>
constexpr bool _Range_verifiable_v = false;

template <class _Iter, class _Sentinel>
constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>> =
    _Allow_inheriting_unwrap_v<_Iter>;

template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
    
    if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {

        if (!(_First <= _Last)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 1356, 0, "%s", "transposed pointer range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1358 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}

template <class _Iter, class = void>
constexpr bool _Unwrappable_v = false;

template <class _Iter>
constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(::std:: declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std:: declval<_Iter>()._Unwrapped()))>> =
    _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class = void>
constexpr bool _Has_nothrow_unwrapped = false;
template <class _Iter>
constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(::std:: declval<_Iter>()._Unwrapped())>> =
    noexcept(::std:: declval<_Iter>()._Unwrapped());

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It)
    noexcept(!_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(::std:: _Get_unwrapped(::std:: declval<_Iter>()))>;

template <class _Iter, class = bool>
constexpr bool _Do_unwrap_when_unverified_v = false;

template <class _Iter>
constexpr bool _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
    static_cast<bool>(_Iter::_Unwrap_when_unverified);

template <class _Iter>
constexpr bool _Unwrappable_for_unverified_v =
    _Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<_Iter>()))>;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
constexpr _Diff _Max_possible_v{static_cast<_Make_unsigned_like_t<_Diff>>(-1) >> 1};

template <class _Diff>
constexpr _Diff _Min_possible_v{-_Max_possible_v<_Diff> - 1};

template <class _Iter, class = void>
constexpr bool _Offset_verifiable_v = false;

template <class _Iter>
constexpr bool
    _Offset_verifiable_v<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
        true;

template <class _Iter>
constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class _Diff>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v<_Iter> && _Integer_like<_Diff>) {
        
        using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff     = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);

        if (!(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>) && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 1454, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1455 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        (void) _COff;

        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter, class _UIter, class = void>
constexpr bool _Wrapped_seekable_v = false;

template <class _Iter, class _UIter>
constexpr bool
    _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<_UIter>()))>> =
        true;

template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(::std:: forward<_UIter>(_UIt));
    } else {
        _It = ::std:: forward<_UIter>(_UIt);
    }
}































































#line 1548 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Checked, class _Iter>
[[nodiscard]] constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    
    
    ;
    if constexpr (_Is_ranges_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        return _Distance_unknown{};
    }
}

template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { 
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { 
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;






#line 1580 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"





template <class _Pr, class _Ty1, class _Ty2>
constexpr bool _Enable_debug_lt_pred_order_check = is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>;

template <class _Pr, class _Ty1, class _Ty2, bool _Order_check = _Enable_debug_lt_pred_order_check<_Pr, _Ty1, _Ty2>>
constexpr bool _Debug_lt_pred_order_check_noexcept =
    noexcept(::std:: declval<_Pr&>()(::std:: declval<_Ty2&>(), ::std:: declval<_Ty1&>()));

template <class _Pr, class _Ty1, class _Ty2>
constexpr bool _Debug_lt_pred_order_check_noexcept<_Pr, _Ty1, _Ty2, false> = true;

template <class _Pr, class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right)
    noexcept(noexcept(_Pred(_Left, _Right)) && _Debug_lt_pred_order_check_noexcept<_Pr, _Ty1, _Ty2>) {
    const auto _Result = static_cast<bool>(_Pred(_Left, _Right));

    if constexpr (_Enable_debug_lt_pred_order_check<_Pr, _Ty1, _Ty2>) {
        if (_Result) {
            if (!(!_Pred(_Right, _Left))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 1602, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        }
    }

    return _Result;
}

template <class _InIt, class _Sentinel, class _Pr>
constexpr void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred) {
    
    if constexpr (_Is_ranges_fwd_iter_v<_InIt>) {
        if (_First != _Last) {
            for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
                if (!(!static_cast<bool>(_Pred(*_Next, *_First)))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 1615, 0, "%s", "sequence not ordered")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
            }
        }
    }
}

template <class _OtherIt, class _InIt, class _Pr>
constexpr void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred) {
    
    if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>>) {
        ::std:: _Debug_order_unchecked(_First, _Last, _Pred);
    }
}
#line 1629 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"


 template <class _InIt, class _Diff>
inline void advance(_InIt& _Where, _Diff _Off) { 
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
            if (!(_Off >= 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 1637, 0, "%s", "negative advance of non-bidirectional iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        }

        decltype(auto) _UWhere      = ::std:: _Get_unwrapped_n(::std:: move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(::std:: _Get_unwrapped_n(::std:: move(_Where), _Off))>;

        if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            ::std:: _Seek_wrapped(_Where, ::std:: move(_UWhere));
        }
    }
}

 template <class _InIt>
[[nodiscard]] inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        return _Last - _First; 
    } else {
        ::std:: _Adl_verify_range(_First, _Last);
        auto _UFirst             = ::std:: _Get_unwrapped(_First);
        const auto _ULast        = ::std:: _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { 
    return ++_First;
}

 template <class _InIt>
[[nodiscard]] inline _InIt next(
    _InIt _First, typename iterator_traits<_InIt>::difference_type _Off = 1) { 
    static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");

    ::std:: advance(_First, _Off);
    return _First;
}

template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { 
    return --_First;
}

 template <class _BidIt>
[[nodiscard]] inline _BidIt prev(
    _BidIt _First, typename iterator_traits<_BidIt>::difference_type _Off = 1) { 
    static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    ::std:: advance(_First, -_Off);
    return _First;
}

template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;

template <class _Iter, class _Pointer>
constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> =
    noexcept(::std:: _Fake_copy_init<_Pointer>(::std:: declval<_Iter>().operator->()));

 template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;






#line 1722 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    using iterator_category = _Iter_cat_t<_BidIt>;
#line 1724 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    using value_type      = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer         = typename iterator_traits<_BidIt>::pointer;
    using reference       = _Iter_ref_t<_BidIt>;

    template <class>
    friend class reverse_iterator;

    inline reverse_iterator() = default;

    inline explicit reverse_iterator(_BidIt _Right)
        noexcept(is_nothrow_move_constructible_v<_BidIt>) 
        : current(::std:: move(_Right)) {}

    template <class _Other>


#line 1742 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    inline reverse_iterator(const reverse_iterator<_Other>& _Right)
        noexcept(is_nothrow_constructible_v<_BidIt, const _Other&>) 
        : current(_Right.current) {
    }

    template <class _Other>



#line 1752 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    inline reverse_iterator& operator=(const reverse_iterator<_Other>& _Right)
        noexcept(is_nothrow_assignable_v<_BidIt&, const _Other&>)  {
        current = _Right.current;
        return *this;
    }

    [[nodiscard]] inline _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>)  {
        return current;
    }

    [[nodiscard]] inline reference operator*() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt> && noexcept(*--(::std:: declval<_BidIt&>())))  {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }

    [[nodiscard]] inline pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt> && noexcept(--(::std:: declval<_BidIt&>()))
                 && _Has_nothrow_operator_arrow<_BidIt&, pointer>) 


#line 1774 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        } else {
            return _Tmp.operator->();
        }
    }

    inline reverse_iterator& operator++() noexcept(noexcept(--current))  {
        --current;
        return *this;
    }

    inline reverse_iterator operator++(int) noexcept(is_nothrow_copy_constructible_v<_BidIt> 
                                                           && noexcept(--current))  {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    inline reverse_iterator& operator--() noexcept(noexcept(++current))  {
        ++current;
        return *this;
    }

    inline reverse_iterator operator--(int) noexcept(is_nothrow_copy_constructible_v<_BidIt> 
                                                           && noexcept(++current))  {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    [[nodiscard]] inline reverse_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current - _Off)))  {
        return reverse_iterator(current - _Off);
    }

    inline reverse_iterator& operator+=(const difference_type _Off)
        noexcept(noexcept(current -= _Off))  {
        current -= _Off;
        return *this;
    }

    [[nodiscard]] inline reverse_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current + _Off)))  {
        return reverse_iterator(current + _Off);
    }

    inline reverse_iterator& operator-=(const difference_type _Off)
        noexcept(noexcept(current += _Off))  {
        current += _Off;
        return *this;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const
        noexcept(noexcept(::std:: _Fake_copy_init<reference>(current[_Off])))  {
        return current[static_cast<difference_type>(-_Off - 1)];
    }



















#line 1854 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(
        const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept {
        _Verify_range(_Last._Get_current(), _First.current); 
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (!(_Off != _Min_possible_v<difference_type>)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 1865, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current))) {
        current._Seek_to(_It.current);
    }

    [[nodiscard]] constexpr const _BidIt& _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current()))) 




#line 1903 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left._Get_current() == _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current()))) 




#line 1915 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left._Get_current() != _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current()))) 




#line 1927 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left._Get_current() > _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current()))) 




#line 1939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left._Get_current() < _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current()))) 




#line 1951 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left._Get_current() >= _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline bool operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current()))) 




#line 1963 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left._Get_current() <= _Right._Get_current();
}








#line 1975 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline auto operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    noexcept(noexcept(_Right._Get_current() - _Left._Get_current())) 
    -> decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

 template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
    const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off))  {
    return _Right + _Off;
}

 template <class _BidIt>
[[nodiscard]] inline reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter)
    noexcept(is_nothrow_move_constructible_v<_BidIt>)  {
    return reverse_iterator<_BidIt>(::std:: move(_Iter));
}





#line 2000 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Container>
[[nodiscard]] inline auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin())) 
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] inline auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin())) 
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] inline auto end(_Container& _Cont) noexcept(noexcept(_Cont.end())) 
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Container>
[[nodiscard]] inline auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end())) 
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
    return _Array + _Size;
}

 template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) {
    return ::std:: begin(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) {
    return ::std:: end(_Cont);
}

 template <class _Container>
[[nodiscard]] inline auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin())) 
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] inline auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin())) 
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] inline auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend())) 
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Container>
[[nodiscard]] inline auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend())) 
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) noexcept  {
    return reverse_iterator<_Ty*>(_Array + _Size);
}

 template <class _Ty, size_t _Size>
[[nodiscard]] inline reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) noexcept  {
    return reverse_iterator<_Ty*>(_Array);
}

 template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
 {
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

 template <class _Elem>
[[nodiscard]] inline reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
 {
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

 template <class _Container>
[[nodiscard]] inline auto crbegin(const _Container& _Cont) noexcept(noexcept(::std:: rbegin(_Cont))) 
    -> decltype(::std:: rbegin(_Cont)) {
    return ::std:: rbegin(_Cont);
}

 template <class _Container>
[[nodiscard]] inline auto crend(const _Container& _Cont) noexcept(noexcept(::std:: rend(_Cont))) 
    -> decltype(::std:: rend(_Cont)) {
    return ::std:: rend(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size())) 
    -> decltype(_Cont.size()) {
    return _Cont.size();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept {
    return _Size;
}














#line 2130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Container>
[[nodiscard("This function returns a bool indicating whether the collection is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr auto empty(const _Container& _Cont)
    noexcept(noexcept(_Cont.empty())) 
    -> decltype(_Cont.empty()) {
    return _Cont.empty();
}

 template <class _Ty, size_t _Size>
[[nodiscard("This function returns a bool indicating whether the collection is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(const _Ty (&)[_Size]) noexcept {
    return false;
}

 template <class _Elem>
[[nodiscard("This function returns a bool indicating whether the collection is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.size() == 0;
}

 template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data())) 
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data())) 
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 4185 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; 














#line 4205 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
template <class _Iter>
struct _Move_iterator_category {
    using iterator_category = _Iter_cat_t<_Iter>;
};
#line 4210 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Iter>
class move_iterator : public _Move_iterator_category<_Iter> {
private:
    _Iter _Current{};

public:
    using iterator_type   = _Iter;
    using value_type      = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer         = _Iter;



















#line 4241 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    using reference =
        conditional_t<is_reference_v<_Iter_ref_t<_Iter>>, remove_reference_t<_Iter_ref_t<_Iter>>&&, _Iter_ref_t<_Iter>>;
#line 4244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    inline move_iterator() = default;

    inline explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)) {}

    template <class _Other>


#line 4254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    inline move_iterator(const move_iterator<_Other>& _Right)
        noexcept(is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()) {
    }

    template <class _Other>



#line 4264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    inline move_iterator& operator=(const move_iterator<_Other>& _Right)
        noexcept(is_nothrow_assignable_v<_Iter&, const _Other&>)  {
        _Current = _Right.base();
        return *this;
    }








#line 4278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    [[nodiscard]] inline iterator_type base() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>)  {
        return _Current;
    }
#line 4283 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    [[nodiscard]] inline reference operator*() const




#line 4290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        noexcept(noexcept(static_cast<reference>(*_Current)))  {
        return static_cast<reference>(*_Current);
    }
#line 4294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

     [[nodiscard]] inline pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>)  {
        return _Current;
    }

    inline move_iterator& operator++() noexcept(noexcept(++_Current))  {
        ++_Current;
        return *this;
    }

    inline auto operator++(int) noexcept(is_nothrow_copy_constructible_v<_Iter> 
                                               && noexcept(++_Current))  {


#line 4310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;




#line 4318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    }

    inline move_iterator& operator--() noexcept(noexcept(--_Current))  {
        --_Current;
        return *this;
    }

    inline move_iterator operator--(int) noexcept(is_nothrow_copy_constructible_v<_Iter> 
                                                        && noexcept(--_Current))  {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept 
        -> decltype(::std:: declval<const _Iter2&>() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept 
        -> decltype(::std:: declval<const _Iter2&>() != _Sentinel) {
        return _Current != _Sentinel;
    }

    [[nodiscard]] inline move_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current + _Off)))  {
        return move_iterator(_Current + _Off);
    }

    inline move_iterator& operator+=(const difference_type _Off)
        noexcept(noexcept(_Current += _Off))  {
        _Current += _Off;
        return *this;
    }

    [[nodiscard]] inline move_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current - _Off)))  {
        return move_iterator(_Current - _Off);
    }

    inline move_iterator& operator-=(const difference_type _Off)
        noexcept(noexcept(_Current -= _Off))  {
        _Current -= _Off;
        return *this;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const



#line 4371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        noexcept(noexcept(::std:: move(_Current[_Off])))  {
        return ::std:: move(_Current[_Off]);
#line 4374 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    }






























#line 4406 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_current());
    }






#line 4418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _Current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
        _Current._Seek_to(_It._Get_current());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src>&& _It)
        noexcept(noexcept(_Current._Seek_to(::std:: move(_It)._Get_current()))) {
        _Current._Seek_to(::std:: move(_It)._Get_current());
    }

    [[nodiscard]] constexpr const iterator_type& _Get_current() const& noexcept {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type&& _Get_current() && noexcept {
        return ::std:: move(_Current);
    }
};

 template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left.base() == _Right.base()))) 




#line 4465 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left.base() == _Right.base();
}


template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator!=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    noexcept(noexcept(_Left == _Right))  {
    return !(_Left == _Right);
}
#line 4476 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    noexcept(noexcept(::std:: _Fake_copy_init<bool>(_Left.base() < _Right.base()))) 




#line 4485 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Left.base() < _Right.base();
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    noexcept(noexcept(_Right < _Left)) 


#line 4495 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return _Right < _Left;
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator<=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    noexcept(noexcept(_Right < _Left)) 


#line 4505 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return !(_Right < _Left);
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] inline bool operator>=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    noexcept(noexcept(_Left < _Right)) 


#line 4515 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return !(_Left < _Right);
}







#line 4526 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] inline auto operator-(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    noexcept(noexcept(_Left.base() - _Right.base())) 
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

 template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter> operator+(
    typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right)
    noexcept(noexcept(move_iterator<_Iter>(_Right.base() + _Off))) 




#line 4543 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
{
    return move_iterator<_Iter>(_Right.base() + _Off);
}

 template <class _Iter>
[[nodiscard]] inline move_iterator<_Iter> make_move_iterator(_Iter _It)
    noexcept(is_nothrow_move_constructible_v<_Iter>)  {
    return move_iterator<_Iter>(::std:: move(_It));
}




















































#line 4605 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"














#line 4620 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Iter>
constexpr bool _Iterator_is_contiguous = is_pointer_v<_Iter>;

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const _Iter& _Val) noexcept {
    ;
    return _Val;
}
#line 4630 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept {
    return _To_address(_Val.base());
}



template <class _Iter1, class _Iter2>
constexpr bool _Iterators_are_contiguous = _Iterator_is_contiguous<_Iter1> && _Iterator_is_contiguous<_Iter2>;

template <class _Iter>
constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;

template <class _Source, class _Dest>
constexpr bool _Is_pointer_address_convertible = is_void_v<_Source>
                                              || is_void_v<_Dest>
                                              
                                              || is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>



    ;

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat {
    using _USource = _Unwrap_enum_t<_Source>;
    using _UDest   = _Unwrap_enum_t<_Dest>;

    static constexpr bool _Same_size_and_compatible =
        sizeof(_Source) == sizeof(_Dest)
        
        
        
        && is_same_v<bool, _USource> >= is_same_v<bool, _UDest>
        && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>)
            || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>) );

    static constexpr bool _Bitcopy_constructible =
        _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
    static constexpr bool _Bitcopy_constructible =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_constructible_v<_Dest*, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

struct _False_trivial_cat {
    static constexpr bool _Bitcopy_constructible = false;
    static constexpr bool _Bitcopy_assignable    = false;
};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
                        && !_Iterator_is_volatile<_DestIt>>
struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
                            remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
                        && !_Iterator_is_volatile<_DestIt>>
struct _Iter_copy_cat
    : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _Iter1, class _Sent1, class _Iter2>
inline void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2) {

    if constexpr (_Iterators_are_contiguous<_Iter1, _Iter2>


#line 4720 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    ) {




#line 4726 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

        const auto _Offset     = _Last1 - _First1;
        const auto _Ptr1Offset = _Offset * sizeof(*::std:: _To_address(_First1));
        const auto _Ptr2Offset = _Offset * sizeof(*::std:: _To_address(_First2));
        
        
        const auto _PtrFirst1 = reinterpret_cast<const volatile char*>(::std:: _To_address(_First1));
        const auto _PtrLast1  = _PtrFirst1 + _Ptr1Offset;
        const auto _PtrFirst2 = reinterpret_cast<const volatile char*>(::std:: _To_address(_First2));
        const auto _PtrLast2  = _PtrFirst2 + _Ptr2Offset;
        if (!(_PtrLast1 <= _PtrFirst2 || _PtrLast2 <= _PtrFirst1)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 4736, 0, "%s", "ranges should not overlap each other")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
    }




#line 4743 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
}

template <class _OutCtgIt>
_OutCtgIt _Copy_memmove_tail(
    const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {
    ;
    const auto _Dest_ptr = ::std:: _To_address(_Dest);
    const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
    :: memmove(_Dest_ch, _First_ch, _Byte_count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        (void) _Object_count;
        
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);
    } else {
        return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
    }
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    ;
    const auto _First_ptr    = ::std:: _To_address(_First);
    const auto _Last_ptr     = ::std:: _To_address(_Last);
    const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);
    const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
    const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
    const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
    return ::std:: _Copy_memmove_tail(_First_ch, ::std:: move(_Dest), _Byte_count, _Object_count);
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest) {
    const auto _First_ptr  = ::std:: _To_address(_First);
    const auto _First_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
    const auto _Byte_count = _Object_count * sizeof(*_First_ptr);
    return ::std:: _Copy_memmove_tail(_First_ch, ::std:: move(_Dest), _Byte_count, _Object_count);
}

template <class _It, bool _RequiresMutable = false>
constexpr bool _Is_vb_iterator = false;

template <class _VbIt, class _OutIt>
inline _OutIt _Copy_vbool(_VbIt _First, _VbIt _Last, _OutIt _Dest);

template <class _VbIt>
[[nodiscard]] inline _Iter_diff_t<_VbIt> _Count_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;

template <class _VbIt>
inline void _Fill_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;

template <class _VbIt>
[[nodiscard]] inline _VbIt _Find_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;

template <class _InIt, class _SizeTy, class _OutIt>
inline _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
    
    
    ;
    ;

    if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {


#line 4807 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
        }
    }

    for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
        *_Dest = *_First;
    }

    return _Dest;
}

template <class _InIt, class _Sent, class _OutIt>
using _Sent_copy_cat = conditional_t<


#line 4824 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    is_same_v<_Sent, _InIt>,
#line 4826 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;

template <class _InIt, class _Sent, class _OutIt>
inline _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
    
    
    if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
        return ::std:: _Copy_vbool(_First, _Last, _Dest);
    } else {
        if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {


#line 4839 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
            {




#line 4845 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
                {
                    return ::std:: _Copy_memmove(_First, _Last, _Dest);
                }
            }
        }

        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = *_First;
        }

        return _Dest;
    }
}

 template <class _InIt, class _OutIt>
inline _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    ::std:: _Adl_verify_range(_First, _Last);
    const auto _UFirst = ::std:: _Get_unwrapped(_First);
    const auto _ULast  = ::std:: _Get_unwrapped(_Last);
    auto _UDest        = ::std:: _Get_unwrapped_n(::std:: move(_Dest), ::std:: _Idl_distance<_InIt>(_UFirst, _ULast));
    ::std:: _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst, _ULast, ::std:: move(_UDest)));
    return _Dest;
}










#line 4879 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"






















































































































































#line 5030 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _InIt, class _Diff, class _OutIt>
inline _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
            return ::std:: _Copy_vbool(_First, _First + _Count, _Dest);
        } else {
            auto _UFirst = ::std:: _Get_unwrapped_n(_First, _Count);
            auto _UDest  = ::std:: _Get_unwrapped_n(_Dest, _Count);
            if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {


#line 5045 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
                {
                    _UDest = ::std:: _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
                    ::std:: _Seek_wrapped(_Dest, _UDest);
                    return _Dest;
                }
            }

            for (;;) {
                *_UDest = *_UFirst;
                ++_UDest;
                --_Count;
                
                if (_Count == 0) {
                    break;
                }

                ++_UFirst;
            }

            ::std:: _Seek_wrapped(_Dest, _UDest);
        }
    }

    return _Dest;
}










#line 5081 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    
    const auto _First_ptr = ::std:: _To_address(_First);
    const auto _Last_ptr  = ::std:: _To_address(_Last);
    const auto _Dest_ptr  = ::std:: _To_address(_Dest);
    const auto _First_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
    const auto _Last_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
    const auto _Dest_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
    const auto _Count     = static_cast<size_t>(_Last_ch - _First_ch);
    const auto _Result    = :: memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    } else {
        return _Dest - static_cast<_Iter_diff_t<_CtgIt2>>(_Last_ptr - _First_ptr);
    }
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return ::std:: _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _BidIt1, class _BidIt2>
[[nodiscard]] inline _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {


#line 5112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            return ::std:: _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
inline _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    const auto _UFirst = ::std:: _Get_unwrapped(_First);
    const auto _ULast  = ::std:: _Get_unwrapped(_Last);
    const auto _UDest  = ::std:: _Get_unwrapped_n(_Dest, -::std:: _Idl_distance<_BidIt1>(_UFirst, _ULast));
    ::std:: _Seek_wrapped(_Dest, ::std:: _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _OutIt>
inline _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
        return ::std:: _Copy_vbool(_First, _Last, _Dest);
    } else {
        if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {


#line 5146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
            {
                return ::std:: _Copy_memmove(_First, _Last, _Dest);
            }
        }

        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = ::std:: move(*_First);
        }

        return _Dest;
    }
}

 template <class _InIt, class _OutIt>
inline _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    const auto _UFirst = ::std:: _Get_unwrapped(_First);
    const auto _ULast  = ::std:: _Get_unwrapped(_Last);
    const auto _UDest  = ::std:: _Get_unwrapped_n(_Dest, ::std:: _Idl_distance<_InIt>(_UFirst, _ULast));
    ::std:: _Seek_wrapped(_Dest, ::std:: _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}










#line 5180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _BidIt1, class _BidIt2>
inline _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    
    if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {


#line 5189 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            return ::std:: _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = ::std:: move(*--_Last);
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
inline _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    const auto _UFirst = ::std:: _Get_unwrapped(_First);
    const auto _ULast  = ::std:: _Get_unwrapped(_Last);
    const auto _UDest  = ::std:: _Get_unwrapped_n(_Dest, -::std:: _Idl_distance<_BidIt1>(_UFirst, _ULast));
    ::std:: _Seek_wrapped(_Dest, ::std:: _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _Ty>
struct _Is_character : false_type {}; 

template <>
struct _Is_character<char> : true_type {}; 

template <>
struct _Is_character<signed char> : true_type {}; 

template <>
struct _Is_character<unsigned char> : true_type {}; 






template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {};

template <>
struct _Is_character_or_bool<bool> : true_type {};

template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};








template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
constexpr bool _Fill_zero_memset_is_safe =
    conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    :: memset(::std:: _To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}

template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    :: memset(::std:: _To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}

template <class _Ty>
[[nodiscard]] bool _Is_all_bits_zero(const _Ty& _Val) {
    
    ;
    if constexpr (is_same_v<_Ty, nullptr_t>) {
        return true;
    } else {
        constexpr _Ty _Zero{};
        return :: memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
    }
}

 template <class _FwdIt, class _Ty>
inline void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        ::std:: _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = ::std:: _Get_unwrapped(_First);
        const auto _ULast = ::std:: _Get_unwrapped(_Last);


#line 5297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                ::std:: _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (::std:: _Is_all_bits_zero(_Val)) {
                    ::std:: _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}









#line 5324 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _OutIt, class _Diff, class _Ty>
inline _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            ::std:: _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = ::std:: _Get_unwrapped_n(_Dest, _Count);


#line 5339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    ::std:: _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    ::std:: _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (::std:: _Is_all_bits_zero(_Val)) {
                        ::std:: _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        ::std:: _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            ::std:: _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}









#line 5372 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"





































#line 5410 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Ty1, class _Ty2, class = void>
constexpr bool _Can_compare_with_operator_equal = false;

template <class _Ty1, class _Ty2>
constexpr bool
    _Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>())>> =
        true;

template <class _Ty1, class _Ty2>
constexpr bool _Is_pointer_address_comparable =
    _Can_compare_with_operator_equal<_Ty1*, _Ty2*>
    && (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);








#pragma warning(push)
#pragma warning(disable : 4806) 
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1> && is_integral_v<_Elem2>>
constexpr bool _Can_memcmp_elements =
    is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)











template <class _Ty1, class _Ty2>
constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;

template <class _Elem1, class _Elem2>
constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;




template <class _Elem1, class _Elem2, class _Pr>
constexpr bool _Can_memcmp_elements_with_pred = false;



template <class _Elem1, class _Elem2, class _Elem3>
constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> =
    _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible
    && _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;


template <class _Elem1, class _Elem2>
constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> = _Can_memcmp_elements<_Elem1, _Elem2>;





#line 5477 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"




template <class _Iter1, class _Iter2, class _Pr>
constexpr bool _Equal_memcmp_is_safe_helper =
    _Iterators_are_contiguous<_Iter1, _Iter2> && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2>
    && _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;

template <class _Iter1, class _Iter2, class _Pr>
constexpr bool _Equal_memcmp_is_safe =
    _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, remove_const_t<_Pr>>;


template <class _It1, class _It2, class _Pr>
constexpr bool _Vector_alg_in_search_is_safe = _Equal_memcmp_is_safe<_It1, _It2, _Pr> 
                                            && sizeof(_Iter_value_t<_It1>) <= 2; 

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(::std:: _To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(::std:: _To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    
    ::std:: _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = ::std:: _Get_unwrapped(_First1);
    const auto _ULast1 = ::std:: _Get_unwrapped(_Last1);
    auto _UFirst2      = ::std:: _Get_unwrapped_n(_First2, ::std:: _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {


#line 5514 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            ;
#line 5517 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
            const auto _First1_ch = reinterpret_cast<const char*>(::std:: _To_address(_UFirst1));
            const auto _Size      = reinterpret_cast<const char*>(::std:: _To_address(_ULast1)) - _First1_ch;
            return :: memcmp(_First1_ch, ::std:: _To_address(_UFirst2), static_cast<size_t>(_Size)) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}





#line 5537 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>{});
}








#line 5552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    ::std:: _Adl_verify_range(_First1, _Last1);
    ::std:: _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = ::std:: _Get_unwrapped(_First1);
    const auto _ULast1 = ::std:: _Get_unwrapped(_Last1);
    auto _UFirst2      = ::std:: _Get_unwrapped(_First2);
    const auto _ULast2 = ::std:: _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, ::std:: _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}





#line 5594 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
}








#line 5610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"




















































































































































#line 5759 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Elem1, class _Elem2>
constexpr bool _Lex_compare_memcmp_classify_elements =

    is_integral_v<_Elem1> && is_integral_v<_Elem2> && sizeof(_Elem1) == sizeof(_Elem2)
    && is_unsigned_v<_Elem1> == is_unsigned_v<_Elem2>;



#line 5769 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"






template <class _Elem1, class _Elem2, class _Pr>
struct _Lex_compare_memcmp_classify_pred {
    using _Pred = void;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        greater<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};











#line 5817 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _It1, class _It2, class _Pr>
using _Lex_compare_memcmp_classify =
    conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
        typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] inline bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    ::std:: _Adl_verify_range(_First1, _Last1);
    ::std:: _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = ::std:: _Get_unwrapped(_First1);
    const auto _ULast1 = ::std:: _Get_unwrapped(_Last1);
    auto _UFirst2      = ::std:: _Get_unwrapped(_First2);
    const auto _ULast2 = ::std:: _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
    if constexpr (!is_void_v<_Memcmp_pred>) {


#line 5839 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            const auto _Num1  = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2  = static_cast<size_t>(_ULast2 - _UFirst2);
            const size_t _Num = (::std:: min)(_Num1, _Num2);

            const auto _First1_ptr = ::std:: _To_address(_UFirst1);
            const auto _First2_ptr = ::std:: _To_address(_UFirst2);
            const size_t _Pos      = _Mismatch_vectorized<sizeof(*_First1_ptr)>(_First1_ptr, _First2_ptr, _Num);
            if (_Pos == _Num2) {
                return false;
            } else if (_Pos == _Num1) {
                return true;
            } else {
                return _Pred(_First1_ptr[_Pos], _First2_ptr[_Pos]);
            }



#line 5858 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        }
    }

    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { 
        if (::std:: _Debug_lt_pred(_Pred, *_UFirst1, *_UFirst2)) {
            return true;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            return false;
        }
    }

    return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] inline bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
}





















#line 5900 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"




















































































































#line 6017 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Ty, class _Elem>
struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
template <class _Ty1, class _Ty2>
struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
    : conjunction<
          
          disjunction<is_object<_Ty1>, is_void<_Ty1>>,
          
          disjunction<is_object<_Ty2>, is_void<_Ty2>>,
          
          disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};


template <class _Ty, class _Elem>
constexpr bool _Vector_alg_in_find_is_safe_elem = disjunction_v<




    
    
    conjunction<is_integral<_Ty>, is_integral<_Elem>>,
    
    conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
    
    conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
    
    
    
    _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;


template <class _Iter, class _Ty>
constexpr bool _Vector_alg_in_find_is_safe =
    
    _Iterator_is_contiguous<_Iter>
    
    && !_Iterator_is_volatile<_Iter>
    
    && _Vector_alg_in_find_is_safe_elem<_Ty, _Iter_value_t<_Iter>>;

template <class _InIt, class _Ty>
[[nodiscard]] constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
    
    ;

    if constexpr (disjunction_v<



                      is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
        return true;
    } else {
        using _Elem = _Iter_value_t<_InIt>;
        ;

        if constexpr (is_same_v<_Elem, bool>) {
            return _Val == true || _Val == false;
        } else if constexpr (is_signed_v<_Elem>) {
            constexpr _Elem _Min = ::std:: _Min_limit<_Elem>();
            constexpr _Elem _Max = ::std:: _Max_limit<_Elem>();

            if constexpr (is_signed_v<_Ty>) {
                
                return _Min <= _Val && _Val <= _Max;
            } else {
                
                if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
                    
                    return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
                } else {
                    
                    return _Val <= _Max;
                }
            }
        } else {
            constexpr _Elem _Max = ::std:: _Max_limit<_Elem>();

            if constexpr (is_unsigned_v<_Ty>) {
                
                return _Val <= _Max;
            } else {
                
                if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
                    
                    return _Val <= _Max;
                } else {
                    
                    return 0 <= _Val && _Val <= _Max;
                }
            }
        }
    }
}

template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    
    if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {


#line 6121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            if (!::std:: _Could_compare_equal_to_value_type<_InIt>(_Val)) {
                return _Last;
            }

            const auto _First_ptr = ::std:: _To_address(_First);
            const auto _Result    = ::std:: _Find_vectorized(_First_ptr, ::std:: _To_address(_Last), _Val);
            if constexpr (is_pointer_v<_InIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }






















#line 6156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        }
    }

    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

 template <class _InIt, class _Ty>
[[nodiscard]] inline _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { 
    ::std:: _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return ::std:: _Find_vbool(_First, _Last, _Val);
    } else {
        ::std:: _Seek_wrapped(_First, ::std:: _Find_unchecked(::std:: _Get_unwrapped(_First), ::std:: _Get_unwrapped(_Last), _Val));
        return _First;
    }
}




#line 6183 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"














































































































#line 6294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _InIt, class _Ty>
[[nodiscard]] inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return ::std:: _Count_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = ::std:: _Get_unwrapped(_First);
        const auto _ULast = ::std:: _Get_unwrapped(_Last);


        if constexpr (_Vector_alg_in_find_is_safe<decltype(_UFirst), _Ty>) {


#line 6310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
            {
                if (!::std:: _Could_compare_equal_to_value_type<decltype(_UFirst)>(_Val)) {
                    return 0;
                }

                return static_cast<_Iter_diff_t<_InIt>>(
                    ::std:: _Count_vectorized(::std:: _To_address(_UFirst), ::std:: _To_address(_ULast), _Val));
            }
        }
#line 6320 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

        _Iter_diff_t<_InIt> _Count = 0;

        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }

        return _Count;
    }
}





#line 6338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

enum class _TrimResult : unsigned char { _KeepTrimming, _HaveWorkAfterTrimming, _ReturnFalse, _ReturnTrue };

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] inline _TrimResult _Trim_equal(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
    ;
    ;
    if (_Pred(*_First1, *_First2)) {
        do {
            ++_First1;
            ++_First2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_First2));
    } else {
        if (!_Pred(*_Back1, *_Back2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        --_Back2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        --_Back2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] inline _TrimResult _Trim_reversed(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
    ;
    ;
    if (_Pred(*_First1, *_Back2)) {
        do {
            ++_First1;
            --_Back2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_Back2));
    } else {
        if (!_Pred(*_Back1, *_First2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        ++_First2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        ++_First2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] inline _TrimResult _Trim_completely(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    _TrimResult _Res = _TrimResult::_KeepTrimming;

    for (bool _Check_reversed = true; _Res == _TrimResult::_KeepTrimming; _Check_reversed = !_Check_reversed) {
        if (_Check_reversed) {
            _Res = ::std:: _Trim_reversed(_First1, _Back1, _First2, _Back2, _Pred);
        } else {
            _Res = ::std:: _Trim_equal(_First1, _Back1, _First2, _Back2, _Pred);
        }
    }

    return _Res;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] inline bool _Check_match_counts(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
    ;
    ;
    if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
        do { 
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));

        if (_First1 == _Last1) {
            return false;
        }

        const _TrimResult _Res = ::std:: _Trim_completely(_First1, _Last1, _First2, _Last2, _Pred);

        if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
            return _Res == _TrimResult::_ReturnTrue;
        }

        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == ::std:: _Find_pr(_First1, _Next1, *_Next1, _Pred)) { 
            _Iter_diff_t<_FwdIt2> _Count2 = ::std:: _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; 
            }

            _FwdIt1 _Skip1                = ::std:: _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = ::std:: _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; 
            }
        }
    }

    return true;
}

 template <class _BidIt>
inline void reverse(const _BidIt _First, const _BidIt _Last) { 
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst = ::std:: _Get_unwrapped(_First);
    auto _ULast  = ::std:: _Get_unwrapped(_Last);

    using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {


#line 6519 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            ::std:: _Reverse_vectorized<_Nx>(::std:: _To_address(_UFirst), ::std:: _To_address(_ULast));
            return;
        }
    }
#line 6525 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        swap(*_UFirst, *_ULast); 
    }
}









#line 6540 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    
    while (_First != _Sentinel && _Last != _Sentinel) {
        swap(*_First, *--_Last); 
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}

 template <class _FwdIt>
inline _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    
    
    
    ::std:: _Adl_verify_range(_First, _Mid);
    ::std:: _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = ::std:: _Get_unwrapped(_First);
    auto _UMid        = ::std:: _Get_unwrapped(_Mid);
    const auto _ULast = ::std:: _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        ::std:: _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = ::std:: _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        ::std:: _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { 
            swap(*_UFirst, *_UNext); 
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        ::std:: _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { 
            _UNext = _UMid;
            do {
                swap(*_UFirst, *_UNext); 
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}









#line 6617 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _InIt, class _Pr>
[[nodiscard]] inline _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { 
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst      = ::std:: _Get_unwrapped(_First);
    const auto _ULast = ::std:: _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    ::std:: _Seek_wrapped(_First, _UFirst);
    return _First;
}
































































































































































































































































































































#line 6953 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _Iter, class _Pr, class _Elem = _Iter_value_t<_Iter>>
constexpr bool _Is_min_max_optimization_safe = 
    _Iterator_is_contiguous<_Iter> 
    && !_Iterator_is_volatile<_Iter> 
    && conjunction_v<disjunction<



#line 6963 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
                         is_floating_point<_Elem>, 
#line 6965 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
#line 6966 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
                         is_integral<_Elem>, is_pointer<_Elem>>, 
        disjunction< 


#line 6971 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
            is_same<_Pr, less<>>, is_same<_Pr, less<_Elem>>>>; 












template <class _Iter, class _Pr, class _Elem = _Iter_value_t<_Iter>>
constexpr bool _Is_min_max_value_optimization_safe = 

    !is_floating_point_v<_Elem> &&
#line 6989 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    _Is_min_max_optimization_safe<_Iter, _Pr, _Elem>;

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = ::std:: _To_address(_First);
            const auto _Result    = ::std:: _Max_element_vectorized(_First_ptr, ::std:: _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 7006 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (::std:: _Debug_lt_pred(_Pred, *_Found, *_First)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    ::std:: _Adl_verify_range(_First, _Last);
    ::std:: _Seek_wrapped(_First,
        ::std:: _Max_element_unchecked(::std:: _Get_unwrapped(_First), ::std:: _Get_unwrapped(_Last), ::std:: _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: max_element(_First, _Last, less<>{});
}


















































































#line 7114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    if (!(_Ilist.size() != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 7119, 0, "%s", "An initializer_list passed to std::max must not be empty. (N4971 [alg.min.max]/13)")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 7120 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    if constexpr (_Is_min_max_value_optimization_safe<const _Ty*, _Pr>) {
        if (!_Is_constant_evaluated()) {
            return static_cast<_Ty>(::std:: _Max_vectorized(_Ilist.begin(), _Ilist.end()));
        }
    }
#line 7127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    const _Ty* _Res = ::std:: _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), ::std:: _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: max)(_Ilist, less<>{});
}













































































#line 7214 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = ::std:: _To_address(_First);
            const auto _Result    = ::std:: _Min_element_vectorized(_First_ptr, ::std:: _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 7230 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (::std:: _Debug_lt_pred(_Pred, *_First, *_Found)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    ::std:: _Adl_verify_range(_First, _Last);
    ::std:: _Seek_wrapped(_First,
        ::std:: _Min_element_unchecked(::std:: _Get_unwrapped(_First), ::std:: _Get_unwrapped(_Last), ::std:: _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: min_element(_First, _Last, less<>{});
}


















































































#line 7338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    if (!(_Ilist.size() != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility", 7343, 0, "%s", "An initializer_list passed to std::min must not be empty. (N4971 [alg.min.max]/5)")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 7344 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    if constexpr (_Is_min_max_value_optimization_safe<const _Ty*, _Pr>) {
        if (!_Is_constant_evaluated()) {
            return static_cast<_Ty>(::std:: _Min_vectorized(_Ilist.begin(), _Ilist.end()));
        }
    }
#line 7351 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
    const _Ty* _Res = ::std:: _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), ::std:: _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: min)(_Ilist, less<>{});
}







































































#line 7432 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst                = ::std:: _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, ::std:: _Get_unwrapped(_Last));

    while (0 < _Count) { 
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { 
            _UFirst = ::std:: _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    ::std:: _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: lower_bound(_First, _Last, _Val, less<>{});
}

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst                = ::std:: _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, ::std:: _Get_unwrapped(_Last));

    while (0 < _Count) { 
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid             = ::std:: next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { 
            _UFirst = ::std:: _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    ::std:: _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] inline _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: upper_bound(_First, _Last, _Val, less<>{});
}

template <class _FwdIt1, class _FwdIt2>
inline _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    


    using _Elem1 = remove_reference_t<_Iter_ref_t<_FwdIt1>>;
    using _Elem2 = remove_reference_t<_Iter_ref_t<_FwdIt2>>;
    if constexpr (is_same_v<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1>
                  && _Iterators_are_contiguous<_FwdIt1, _FwdIt2>) {


#line 7501 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
        {
            ::__std_swap_ranges_trivially_swappable_noalias(
                ::std:: _To_address(_First1), ::std:: _To_address(_Last1), ::std:: _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
#line 7508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        swap(*_First1, *_First2); 
    }

    return _First2;
}

extern "C++" [[noreturn]]  void __cdecl _Xbad_alloc();
extern "C++" [[noreturn]]  void __cdecl _Xinvalid_argument(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xlength_error(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xout_of_range(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xoverflow_error(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xruntime_error(  const char*);
extern "C++" [[noreturn]]  void __cdecl _XGetLastError();

 template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*,
    class _Reference = _Ty&>
struct  iterator { 
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};



#line 7537 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"




















#line 7558 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"


























































#line 7617 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"

} 








#pragma warning(pop)
#pragma pack(pop)
#line 7630 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
#line 7631 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xutility"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"



#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )





extern "C" {
void* __stdcall __std_remove_1(void* _First, void* _Last, uint8_t _Val) noexcept;
void* __stdcall __std_remove_2(void* _First, void* _Last, uint16_t _Val) noexcept;
void* __stdcall __std_remove_4(void* _First, void* _Last, uint32_t _Val) noexcept;
void* __stdcall __std_remove_8(void* _First, void* _Last, uint64_t _Val) noexcept;
} 

 namespace std {
template <class _Ty, class _TVal>
_Ty* _Remove_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {
    if constexpr (is_pointer_v<_Ty>) {

        return reinterpret_cast<_Ty*>(::__std_remove_8(_First, _Last, reinterpret_cast<uint64_t>(_Val)));


#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    } else if constexpr (sizeof(_Ty) == 1) {
        return reinterpret_cast<_Ty*>(::__std_remove_1(_First, _Last, static_cast<uint8_t>(_Val)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return reinterpret_cast<_Ty*>(::__std_remove_2(_First, _Last, static_cast<uint16_t>(_Val)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return reinterpret_cast<_Ty*>(::__std_remove_4(_First, _Last, static_cast<uint32_t>(_Val)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return reinterpret_cast<_Ty*>(::__std_remove_8(_First, _Last, static_cast<uint64_t>(_Val)));
    } else {
        ; 
    }
}
} 

#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

 namespace std {
template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { 
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { 
    return _Ptr;
}

template <class _Ptrty>
constexpr auto _Unfancy_maybe_null(_Ptrty _Ptr) noexcept {
    
    return _Ptr ? ::std:: addressof(*_Ptr) : nullptr;
}

template <class _Ty>
constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { 
    return _Ptr;
}

template <class _Ty>
struct [[nodiscard]] _Tidy_guard { 
    _Ty* _Target;
    inline ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};

template <class _Ty>
struct [[nodiscard]] _Tidy_deallocate_guard { 
    _Ty* _Target;
    inline ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};

template <class _Keycmp, class _Lhs, class _Rhs>
constexpr bool _Nothrow_compare = noexcept(
    static_cast<bool>(::std:: declval<const _Keycmp&>()(::std:: declval<const _Lhs&>(), ::std:: declval<const _Rhs&>())));

[[noreturn]] inline void _Throw_bad_array_new_length() {
    throw(bad_array_new_length{});
}

template <size_t _Ty_size>
[[nodiscard]] constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr (_Overflow_is_possible) {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        if (_Count > _Max_possible) {
            _Throw_bad_array_new_length(); 
        }
    }

    return _Count * _Ty_size;
}

template <class _Ty>
constexpr size_t _New_alignof = (::std:: max)(alignof(_Ty), 16ull);





#line 133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

struct _Default_allocate_traits {
    __declspec(allocator) static  void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }













};



constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}


 constexpr size_t _Big_allocation_threshold = 4096;
 constexpr size_t _Big_allocation_alignment = 32;


;


;


 constexpr size_t _Non_user_size = 2 * sizeof(void*) + _Big_allocation_alignment - 1;


#line 174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"


 constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;


#line 180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {
    
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length(); 
    }

    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    if (!(_Ptr_container != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory", 190, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ; 
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;


    static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
#line 197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    return _Ptr;
}

inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {
    
    _Bytes += _Non_user_size;

    const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];

    
    
    if (!(_Ptr_user[-2] == _Big_allocation_sentinel)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory", 209, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;

    
    

    constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);


#line 218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    if (!(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory", 219, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#line 223 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <size_t _Align, class _Traits = _Default_allocate_traits>
__declspec(allocator) inline void* _Allocate(const size_t _Bytes) {
    
    if (_Bytes == 0) {
        return nullptr;
    }





#line 236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"













    {

        if (_Bytes >= _Big_allocation_threshold) {
            
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }
#line 256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        return _Traits::_Allocate(_Bytes);
    }
}

template <size_t _Align>
inline void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {
    





#line 269 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"













    {

        if (_Bytes >= _Big_allocation_threshold) {
            
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
#line 289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        ::operator delete(_Ptr, _Bytes);
    }
}

template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy_maybe_null(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return _Ptr == nullptr ? _Pointer() : pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
inline _Pointer _Refancy_maybe_null(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;

template <class _Ty>
inline void _Destroy_in_place(_Ty& _Obj) noexcept {
    if constexpr (is_array_v<_Ty>) {
        ::std:: _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
    } else {
        _Obj.~_Ty();
    }
}













#line 341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept { 
    using _Elem       = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest       = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}

template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}

template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<void>;
};

template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};

template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const void>;
};

template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};

template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::difference_type;
};

template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};

template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};

template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = bool_constant<is_empty_v<_Ty>>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};
__pragma(warning(pop))

template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
__pragma(warning(pop))

 template <class _Ty>
class allocator;

template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {};

template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type {};




#line 493 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
    disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;

template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
    : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std:: declval<_Alloc&>().allocate(
        ::std:: declval<const _Size_type&>(), ::std:: declval<const _Const_void_pointer&>()))>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_max_size : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {};







#line 552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

 template <class _Alloc>
struct allocator_traits;

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Normal_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer      = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer       = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

    using size_type       = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal                        = typename _Get_is_always_equal<_Alloc>::type;

    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer allocate(
        _Alloc& _Al, __declspec(guard(overflow)) const size_type _Count) {
        return _Al.allocate(_Count);
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer allocate(
        _Alloc& _Al, __declspec(guard(overflow)) const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            return _Al.allocate(_Count);
        }
    }










#line 605 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    static inline void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }

    template <class _Ty, class... _Types>
    static inline void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {


#line 616 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
            ::new (static_cast<void*>(_Ptr)) _Ty(::std:: forward<_Types>(_Args)...);
#line 618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        } else {
            _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Ty>
    static inline void destroy(_Alloc& _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {


#line 629 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
            _Ptr->~_Ty();
#line 631 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        } else {
            _Al.destroy(_Ptr);
        }
    }

    [[nodiscard]] static inline size_type max_size(const _Alloc& _Al) noexcept {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            return ::std:: _Max_limit<size_type>() / sizeof(value_type);
        }
    }

    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
};
__pragma(warning(pop))

template <class _Alloc>
struct _Default_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    using rebind_alloc = allocator<_Other>;

    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer allocate(
        _Alloc& _Al, __declspec(guard(overflow)) const size_type _Count) {




#line 685 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static inline __declspec(allocator) pointer allocate(
        _Alloc& _Al, __declspec(guard(overflow)) const size_type _Count, const_void_pointer) {




#line 699 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }






#line 712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    static inline void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) noexcept
     {
        




#line 721 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            (void) _Al;
            ::std:: _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }
    }

    template <class _Objty, class... _Types>
    static inline void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {


#line 732 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std:: forward<_Types>(_Args)...);
#line 734 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    }

    template <class _Uty>
    static inline void destroy(_Alloc&, _Uty* const _Ptr) {


#line 741 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        _Ptr->~_Uty();
#line 743 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    }

    [[nodiscard]] static inline size_type max_size(const _Alloc&) noexcept {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }

    [[nodiscard]] static inline _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        return _Al;
    }
};

 template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> {};



template <class _Alloc>
constexpr bool _Choose_pocca_v = allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
                              && !allocator_traits<_Alloc>::is_always_equal::value;

enum class _Pocma_values {
    _Equal_allocators, 
    _Propagate_allocators, 
    _No_propagate_allocators, 
};

template <class _Alloc>
constexpr _Pocma_values _Choose_pocma_v = allocator_traits<_Alloc>::is_always_equal::value
                                            ? _Pocma_values::_Equal_allocators
                                            : (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value
                                                      ? _Pocma_values::_Propagate_allocators
                                                      : _Pocma_values::_No_propagate_allocators);

template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;



template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
        _Rebind_alloc_t<_Alloc, _Value_type>>;

template <class _Alloc> 
constexpr bool _Is_simple_alloc_v =
    is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>
    && is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>
    && is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>
    && is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

template <class _Value_type>
struct _Simple_types { 
                       
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};


 constexpr size_t _Asan_granularity      = 8;
 constexpr size_t _Asan_granularity_mask = _Asan_granularity - 1;


template <class>
constexpr bool _Disable_ASan_container_annotations_for_allocator = false;

struct _Asan_aligned_pointers {
    const void* _First;
    const void* _End;

    [[nodiscard]] constexpr const void* _Clamp_to_end(const void* _Mid) const noexcept {
        ;
        if (_Mid > _End) {
            return _End;
        } else {
            return _Mid;
        }
    }
};

















































































[[nodiscard]] inline _Asan_aligned_pointers _Get_asan_aligned_first_end(
    const void* const _First, const void* const _End) noexcept {
    return {
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_First) & ~_Asan_granularity_mask),
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_End) & ~_Asan_granularity_mask),
    };
}




[[nodiscard]] inline const void* _Get_asan_aligned_after(const void* const _End) noexcept {
    return reinterpret_cast<const void*>(
        (reinterpret_cast<uintptr_t>(_End) + _Asan_granularity_mask) & ~_Asan_granularity_mask);
}

template <class _Container, class = void>
constexpr size_t _Container_allocation_minimum_asan_alignment = alignof(typename _Container::value_type);

template <class _Container>
constexpr size_t _Container_allocation_minimum_asan_alignment<_Container,
    void_t<decltype(_Container::allocator_type::_Minimum_asan_allocation_alignment)>> =
    (::std:: max)(
        alignof(typename _Container::value_type), _Container::allocator_type::_Minimum_asan_allocation_alignment);

 template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");
    static_assert(!is_function_v<_Ty>, "The C++ Standard forbids allocators for function elements "
                                       "because of [allocator.requirements].");
    static_assert(!is_reference_v<_Ty>, "The C++ Standard forbids allocators for reference elements "
                                        "because of [allocator.requirements].");

    using _From_primary = allocator;

    using value_type = _Ty;


    using pointer        = _Ty*;
    using const_pointer  = const _Ty*;

    using reference        = _Ty&;
    using const_reference  = const _Ty&;
#line 952 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment           = true_type;
    using is_always_equal  = true_type;


    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };

     [[nodiscard]] _Ty* address(_Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }

     [[nodiscard]] const _Ty* address(const _Ty& _Val) const noexcept {
        return ::std:: addressof(_Val);
    }
#line 973 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    constexpr allocator() noexcept {}

    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept {}
    inline ~allocator()                           = default;
    inline allocator& operator=(const allocator&) = default;

    inline void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept  {
        if (!(_Ptr != nullptr || _Count == 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory", 983, 0, "%s", "null pointer cannot point to a block of non-zero size")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        
        ::std:: _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] inline __declspec(allocator) _Ty* allocate(__declspec(guard(overflow)) const size_t _Count) {
        static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
        return static_cast<_Ty*>(::std:: _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }






#line 999 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"


     [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator)
    _Ty* allocate(__declspec(guard(overflow)) const size_t _Count, const void*) {
        return allocate(_Count);
    }

    template <class _Objty, class... _Types>
     void construct(_Objty* const _Ptr, _Types&&... _Args) {
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std:: forward<_Types>(_Args)...);
    }

    template <class _Uty>
     void destroy(_Uty* const _Ptr) {
        _Ptr->~_Uty();
    }

     [[nodiscard]] size_t max_size() const noexcept {
        return static_cast<size_t>(-1) / sizeof(_Ty);
    }
#line 1020 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    static constexpr size_t _Minimum_asan_allocation_alignment = _Asan_granularity;
};


template <>
class allocator<void> {
public:
    using value_type = void;

    using pointer        = void*;
    using const_pointer  = const void*;

    template <class _Other>
    struct  rebind {
        using other = allocator<_Other>;
    };
#line 1038 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"







#line 1046 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
};
#line 1048 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

 template <class _Ty, class _Other>
[[nodiscard]] inline bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return true;
}


template <class _Ty, class _Other>
[[nodiscard]] bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return false;
}
#line 1060 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"






#line 1067 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

template <class _Alloc>
inline void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}

template <class _Alloc>
inline void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std:: move(_Right);
    }
}

template <class _Alloc>
inline void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        swap(_Left, _Right); 
    } else {
        if (!(_Left == _Right)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory", 1093, 0, "%s", "containers incompatible for swap")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
    }
}

template <class _Alloc>
inline void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, ::std:: _Unfancy(_First));
        }
    }
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
inline void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {
    
    if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        for (; _First != _Last; ++_First) {
            ::std:: _Destroy_in_place(*_First);
        }
    }
}

template <class _Size_type, class _Unsigned_type>
[[nodiscard]] constexpr _Size_type _Convert_size(const _Unsigned_type _Len)
    noexcept(sizeof(_Unsigned_type) <= sizeof(_Size_type)) {
    
    ;
    ;

    if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
        if (_Len > ::std:: _Max_limit<_Size_type>()) {
            _Xlength_error("size is too long for _Size_type");
        }
    }

    return static_cast<_Size_type>(_Len);
}

template <class _Alloc>
inline void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}

template <class _Alloc>
inline void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    ::std:: _Deallocate_plain(_Al, _Ptr);
}

template <class _Alloc>
struct _Alloc_construct_ptr { 
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;

    inline explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

    [[nodiscard]] inline pointer _Release() noexcept { 
        return ::std:: exchange(_Ptr, nullptr);
    }

    inline void _Allocate() { 
        _Ptr = nullptr; 
        _Ptr = _Al.allocate(1);
    }

    inline ~_Alloc_construct_ptr() { 
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&)            = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};

struct _Fake_allocator {};

struct _Container_base0 {
    inline void _Orphan_all() noexcept {}
    inline void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    inline void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    inline void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};

struct _Iterator_base0 {
    inline void _Adopt(const void*) noexcept {}
    inline const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

struct _Container_base12;
struct _Container_proxy { 
    inline _Container_proxy() noexcept = default;
    inline _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

    const _Container_base12* _Mycont       = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};

struct _Container_base12 {
public:
    inline _Container_base12() noexcept = default;

    _Container_base12(const _Container_base12&)            = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;

    inline void _Orphan_all() noexcept;
    inline void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

    template <class _Alloc>
    inline void _Alloc_proxy(_Alloc&& _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy->_Mycont = this;
    }

    template <class _Alloc>
    inline void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Myproxy, _New_proxy));
    }

    _Container_proxy* _Myproxy = nullptr;

private:
    inline void _Orphan_all_unlocked_v3() noexcept;
    inline void _Swap_proxy_and_iterators_unlocked(_Container_base12&) noexcept;

    void _Orphan_all_locked_v3() noexcept {
        _Lockit _Lock(3);
        _Orphan_all_unlocked_v3();
    }

    void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {
        _Lockit _Lock(3);
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
};

struct _Iterator_base12 { 
public:
    inline _Iterator_base12() noexcept = default; 

    inline _Iterator_base12(const _Iterator_base12& _Right) noexcept {
        *this = _Right;
    }

    inline _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {





#line 1267 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            _Assign_locked(_Right);
        }


#line 1273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        return *this;
    }


    inline ~_Iterator_base12() noexcept {




#line 1283 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            _Orphan_me_locked_v3();
        }
    }

    inline void _Adopt(const _Container_base12* _Parent) noexcept {




#line 1294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            _Adopt_locked(_Parent);
        }
    }








#line 1307 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    inline const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = 2 == 0;

    mutable _Container_proxy* _Myproxy    = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;


private:
    inline void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {
        if (_Myproxy == _Right._Myproxy) {
            return;
        }

        if (_Right._Myproxy) {
            _Adopt_unlocked(_Right._Myproxy->_Mycont);
        } else { 
            _Orphan_me_unlocked_v3();
        }
    }

    void _Assign_locked(const _Iterator_base12& _Right) noexcept {
        _Lockit _Lock(3);
        _Assign_unlocked(_Right);
    }

    inline void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {
        if (!_Parent) {
            _Orphan_me_unlocked_v3();
            return;
        }

        _Container_proxy* _Parent_proxy = _Parent->_Myproxy;
        if (_Myproxy != _Parent_proxy) { 
            if (_Myproxy) { 
                _Orphan_me_unlocked_v3();
            }
            _Mynextiter                 = _Parent_proxy->_Myfirstiter;
            _Parent_proxy->_Myfirstiter = this;
            _Myproxy                    = _Parent_proxy;
        }
    }

    void _Adopt_locked(const _Container_base12* _Parent) noexcept {
        _Lockit _Lock(3);
        _Adopt_unlocked(_Parent);
    }

    inline void _Orphan_me_unlocked_v3() noexcept {
        if (!_Myproxy) { 
            return;
        }

        
        _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;
        while (*_Pnext && *_Pnext != this) {
            _Pnext = &(*_Pnext)->_Mynextiter;
        }

        if (!(*_Pnext)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory", 1369, 0, "%s", "ITERATOR LIST CORRUPTED!")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        *_Pnext  = _Mynextiter;
        _Myproxy = nullptr;
    }

    void _Orphan_me_locked_v3() noexcept {
        _Lockit _Lock(3);
        _Orphan_me_unlocked_v3();
    }
#line 1379 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
};

inline void _Container_base12::_Orphan_all_unlocked_v3() noexcept {
    if (!_Myproxy) { 
        return;
    }

    
    for (auto _Pnext = ::std:: exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {
        _Pnext->_Myproxy = nullptr;
    }
}

inline void _Container_base12::_Orphan_all() noexcept {





#line 1399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    {
        _Orphan_all_locked_v3();
    }
#line 1403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
}

inline void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;

    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }

    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}

inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {





#line 1426 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    {
        _Swap_proxy_and_iterators_locked(_Right);
    }


#line 1432 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
}




#line 1438 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
using _Container_base = _Container_base12;
using _Iterator_base  = _Iterator_base12;
#line 1441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
}; 

struct _Fake_proxy_ptr_impl { 
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&)            = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    inline _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

    inline void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    inline void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    
    _Container_proxy* _Ptr = nullptr;

    constexpr void _Release() noexcept { 
        _Ptr = nullptr;
    }

protected:
    inline _Basic_container_proxy_ptr12()                       = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&)      = delete;
};

template <class _Alloc>
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    
    _Alloc& _Al;

    inline _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

    inline _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, ::std:: addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }

    inline void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        
        
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Mycont->_Myproxy, ::std:: exchange(_Ptr, nullptr)));
    }

    inline ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};






#line 1508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Alloc>
using _Container_proxy_ptr = _Container_proxy_ptr12<_Rebind_alloc_t<_Alloc, _Container_proxy>>;
#line 1512 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
}; 

struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
}; 

template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { 
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; 

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2)
        noexcept(conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2)
        noexcept(conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return *this;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return *this;
    }
};

template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { 
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2)
        noexcept(conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2)
        noexcept(conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return _Myval1;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return _Myval1;
    }
};

template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;





            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return {static_cast<_Ty*>(_Pbuf), _Count};
            }
        }
    }

    return {nullptr, 0};
}

template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {





    {
        ::operator delete(_Pbuf);
    }
}

template <class _Ty, class _InIt>
void _Construct_in_place_by_deref(_Ty& _Val, _InIt& _Iter)
    noexcept(noexcept(::new (static_cast<void*>(::std:: addressof(_Val))) _Ty(*_Iter))) {
    ::new (static_cast<void*>(::std:: addressof(_Val))) _Ty(*_Iter);
}

template <class _NoThrowFwdIt>
struct [[nodiscard]] _Uninitialized_backout {
    
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&)            = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

    inline ~_Uninitialized_backout() {
        ::std:: _Destroy_range(_First, _Last);
    }

    template <class... _Types>
    inline void _Emplace_back(_Types&&... _Vals) {
        
        ::std:: _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    template <class _InIt>
    void _Emplace_back_deref(_InIt& _Iter) {
        
        ::std:: _Construct_in_place_by_deref(*_Last, _Iter);
        ++_Last;
    }

    template <class _InIt>
    void _Emplace_back_deref_move(_InIt& _Iter) {
        
        
        if constexpr (is_lvalue_reference_v<decltype(*_Iter)>) {
            ::std:: _Construct_in_place(*_Last, ::std:: move(*_Iter));
        } else {
            ::std:: _Construct_in_place_by_deref(*_Last, _Iter);
        }
        ++_Last;
    }

    constexpr _NoThrowFwdIt _Release() { 
        _First = _Last;
        return _Last;
    }
};

template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Iter_move_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {


#line 1670 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            return ::std:: _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back_deref_move(_First);
    }

    return _Backout._Release();
}















































































































































#line 1825 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Alloc>
class [[nodiscard]] _Uninitialized_backout_al {
    
private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    inline _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_backout_al(const _Uninitialized_backout_al&)            = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

    inline ~_Uninitialized_backout_al() {
        ::std:: _Destroy_range(_First, _Last, _Al);
    }

    template <class... _Types>
    inline void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, ::std:: _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr pointer _Release() { 
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _InIt, class _Se, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;








#line 1874 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    
    
    auto _UFirst = ::std:: _Get_unwrapped(::std:: move(_First));
    auto _ULast  = ::std:: _Get_unwrapped(::std:: move(_Last));
#line 1879 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
                               && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;

    if constexpr (_Can_memmove) {


#line 1887 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
                ::std:: _Copy_memmove(::std:: _To_address(_UFirst), ::std:: _To_address(_ULast), ::std:: _Unfancy(_Dest));
                _Dest += _ULast - _UFirst;
            } else {
                const auto _Count = static_cast<size_t>(_ULast - _UFirst);
                ::std:: _Copy_memmove_n(::std:: _To_address(_UFirst), _Count, ::std:: _Unfancy(_Dest));
                _Dest += _Count;
            }
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
    _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;




    auto _UFirst = ::std:: _Get_unwrapped(::std:: move(_First));
#line 1920 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    constexpr bool _Can_memmove =
        conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
            _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;

    if constexpr (_Can_memmove) {


#line 1929 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            ::std:: _Copy_memmove_n(_UFirst, _Count, ::std:: _Unfancy(_Dest));
            _Dest += _Count;
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _Count != 0; ++_UFirst, (void) --_Count) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {


#line 1951 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            return ::std:: _Copy_memmove(_First, _Last, _Dest);
        }
    }

    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back_deref(_First);
    }

    return _Backout._Release();
}

 template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst      = ::std:: _Get_unwrapped(_First);
    const auto _ULast = ::std:: _Get_unwrapped(_Last);
    auto _UDest       = ::std:: _Get_unwrapped_n(_Dest, ::std:: _Idl_distance<_InIt>(_UFirst, _ULast));
    ::std:: _Seek_wrapped(_Dest, ::std:: _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    



    using _Ptrval     = typename _Alloc::value_type*;
    auto _UFirst      = ::std:: _Get_unwrapped(_First);
    const auto _ULast = ::std:: _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(::std:: move(*_UFirst))>>) {


#line 1991 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            ::std:: _Copy_memmove(_UFirst, _ULast, ::std:: _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(::std:: move(*_UFirst));
    }

    return _Backout._Release();
}

template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {


#line 2014 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
            return _First + _Count;
        }
    } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {


#line 2022 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }

    return _Backout._Release();
}

 template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst      = ::std:: _Get_unwrapped(_First);
    const auto _ULast = ::std:: _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
        ::std:: _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
            if (::std:: _Is_all_bits_zero(_Val)) {
                ::std:: _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
        }

        _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}

template <class _NoThrowFwdIt>
constexpr bool _Use_memset_value_construct_v = conjunction_v<bool_constant<_Iterator_is_contiguous<_NoThrowFwdIt>>,
    is_scalar<_Iter_value_t<_NoThrowFwdIt>>, negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
    negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { 
    char* const _First_ch = reinterpret_cast<char*>(::std:: _To_address(_First));
    char* const _Last_ch  = reinterpret_cast<char*>(::std:: _To_address(_Last));
    :: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}

template <class _Alloc>
inline _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {
    
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {


#line 2085 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    
    ;
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return ::std:: _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}


 template <class _Ty>
 [[nodiscard]] pair<_Ty*, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept {
    return _Get_temporary_buffer<_Ty>(_Count);
}

 template <class _Ty>
 void return_temporary_buffer(_Ty* _Pbuf) {
    _Return_temporary_buffer(_Pbuf);
}
#line 2127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"





template <class _Ty>
using _Remove_const_ref_t = remove_const_t<remove_reference_t<_Ty>>;


template <class _Key, class... _Args>
struct _In_place_key_extract_set_impl {
    
    static constexpr bool _Extractable = false;
};

template <class _Key>
struct _In_place_key_extract_set_impl<_Key, _Key> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept {
        return _Val;
    }
};

template <class... _Valtys>
using _In_place_key_extract_set = _In_place_key_extract_set_impl<_Remove_const_ref_t<_Valtys>...>;


template <class _Key, class... _Args>
struct _In_place_key_extract_map_impl {
    
    static constexpr bool _Extractable = false;
};

template <class _Key, class _Second>
struct _In_place_key_extract_map_impl<_Key, _Key, _Second> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {
        return _Val;
    }
};

template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map_impl<_Key, pair<_First, _Second>> {
    
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_const_ref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val) noexcept {
        return _Val.first;
    }
};




















#line 2199 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Key, class _First, class... _RestTypes>
struct _In_place_key_extract_map_impl<_Key, piecewise_construct_t, tuple<_First>, tuple<_RestTypes...>> {
    
    
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_const_ref_t<_First>>;
    static const _Key& _Extract(
        const piecewise_construct_t&, const tuple<_First>& _Tup_val, const tuple<_RestTypes...>&) noexcept {
        return ::std:: get<0>(_Tup_val);
    }
};

template <class... _Valtys>
using _In_place_key_extract_map = _In_place_key_extract_map_impl<_Remove_const_ref_t<_Valtys>...>;

#pragma warning(push)
#pragma warning(disable : 4624) 
template <class _Ty>
struct _Wrap {
    _Ty _Value; 
};
#pragma warning(pop)

template <class _Alloc>
struct _Alloc_temporary2 {
    using value_type = typename _Alloc::value_type;
    using _Traits    = allocator_traits<_Alloc>;

    _Alloc& _Al;














    union {
        value_type _Value;
    };

    [[nodiscard]] inline value_type& _Get_value() noexcept {
        return _Value;
    }

    [[nodiscard]] inline const value_type& _Get_value() const noexcept {
        return _Value;
    }
#line 2254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    template <class... _Args>
    inline explicit _Alloc_temporary2(_Alloc& _Al_, _Args&&... _Vals)
        noexcept(noexcept(_Traits::construct(_Al_, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...)))
        : _Al(_Al_) {
        _Traits::construct(_Al, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...);
    }

    _Alloc_temporary2(const _Alloc_temporary2&)            = delete;
    _Alloc_temporary2& operator=(const _Alloc_temporary2&) = delete;

    inline ~_Alloc_temporary2() {
        _Traits::destroy(_Al, ::std:: addressof(_Get_value()));
    }
};

template <class _Alloc>
[[nodiscard]] constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {
    if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}












#line 2291 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Alloc>
[[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] inline typename allocator_traits<_Alloc>::pointer _Allocate_at_least_helper(
    _Alloc& _Al, __declspec(guard(overflow)) typename allocator_traits<_Alloc>::size_type& _Count) {






#line 2302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
    {
        return _Al.allocate(_Count);
    }
}

 template <class _FwdIt, class _Ty>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] inline _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst      = ::std:: _Get_unwrapped(_First);
    const auto _ULast = ::std:: _Get_unwrapped(_Last);
    _UFirst           = ::std:: _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {

        if constexpr (_Vector_alg_in_find_is_safe<decltype(_UFirst), _Ty>) {


#line 2321 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
            {
                const auto _First_ptr = ::std:: _To_address(_UFirst);
                const auto _Result    = ::std:: _Remove_vectorized(_First_ptr, ::std:: _To_address(_ULast), _Val);

                if constexpr (is_pointer_v<decltype(_UNext)>) {
                    _UNext = _Result;
                } else {
                    _UNext += _Result - _First_ptr;
                }

                ::std:: _Seek_wrapped(_First, _UNext);
                return _First;
            }
        }
#line 2336 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    ::std:: _Seek_wrapped(_First, _UNext);
    return _First;
}

 template <class _FwdIt, class _Pr>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] inline _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    ::std:: _Adl_verify_range(_First, _Last);
    auto _UFirst      = ::std:: _Get_unwrapped(_First);
    const auto _ULast = ::std:: _Get_unwrapped(_Last);
    _UFirst           = ::std:: find_if(_UFirst, _ULast, ::std:: _Pass_fn(_Pred));
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    ::std:: _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _Container, class _Uty>
inline typename _Container::size_type _Erase_remove(_Container& _Cont, const _Uty& _Val) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    ::std:: _Seek_wrapped(_First, ::std:: remove(::std:: _Get_unwrapped(_First), ::std:: _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
inline typename _Container::size_type _Erase_remove_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    ::std:: _Seek_wrapped(_First, ::std:: remove_if(::std:: _Get_unwrapped(_First), ::std:: _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
typename _Container::size_type _Erase_nodes_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        } else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}

template <class _Ty1, class _Ty2>
void _Deduce_as_pair(const pair<_Ty1, _Ty2>&); 

template <class _Ty, class = void>
constexpr bool _Is_deducible_as_pair = false;

template <class _Ty>
constexpr bool _Is_deducible_as_pair<_Ty, decltype(::std:: _Deduce_as_pair(::std:: declval<_Ty>()))> = true;

template <class _Ty>
constexpr bool _Is_cv_pair = _Is_specialization_v<remove_cv_t<_Ty>, pair>;

template <class _Ty>
const _Ty& _Normally_bind(_Identity_t<const _Ty&>); 

template <class _Ty>
_Ty&& _Normally_bind(_Identity_t<_Ty&&>); 

template <class _Ty, class _Uty>
using _Normally_bound_ref = decltype(::std:: _Normally_bind<_Ty>(::std:: declval<_Uty>()));

template <class _Ty, class _Uty, class = void>
constexpr bool _Is_normally_bindable = false;

template <class _Ty, class _Uty>
constexpr bool _Is_normally_bindable<_Ty, _Uty, void_t<_Normally_bound_ref<_Ty, _Uty>>> = true;












































































































































































































#line 2639 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"




















#line 2660 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
class _Ebco_base : private _Ty { 
private:
    using _Mybase = _Ty; 

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return *this;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return *this;
    }
};

template <class _Ty>
class _Ebco_base<_Ty, false> { 
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return _Myval;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return _Myval;
    }
};

 inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept  {
    
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; 
    }

    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }

    
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}

template <class _Ty, class = void>
constexpr bool _Is_transparent_v = false;

template <class _Ty>
constexpr bool _Is_transparent_v<_Ty, void_t<typename _Ty::is_transparent>> = true;

template <class _Ty>
struct _Is_transparent : bool_constant<_Is_transparent_v<_Ty>> {};




#line 2730 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"





















#line 2752 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

template <class _Elem, class _UTy>
[[nodiscard]] _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { 
    
    static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");


    auto _UVal_trunc = _UVal;
















#line 2777 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

    do {
        *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);
        _UVal_trunc /= 10;
    } while (_UVal_trunc != 0);
    return _RNext;
}
} 



#line 2789 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

#line 2791 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"



#line 2795 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

#line 2797 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"



#line 2801 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"

#line 2803 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"



#pragma warning(pop)
#pragma pack(pop)
#line 2809 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#line 2810 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\xmemory"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"



#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"



#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )




 namespace std {
template <class _Myvec>
class _Vector_const_iterator : public _Iterator_base {
public:


#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::const_pointer;
    using reference         = const value_type&;

    using _Tptr = typename _Myvec::pointer;

    inline _Vector_const_iterator() noexcept : _Ptr() {}

    inline _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pvector);
    }

    [[nodiscard]] inline reference operator*() const noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        if (!(_Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 53, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 54, 0, "%s", "can't dereference invalidated vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 56, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *_Ptr;
    }

    [[nodiscard]] inline pointer operator->() const noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        if (!(_Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 65, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 66, 0, "%s", "can't dereference invalidated vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 68, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 70 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return _Ptr;
    }

    inline _Vector_const_iterator& operator++() noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        if (!(_Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 77, 0, "%s", "can't increment value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 78, 0, "%s", "can't increment invalidated vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Ptr < _Mycont->_Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 79, 0, "%s", "can't increment vector iterator past end")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        ++_Ptr;
        return *this;
    }

    inline _Vector_const_iterator operator++(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    inline _Vector_const_iterator& operator--() noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        if (!(_Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 95, 0, "%s", "can't decrement value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 96, 0, "%s", "can't decrement invalidated vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont->_Myfirst < _Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 97, 0, "%s", "can't decrement vector iterator before begin")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        --_Ptr;
        return *this;
    }

    inline _Vector_const_iterator operator--(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    inline void _Verify_offset(const difference_type _Off) const noexcept {


#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        if (!(_Off == 0 || _Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 115, 0, "%s", "cannot seek value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Off == 0 || _Mycont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 116, 0, "%s", "cannot seek invalidated vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (_Off < 0) {
            if (!(_Off >= _Mycont->_Myfirst - _Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 118, 0, "%s", "cannot seek vector iterator before begin")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        }

        if (_Off > 0) {
            if (!(_Off <= _Mycont->_Mylast - _Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 122, 0, "%s", "cannot seek vector iterator after end")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        }
#line 125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }

    inline _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] inline _Vector_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend inline _Vector_const_iterator operator+(
        const difference_type _Off, _Vector_const_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    inline _Vector_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _Vector_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return static_cast<difference_type>(_Ptr - _Right._Ptr);
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }






#line 175 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    [[nodiscard]] bool operator!=(const _Vector_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

    [[nodiscard]] bool operator>(const _Vector_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Vector_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Vector_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void _Compat(const _Vector_const_iterator& _Right) const noexcept {
        


#line 202 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        if (!(this->_Getcont() == _Right._Getcont())) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 202, 0, "%s", "vector iterators incompatible")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 204 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }


    friend inline void _Verify_range(
        const _Vector_const_iterator& _First, const _Vector_const_iterator& _Last) noexcept {
        if (!(_First._Getcont() == _Last._Getcont())) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 209, 0, "%s", "vector iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_First._Ptr <= _Last._Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 210, 0, "%s", "vector iterator range transposed")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
    }
#line 213 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    [[nodiscard]] inline const value_type* _Unwrapped() const noexcept {
        return ::std:: _Unfancy_maybe_null(_Ptr);
    }

    inline void _Seek_to(const value_type* _It) noexcept {
        _Ptr = ::std:: _Refancy_maybe_null<_Tptr>(const_cast<value_type*>(_It));
    }

    _Tptr _Ptr; 
};


























#line 253 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

template <class _Myvec>
class _Vector_iterator : public _Vector_const_iterator<_Myvec> {
public:
    using _Mybase = _Vector_const_iterator<_Myvec>;



#line 262 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] inline reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] inline pointer operator->() const noexcept {

        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        if (!(this->_Ptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 277, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 278, 0, "%s", "can't dereference invalidated vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(_Mycont->_Myfirst <= this->_Ptr && this->_Ptr < _Mycont->_Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 280, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 281 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 282 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return this->_Ptr;
    }

    inline _Vector_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _Vector_iterator operator++(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _Vector_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _Vector_iterator operator--(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _Vector_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _Vector_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend inline _Vector_iterator operator+(
        const difference_type _Off, _Vector_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    inline _Vector_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _Vector_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

    [[nodiscard]] inline value_type* _Unwrapped() const noexcept {
        return ::std:: _Unfancy_maybe_null(this->_Ptr);
    }
};


























#line 375 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer>
struct _Vec_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

struct _Value_init_tag { 
    explicit _Value_init_tag() = default;
};

template <class _Val_types>
class _Vector_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    inline _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

    inline _Vector_val(pointer _First, pointer _Last, pointer _End) noexcept
        : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}












#line 417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void _Swap_val(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        swap(_Myfirst, _Right._Myfirst); 
        swap(_Mylast, _Right._Mylast); 
        swap(_Myend, _Right._Myend); 
    }

    inline void _Take_contents(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        _Myfirst = _Right._Myfirst;
        _Mylast  = _Right._Mylast;
        _Myend   = _Right._Myend;

        _Right._Myfirst = nullptr;
        _Right._Mylast  = nullptr;
        _Right._Myend   = nullptr;
    }

    pointer _Myfirst; 
    pointer _Mylast; 
    pointer _Myend; 
};

 template <class _Ty, class _Alloc = allocator<_Ty>>
class vector { 
private:
    template <class>
    friend class _Vb_val;
    friend _Tidy_guard<vector>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits = allocator_traits<_Alty>;

public:
    static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>,
        "vector<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");
    static_assert(is_object_v<_Ty>, "The C++ Standard forbids containers of non-object types "
                                    "because of [container.requirements].");

    using value_type      = _Ty;
    using allocator_type  = _Alloc;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&;
    using const_reference = const _Ty&;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;

private:










































































































































#line 606 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    using _Scary_val = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>,
        _Vec_iter_types<_Ty, size_type, difference_type, pointer, const_pointer>>>;

    struct [[nodiscard]] _Reallocation_guard {
        _Alloc& _Al;
        pointer _New_begin;
        size_type _New_capacity;
        pointer _Constructed_first;
        pointer _Constructed_last;

        _Reallocation_guard& operator=(const _Reallocation_guard&) = delete;
        _Reallocation_guard& operator=(_Reallocation_guard&&)      = delete;

        inline ~_Reallocation_guard() noexcept {
            if (_New_begin != nullptr) {
                ::std:: _Destroy_range(_Constructed_first, _Constructed_last, _Al);
                _Al.deallocate(_New_begin, _New_capacity);
            }
        }
    };

    struct [[nodiscard]] _Simple_reallocation_guard {
        _Alloc& _Al;
        pointer _New_begin;
        size_type _New_capacity;

        _Simple_reallocation_guard& operator=(const _Simple_reallocation_guard&) = delete;
        _Simple_reallocation_guard& operator=(_Simple_reallocation_guard&&)      = delete;

        inline ~_Simple_reallocation_guard() noexcept {
            if (_New_begin != nullptr) {
                _Al.deallocate(_New_begin, _New_capacity);
            }
        }
    };

    struct [[nodiscard]] _Vaporization_guard { 
        vector* _Target;
        pointer _Vaporized_first;
        pointer _Vaporized_last;
        pointer _Destroyed_first;

        _Vaporization_guard& operator=(const _Vaporization_guard&) = delete;
        _Vaporization_guard& operator=(_Vaporization_guard&&)      = delete;

        ~_Vaporization_guard() noexcept {
            if (_Target != nullptr) {
                auto& _Al     = _Target->_Getal();
                auto& _Mylast = _Target->_Mypair._Myval2._Mylast;

                _Target->_Orphan_range(_Vaporized_first, _Vaporized_last);
                ::std:: _Destroy_range(_Destroyed_first, _Mylast, _Al);
                _Mylast = _Vaporized_first;
            }
        }
    };

public:
    using iterator               = _Vector_iterator<_Scary_val>;
    using const_iterator         = _Vector_const_iterator<_Scary_val>;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    inline vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
    }

    inline explicit vector(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
    }

    inline explicit vector(__declspec(guard(overflow)) const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count);
    }



#line 686 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    inline vector(__declspec(guard(overflow)) const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count, _Val);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        ::std:: _Adl_verify_range(_First, _Last);
        auto _UFirst = ::std:: _Get_unwrapped(_First);
        auto _ULast  = ::std:: _Get_unwrapped(_Last);
        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = ::std:: _Convert_size<size_type>(_Length);
            _Construct_n(_Count, ::std:: move(_UFirst), ::std:: move(_ULast));





#line 707 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        } else {
            auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_guard<vector> _Guard{this};

            _Append_uncounted_range(::std:: move(_UFirst), ::std:: move(_ULast));

            _Guard._Target = nullptr;
            _Proxy._Release();
        }
    }

    inline vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());
    }




















#line 744 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline vector(const vector& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        const auto& _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }

    inline vector(const vector& _Right, const _Identity_t<_Alloc>& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        const auto& _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }

    inline vector(vector&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal()),
              ::std:: exchange(_Right._Mypair._Myval2._Myfirst, nullptr),
              ::std:: exchange(_Right._Mypair._Myval2._Mylast, nullptr),
              ::std:: exchange(_Right._Mypair._Myval2._Myend, nullptr)) {
        _Mypair._Myval2._Alloc_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal()));
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    inline vector(vector&& _Right, const _Identity_t<_Alloc>& _Al_)
        noexcept(_Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al_) {
        _Alty& _Al        = _Getal();
        auto&& _Alproxy   = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Al != _Right._Getal()) {
                const auto _Count = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
                if (_Count != 0) {
                    _Buy_raw(_Count);
                    _Tidy_guard<vector> _Guard{this};
                    _My_data._Mylast =
                        _Uninitialized_move(_Right_data._Myfirst, _Right_data._Mylast, _My_data._Myfirst, _Al);

                    ;
                    _Guard._Target = nullptr;
                }
                _Proxy._Release();
                return;
            }
        }

        _My_data._Take_contents(_Right_data);
        _Proxy._Release();
    }

    inline vector& operator=(vector&& _Right)
        noexcept(_Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        _Alty& _Al                = _Getal();
        _Alty& _Right_al          = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
        if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                _Move_assign_unequal_alloc(_Right);
                return *this;
            }
        }

        _Tidy();

        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                
                _Mypair._Myval2._Reload_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right_al));
            }
        }
#line 823 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        _Pocma(_Al, _Right_al);
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
        return *this;
    }

    inline ~vector() noexcept {
        _Tidy();

        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Getal());
        _Delete_plain_internal(_Alproxy, ::std:: exchange(_Mypair._Myval2._Myproxy, nullptr));
#line 835 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }

private:
    template <class... _Valty>
    inline _Ty& _Emplace_one_at_back(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        if (_Mylast != _My_data._Myend) {
            return _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
        }

        return *_Emplace_reallocate(_Mylast, ::std:: forward<_Valty>(_Val)...);
    }

    template <class... _Valty>
    inline _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;
        ; 
        if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
                          _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
            ;
            ::std:: _Construct_in_place(*_Mylast, ::std:: forward<_Valty>(_Val)...);
        } else {
            ;
            _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), ::std:: forward<_Valty>(_Val)...);
            ;
        }

        _Orphan_range(_Mylast, _Mylast);
        _Ty& _Result = *_Mylast;
        ++_Mylast;

        return _Result;
    }

    template <class... _Valty>
    inline pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {
        
        _Alty& _Al        = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        ; 

        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        if (_Oldsize == max_size()) {
            _Xlength();
        }

        const size_type _Newsize = _Oldsize + 1;
        size_type _Newcapacity   = _Calculate_growth(_Newsize);

        const pointer _Newvec           = ::std:: _Allocate_at_least_helper(_Al, _Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;

        _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};
        auto& _Constructed_first = _Guard._Constructed_first;

        _Alty_traits::construct(_Al, ::std:: _Unfancy(_Newvec + _Whereoff), ::std:: forward<_Valty>(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;

        if (_Whereptr == _Mylast) { 
            if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                ::std:: _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
            } else {
                ::std:: _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
            }
        } else { 
            ::std:: _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);
            _Constructed_first = _Newvec;
            ::std:: _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);
        }

        _Guard._New_begin = nullptr;
        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return _Newvec + _Whereoff;
    }

public:
    template <class... _Valty>
    inline void emplace_back(_Valty&&... _Val) {
        
        _Ty& _Result = _Emplace_one_at_back(::std:: forward<_Valty>(_Val)...);


#line 928 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        (void) _Result;
#line 930 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }

    inline void push_back(const _Ty& _Val) { 
        _Emplace_one_at_back(_Val);
    }

    inline void push_back(_Ty&& _Val) {
        
        _Emplace_one_at_back(::std:: move(_Val));
    }

private:
    template <class _Iter, class _Sent>
    inline void _Append_uncounted_range(_Iter _First, const _Sent _Last) {
        

        
        
        

        for (; _First != _Last; ++_First) {
            _Emplace_one_at_back(*_First);
        }
    }























































#line 1010 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

public:











#line 1024 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    template <class... _Valty>
    inline iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldlast  = _My_data._Mylast;

        if (!(_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1034, 0, "%s", "vector emplace iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1035 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1036 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        if (_Oldlast != _My_data._Myend) {
            if (_Whereptr == _Oldlast) { 
                _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
            } else {
                auto& _Al = _Getal();
                _Alloc_temporary2<_Alty> _Obj(_Al, ::std:: forward<_Valty>(_Val)...); 
                
                _Orphan_range(_Whereptr, _Oldlast);
                ;
                _Alty_traits::construct(_Al, _Unfancy(_Oldlast), ::std:: move(_Oldlast[-1]));
                ;
                ++_My_data._Mylast;
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = ::std:: move(_Obj._Get_value());
            }

            return _Make_iterator(_Whereptr);
        }

        return _Make_iterator(_Emplace_reallocate(_Whereptr, ::std:: forward<_Valty>(_Val)...));
    }

    inline iterator insert(const_iterator _Where, const _Ty& _Val) { 
        return emplace(_Where, _Val);
    }

    inline iterator insert(const_iterator _Where, _Ty&& _Val) { 
        return emplace(_Where, ::std:: move(_Val));
    }

    inline iterator insert(const_iterator _Where, __declspec(guard(overflow)) const size_type _Count, const _Ty& _Val) {
        
        const pointer _Whereptr = _Where._Ptr;

        auto& _Al        = _Getal();
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst = _My_data._Myfirst;
        const pointer _Oldlast  = _Mylast;

        if (!(_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _Oldfirst && _Oldlast >= _Whereptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1079, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1080 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1081 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        const auto _Whereoff        = static_cast<size_type>(_Whereptr - _Oldfirst);
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
        const bool _One_at_back     = _Count == 1 && _Whereptr == _Oldlast;
        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;

            _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};
            auto& _Constructed_first = _Guard._Constructed_first;

            _Uninitialized_fill_n(_Newvec + _Whereoff, _Count, _Val, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { 
                if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { 
                _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }

            _Guard._New_begin = nullptr;
            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { 
            _Emplace_back_with_unused_capacity(_Val);
        } else { 
            const _Alloc_temporary2<_Alty> _Tmp_storage(_Al, _Val); 
            const auto& _Tmp              = _Tmp_storage._Get_value();
            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
            _Orphan_range(_Whereptr, _Oldlast);

            ;
            if (_Count > _Affected_elements) { 
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Count - _Affected_elements, _Tmp, _Al);
                _Mylast = _Uninitialized_move(_Whereptr, _Oldlast, _Mylast, _Al);
                ::std:: fill(_Whereptr, _Oldlast, _Tmp);
            } else { 
                _Mylast = _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                ::std:: fill_n(_Whereptr, _Count, _Tmp);
            }
            ;
        }

        return _Make_iterator_offset(_Whereoff);
    }

private:
    template <class _Iter, class _Sent>
    inline void _Insert_uncounted_range(const_iterator _Where, _Iter _First, _Sent _Last) {
        
        if (_First == _Last) {
            return; 
        }

        auto& _My_data       = _Mypair._Myval2;
        pointer& _Myfirst    = _My_data._Myfirst;
        pointer& _Mylast     = _My_data._Mylast;
        const auto _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        _Append_uncounted_range(::std:: move(_First), ::std:: move(_Last));

        _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);

        ::std:: rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
    }

    template <class _Iter>
    inline void _Insert_counted_range(const_iterator _Where, _Iter _First, const size_type _Count) {
        
        const pointer _Whereptr = _Where._Ptr;

        auto& _Al        = _Getal();
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = ::std:: _Allocate_at_least_helper(_Al, _Newcapacity);
            const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;

            _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};
            auto& _Constructed_first = _Guard._Constructed_first;

            ::std:: _Uninitialized_copy_n(::std:: move(_First), _Count, _Newvec + _Whereoff, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_Count == 1 && _Whereptr == _Oldlast) { 
                if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                    ::std:: _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    ::std:: _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { 
                ::std:: _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                ::std:: _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }

            _Guard._New_begin = nullptr;
            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { 
                 
                 

            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);

            ;
            if (_Count < _Affected_elements) { 
                _Mylast = ::std:: _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                ::std:: _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                ::std:: _Destroy_range(_Whereptr, _Whereptr + _Count, _Al);

                try {
                ::std:: _Uninitialized_copy_n(::std:: move(_First), _Count, _Whereptr, _Al);
                } catch (...) {
                

                _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Whereptr + _Count};
                ::std:: _Uninitialized_move(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr, _Al);
                _Guard._Target = nullptr;

                ::std:: _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
                ::std:: _Destroy_range(_Oldlast, _Mylast, _Al);
                _Mylast = _Oldlast;
                throw;
                }
            } else { 
                const pointer _Relocated = _Whereptr + _Count;
                _Mylast                  = ::std:: _Uninitialized_move(_Whereptr, _Oldlast, _Relocated, _Al);
                ::std:: _Destroy_range(_Whereptr, _Oldlast, _Al);

                try {
                ::std:: _Uninitialized_copy_n(::std:: move(_First), _Count, _Whereptr, _Al);
                } catch (...) {
                

                _Vaporization_guard _Guard{this, _Whereptr, _Oldlast, _Relocated};
                ::std:: _Uninitialized_move(_Relocated, _Mylast, _Whereptr, _Al);
                _Guard._Target = nullptr;

                ::std:: _Destroy_range(_Relocated, _Mylast, _Al);
                _Mylast = _Oldlast;
                throw;
                }
            }

            _Orphan_range(_Whereptr, _Oldlast);
            ;
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;

        if (!(_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _Oldfirst && _My_data._Mylast >= _Whereptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1272, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        ::std:: _Adl_verify_range(_First, _Last);
        auto _UFirst         = ::std:: _Get_unwrapped(_First);
        auto _ULast          = ::std:: _Get_unwrapped(_Last);
        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = ::std:: _Convert_size<size_type>(_Length);
            _Insert_counted_range(_Where, _UFirst, _Count);





#line 1289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        } else {
            _Insert_uncounted_range(_Where, _UFirst, _ULast);
        }
        return _Make_iterator_offset(_Whereoff);
    }























#line 1318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;

        if (!(_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _Oldfirst && _My_data._Mylast >= _Whereptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1326, 0, "%s", "vector insert iterator out-of-range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1327 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);

        const auto _Count = _Convert_size<size_type>(_Ilist.size());
        _Insert_counted_range(_Where, _Ilist.begin(), _Count);
        return _Make_iterator_offset(_Whereoff);
    }

    inline void assign(__declspec(guard(overflow)) const size_type _Newsize, const _Ty& _Val) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;




#line 1346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        {
            const auto _Valptr = ::std:: addressof(_Val);
            if (!(!(_Unfancy(_Myfirst) <= _Valptr && _Valptr < _Unfancy(_Mylast)))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1349, 0, "%s", "assignment value cannot be a reference into the container")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1350 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        }
#line 1352 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        constexpr bool _Nothrow_construct =
            conjunction_v<is_nothrow_copy_constructible<_Ty>, _Uses_default_construct<_Alloc, _Ty*, const _Ty&>>;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
        if (_Newsize > _Oldcapacity) { 
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _Uninitialized_fill_n(_Myfirst, _Newsize, _Val, _Al);
                ;
            } else {
                ;
                _Mylast = _Uninitialized_fill_n(_Myfirst, _Newsize, _Val, _Al);
            }

            return;
        }

        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            ::std:: fill(_Myfirst, _Mylast, _Val);
            if constexpr (_Nothrow_construct) {
                ;
                _Mylast = _Uninitialized_fill_n(_Mylast, _Newsize - _Oldsize, _Val, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_fill_n(_Mylast, _Newsize - _Oldsize, _Val, _Al);
                ;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            ::std:: fill(_Myfirst, _Newlast, _Val);
            _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
        }
    }

private:
    template <class _Iter, class _Sent>
    inline void _Assign_uncounted_range(_Iter _First, _Sent _Last) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        pointer _Next = _Myfirst;
        for (; _First != _Last && _Next != _Mylast; ++_First, (void) ++_Next) {
            *_Next = *_First;
        }

        
        
        
        

        
        _Destroy_range(_Next, _Mylast, _Getal());
        ; 
        _Mylast = _Next;

        _Append_uncounted_range(::std:: move(_First), ::std:: move(_Last));
    }

    template <class _Iter>
    inline void _Assign_counted_range(_Iter _First, const size_type _Newsize) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
            _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
        if (_Newsize > _Oldcapacity) {
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = ::std:: _Uninitialized_copy_n(::std:: move(_First), _Newsize, _Myfirst, _Al);
                ;
            } else {
                ;
                _Mylast = ::std:: _Uninitialized_copy_n(::std:: move(_First), _Newsize, _Myfirst, _Al);
            }
            return;
        }

        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            bool _Copied = false;
            if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {


#line 1452 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
                {
                    _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
                    _First += _Oldsize;
                    _Copied = true;
                }
            }

            if (!_Copied) {
                for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
                    *_Mid = *_First;
                }
            }

            if constexpr (_Nothrow_construct) {
                ;
                _Mylast = ::std:: _Uninitialized_copy_n(::std:: move(_First), _Newsize - _Oldsize, _Mylast, _Al);
            } else {
                ;
                _Mylast = ::std:: _Uninitialized_copy_n(::std:: move(_First), _Newsize - _Oldsize, _Mylast, _Al);
                ;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            ::std:: _Copy_n_unchecked4(::std:: move(_First), _Newsize, _Myfirst);
            ::std:: _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline void assign(_Iter _First, _Iter _Last) {
        ::std:: _Adl_verify_range(_First, _Last);
        auto _UFirst = ::std:: _Get_unwrapped(_First);
        auto _ULast  = ::std:: _Get_unwrapped(_Last);
        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = ::std:: _Convert_size<size_type>(_Length);
            _Assign_counted_range(_UFirst, _Count);





#line 1498 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        } else {
            _Assign_uncounted_range(_UFirst, _ULast);
        }
    }














#line 1517 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void assign(const initializer_list<_Ty> _Ilist) {
        const auto _Count = _Convert_size<size_type>(_Ilist.size());
        _Assign_counted_range(_Ilist.begin(), _Count);
    }

    inline vector& operator=(const vector& _Right) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al       = _Getal();
        auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alty>) {
            if (_Al != _Right_al) {
                _Tidy();
                _Mypair._Myval2._Reload_proxy(static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al), static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Right_al));
            }
        }

        _Pocca(_Al, _Right_al);
        auto& _Right_data = _Right._Mypair._Myval2;
        _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

        return *this;
    }

    inline vector& operator=(initializer_list<_Ty> _Ilist) {
        const auto _Count = _Convert_size<size_type>(_Ilist.size());
        _Assign_counted_range(_Ilist.begin(), _Count);
        return *this;
    }

private:
    template <class _Ty2>
    inline void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
        if (_Newsize > max_size()) {
            _Xlength();
        }

        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);
        size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec         = _Allocate_at_least_helper(_Al, _Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;

        _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Appended_first, _Appended_first};
        auto& _Appended_last = _Guard._Constructed_last;

        if constexpr (is_same_v<_Ty2, _Ty>) {
            _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
        } else {
            ;
            _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);
        }

        if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }

        _Guard._New_begin = nullptr;
        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }

    template <class _Ty2>
    inline void _Resize(const size_type _Newsize, const _Ty2& _Val) {
        
        auto& _Al           = _Getal();
        auto& _My_data      = _Mypair._Myval2;
        pointer& _Myfirst   = _My_data._Myfirst;
        pointer& _Mylast    = _My_data._Mylast;
        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize < _Oldsize) { 
            const pointer _Newlast = _Myfirst + _Newsize;
            _Orphan_range(_Newlast, _Mylast);
            _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
            return;
        }

        if (_Newsize > _Oldsize) { 
            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Resize_reallocate(_Newsize, _Val);
                return;
            }

            ;
            const pointer _Oldlast = _Mylast;
            if constexpr (is_same_v<_Ty2, _Ty>) {
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);
            }
            ;
            _Orphan_range(_Oldlast, _Oldlast);
        }

        
    }

public:
    inline void resize(__declspec(guard(overflow)) const size_type _Newsize) {
        
        _Resize(_Newsize, _Value_init_tag{});
    }

    inline void resize(__declspec(guard(overflow)) const size_type _Newsize, const _Ty& _Val) {
        
        _Resize(_Newsize, _Val);
    }

private:
    enum class _Reallocation_policy { _At_least, _Exactly };

    template <_Reallocation_policy _Policy>
    inline void _Reallocate(size_type& _Newcapacity) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

        pointer _Newvec;
        if constexpr (_Policy == _Reallocation_policy::_At_least) {
            _Newvec = _Allocate_at_least_helper(_Al, _Newcapacity);
        } else {
            ;
            _Newvec = _Al.allocate(_Newcapacity);
        }

        _Simple_reallocation_guard _Guard{_Al, _Newvec, _Newcapacity};

        if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }

        _Guard._New_begin = nullptr;
        _Change_array(_Newvec, _Size, _Newcapacity);
    }



















#line 1690 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void _Clear_and_reserve_geometric(const size_type _Newsize) {
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;




#line 1702 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        if (_Newsize > max_size()) {
            _Xlength();
        }

        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        if (_Myfirst) { 
            _Destroy_range(_Myfirst, _Mylast, _Al);
            ;
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }

        _Buy_raw(_Newcapacity);
    }

public:
    inline void reserve(__declspec(guard(overflow)) size_type _Newcapacity) {
        
        if (_Newcapacity > capacity()) { 
            if (_Newcapacity > max_size()) {
                _Xlength();
            }

            _Reallocate<_Reallocation_policy::_At_least>(_Newcapacity);
        }
    }

    inline void shrink_to_fit() { 
        auto& _My_data         = _Mypair._Myval2;
        const pointer _Oldlast = _My_data._Mylast;
        if (_Oldlast != _My_data._Myend) { 
            const pointer _Oldfirst = _My_data._Myfirst;
            if (_Oldfirst == _Oldlast) {
                _Tidy();
            } else {
                size_type _Newcapacity = static_cast<size_type>(_Oldlast - _Oldfirst);
                _Reallocate<_Reallocation_policy::_Exactly>(_Newcapacity);
            }
        }
    }

    inline void pop_back() noexcept  {
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;


        if (!(_My_data._Myfirst != _Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1753, 0, "%s", "pop_back() called on empty vector")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1755 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        _Orphan_range(_Mylast - 1, _Mylast);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        ;
        --_Mylast;
    }

    inline iterator erase(const_iterator _Where)
        noexcept(is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;


        if (!(_Where._Getcont() == ::std:: addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1771, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1772 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1773 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        _Orphan_range(_Whereptr, _Mylast);
        ::std:: _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        ;
        --_Mylast;
        return iterator(_Whereptr, ::std:: addressof(_My_data));
    }

    inline iterator erase(const_iterator _First, const_iterator _Last)
        noexcept(is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Firstptr = _First._Ptr;
        const pointer _Lastptr  = _Last._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;


        if (!(_First._Getcont() == ::std:: addressof(_My_data) && _Last._Getcont() == ::std:: addressof(_My_data) && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1792, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1793 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1794 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        if (_Firstptr != _Lastptr) { 
            _Orphan_range(_Firstptr, _Mylast);

            const pointer _Newlast = ::std:: _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
            _Destroy_range(_Newlast, _Mylast, _Getal());
            ; 
            _Mylast = _Newlast;
        }

        return iterator(_Firstptr, ::std:: addressof(_My_data));
    }

    inline void clear() noexcept { 
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        if (_Myfirst == _Mylast) { 
            
            
            
            return;
        }

        _My_data._Orphan_all();
        _Destroy_range(_Myfirst, _Mylast, _Getal());
        ; 
        _Mylast = _Myfirst;
    }

    inline void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);
        }
    }

    [[nodiscard]] inline _Ty* data() noexcept {
        return ::std:: _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline const _Ty* data() const noexcept {
        return ::std:: _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline iterator begin() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline iterator end() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] inline _Ty* _Unchecked_begin() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline const _Ty* _Unchecked_begin() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] inline _Ty* _Unchecked_end() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Mylast);
    }

    [[nodiscard]] inline const _Ty* _Unchecked_end() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Mylast);
    }

    [[nodiscard("This member function returns a bool indicating whether the collection is empty and has no other effects. " "It is not useful to call this member function and discard the return value. " "Use the 'clear()' member function if you want to erase all elements.")]] inline bool empty() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return _My_data._Myfirst == _My_data._Mylast;
    }

    [[nodiscard]] inline size_type size() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        return (::std:: min)(static_cast<size_type>(::std:: _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);
    }

    [[nodiscard]] inline _Ty& operator[](const size_type _Pos) noexcept  {
        auto& _My_data = _Mypair._Myval2;

        if (!(_Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1931, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1932 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1933 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline const _Ty& operator[](const size_type _Pos) const noexcept  {
        auto& _My_data = _Mypair._Myval2;

        if (!(_Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1941, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1942 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 1943 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline _Ty& at(const size_type _Pos) {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline const _Ty& at(const size_type _Pos) const {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] inline _Ty& front() noexcept  {
        auto& _My_data = _Mypair._Myval2;

        if (!(_My_data._Myfirst != _My_data._Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1968, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1970 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] inline const _Ty& front() const noexcept  {
        auto& _My_data = _Mypair._Myval2;

        if (!(_My_data._Myfirst != _My_data._Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1977, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1979 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] inline _Ty& back() noexcept  {
        auto& _My_data = _Mypair._Myval2;

        if (!(_My_data._Myfirst != _My_data._Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1986, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1988 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] inline const _Ty& back() const noexcept  {
        auto& _My_data = _Mypair._Myval2;

        if (!(_My_data._Myfirst != _My_data._Mylast)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 1995, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 1997 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    inline size_type _Calculate_growth(const size_type _Newsize) const {
        
        const size_type _Oldcapacity = capacity();
        const auto _Max              = max_size();

        if (_Oldcapacity > _Max - _Oldcapacity / 2) {
            return _Max; 
        }

        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

        if (_Geometric < _Newsize) {
            return _Newsize; 
        }

        return _Geometric; 
    }

    inline void _Buy_raw(size_type _Newcapacity) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        ; 
        ;

        const pointer _Newvec = ::std:: _Allocate_at_least_helper(_Getal(), _Newcapacity);
        _Myfirst              = _Newvec;
        _Mylast               = _Newvec;
        _Myend                = _Newvec + _Newcapacity;
    }

    inline void _Buy_nonzero(const size_type _Newcapacity) {
        









        if (_Newcapacity > max_size()) {
            _Xlength();
        }

        _Buy_raw(_Newcapacity);
    }

    inline void _Change_array(
        const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            ::std:: _Destroy_range(_Myfirst, _Mylast, _Al);
            ;
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));
        }

        _Myfirst = _Newvec;
        _Mylast  = _Newvec + _Newsize;
        _Myend   = _Newvec + _Newcapacity;
        ;
    }

    inline void _Tidy() noexcept { 
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            ::std:: _Destroy_range(_Myfirst, _Mylast, _Al);
            ;
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }
    }

    template <class... _Valty>
    inline void _Construct_n(__declspec(guard(overflow)) const size_type _Count, _Valty&&... _Val) {
        
        
        
        
        auto& _Al       = _Getal();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al);
        auto& _My_data  = _Mypair._Myval2;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            if constexpr (sizeof...(_Val) == 0) {
                _My_data._Mylast = ::std:: _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
            } else if constexpr (sizeof...(_Val) == 1) {
                ;
                _My_data._Mylast = ::std:: _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
            } else if constexpr (sizeof...(_Val) == 2) {
                _My_data._Mylast = ::std:: _Uninitialized_copy(::std:: forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
            } else {
                ; 
            }
            ;
            _Guard._Target = nullptr;
        }

        _Proxy._Release();
    }

    inline void _Move_assign_unequal_alloc(vector& _Right) {
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        const pointer _First = _Right_data._Myfirst;
        const pointer _Last  = _Right_data._Mylast;
        const auto _Newsize  = static_cast<size_type>(_Last - _First);

        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        constexpr bool _Nothrow_construct =
            conjunction_v<is_nothrow_move_constructible<_Ty>, _Uses_default_construct<_Alloc, _Ty*, _Ty>>;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
        if (_Newsize > _Oldcapacity) {
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _Uninitialized_move(_First, _Last, _Myfirst, _Al);
                ;
            } else {
                ;
                _Mylast = _Uninitialized_move(_First, _Last, _Myfirst, _Al);
            }

            return;
        }

        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            const pointer _Mid = _First + _Oldsize;
            ::std:: _Move_unchecked(_First, _Mid, _Myfirst);

            if constexpr (_Nothrow_construct) {
                ;
                _Mylast = _Uninitialized_move(_Mid, _Last, _Mylast, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_move(_Mid, _Last, _Mylast, _Al);
                ;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            ::std:: _Move_unchecked(_First, _Last, _Myfirst);
            _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
        }
    }

    [[noreturn]] static void _Xlength() {
        _Xlength_error("vector too long");
    }

    [[noreturn]] static void _Xrange() {
        _Xout_of_range("invalid vector subscript");
    }


    inline void _Orphan_range_unlocked(pointer _First, pointer _Last) const {
        _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
        while (*_Pnext) {
            const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
            const auto _Temp     = *_Pnext;
            if (_Pnextptr < _First || _Last < _Pnextptr) { 
                _Pnext = &_Temp->_Mynextiter;
            } else { 
                _Temp->_Myproxy = nullptr;
                *_Pnext         = _Temp->_Mynextiter;
            }
        }
    }

    void _Orphan_range_locked(pointer _First, pointer _Last) const {
        _Lockit _Lock(3);
        _Orphan_range_unlocked(_First, _Last);
    }

    inline void _Orphan_range(pointer _First, pointer _Last) const {
        




#line 2218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        {
            _Orphan_range_locked(_First, _Last);
        }
    }


#line 2225 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    [[nodiscard]] inline _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] inline iterator _Make_iterator(const pointer _Ptr) noexcept {
        return iterator(_Ptr, ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] inline iterator _Make_iterator_offset(const size_type _Offset) noexcept {
        
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst + _Offset, ::std:: addressof(_My_data));
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};





#line 2252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"




#line 2257 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

template <class _Alloc>
class vector<bool, _Alloc>;

using _Vbase = unsigned int; 

 constexpr int _VBITS = 8 * sizeof(_Vbase); 

 template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator==(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if (_Left.size() != _Right.size()) {
        return false;
    }

    if constexpr (is_same_v<_Ty, bool>) {
        return ::std:: equal(
            _Left._Myvec._Unchecked_begin(), _Left._Myvec._Unchecked_end(), _Right._Myvec._Unchecked_begin());
    } else {
        return ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
    }
}


template <class _Ty, class _Alloc>
[[nodiscard]] bool operator!=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Left == _Right);
}
#line 2285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
















template <class _Ret>
struct _Vbase_compare_three_way {
    [[nodiscard]] static constexpr _Ret operator()(
        const _Vbase _Left, const _Vbase _Right)  noexcept {
        const _Vbase _Differing_bits = _Left ^ _Right;

        if (_Differing_bits == 0) { 


#line 2311 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
            return 0;
#line 2313 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        }

        const int _Bit_index = _Countr_zero(_Differing_bits); 
        ; 

        const _Vbase _Mask = _Vbase{1} << _Bit_index; 

        


#line 2324 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        return (_Left & _Mask) == 0 ? -1 : 1;
#line 2326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }
};


























#line 2355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if constexpr (is_same_v<_Ty, bool>) {
        
        auto _First = _Left._Myvec._Unchecked_begin();
        auto _Other = _Right._Myvec._Unchecked_begin();

        const auto _Last = _First + (::std:: min)(_Left._Myvec.size(), _Right._Myvec.size());

        for (; _First != _Last; ++_First, (void) ++_Other) {
            using _Comp        = _Vbase_compare_three_way<signed char>;
            const auto _Result = _Comp{}(*_First, *_Other);

            if (_Result < 0) {
                return true;
            } else if (_Result > 0) {
                return false;
            }
        }

        return _Left.size() < _Right.size();
    } else {
        return ::std:: lexicographical_compare(
            _Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin(), _Right._Unchecked_end());
    }
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return _Right < _Left;
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator<=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty, class _Alloc>
[[nodiscard]] inline bool operator>=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    return !(_Left < _Right);
}
#line 2397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

 template <class _Ty, class _Alloc>
inline void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}











#line 2414 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

template <class _Alloc0>
struct _Wrap_alloc { 
    using _Alloc = _Alloc0;
};

template <class _Alvbase_wrapped>
class _Vb_iter_base : public _Iterator_base {
    
public:
    using _Alvbase         = typename _Alvbase_wrapped::_Alloc;
    using _Size_type       = typename allocator_traits<_Alvbase>::size_type;
    using _Difference_type = typename allocator_traits<_Alvbase>::difference_type;
    using _Mycont          = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

    static constexpr _Difference_type _VBITS_DIFF = _VBITS;

    inline _Vb_iter_base() = default;

    inline _Vb_iter_base(const _Vbase* _Ptr, _Size_type _Off, const _Container_base* _Mypvbool) noexcept
        : _Myptr(_Ptr), _Myoff(_Off) {
        this->_Adopt(_Mypvbool);
    }

    inline void _Advance(_Size_type _Off) noexcept {
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }


    inline _Difference_type _Total_off(const _Mycont* _Cont) const noexcept {
        return static_cast<_Difference_type>(_VBITS_DIFF * (_Myptr - _Cont->_Myvec.data()) + _Myoff);
    }
#line 2449 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    const _Vbase* _Myptr = nullptr;
    _Size_type _Myoff    = 0;
};

template <class _Alvbase_wrapped>
class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> {
    
private:
    using _Mybase          = _Vb_iter_base<_Alvbase_wrapped>;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

public:
    inline _Vb_reference(const _Vb_reference&) = default;

    inline _Vb_reference(const _Mybase& _Right) noexcept
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

    inline _Vb_reference& operator=(const _Vb_reference& _Right) noexcept {
        return *this = static_cast<bool>(_Right);
    }

    inline _Vb_reference& operator=(bool _Val) noexcept {
        if (_Val) {
            *const_cast<_Vbase*>(_Getptr()) |= _Mask();
        } else {
            *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
        }

        return *this;
    }











#line 2493 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void flip() noexcept {
        *const_cast<_Vbase*>(_Getptr()) ^= _Mask();
    }

    inline operator bool() const noexcept {
        return (*_Getptr() & _Mask()) != 0;
    }

    inline const _Vbase* _Getptr() const noexcept {

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        if (!(_Cont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2505, 0, "%s", "cannot dereference value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(this->_Total_off(_Cont) <= static_cast<_Difference_type>(_Cont->_Mysize))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2507, 0, "%s", "vector<bool> iterator not dereferenceable")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 2508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 2509 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return this->_Myptr;
    }

    friend inline void swap(_Vb_reference _Left, _Vb_reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

protected:
    inline _Vbase _Mask() const noexcept {
        return static_cast<_Vbase>(1) << this->_Myoff;
    }
};

template <class _Alvbase_wrapped>
class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> {
public:
    using _Mybase         = _Vb_iter_base<_Alvbase_wrapped>;
    using _Mycont         = typename _Mybase::_Mycont;
    using _Size_type      = typename _Mybase::_Size_type;
    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difference_type;
    using pointer           = const_reference*;
    using reference         = const_reference;

    inline _Vb_const_iterator() = default;

    inline _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept
        : _Mybase(_Ptr, 0, _Mypvbool) {}

    [[nodiscard]] inline const_reference operator*() const noexcept {

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        if (!(_Cont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2548, 0, "%s", "cannot dereference value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(this->_Total_off(_Cont) < static_cast<difference_type>(_Cont->_Mysize))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2550, 0, "%s", "vector<bool> iterator not dereferenceable")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 2551 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 2552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return _Reft(*this);
    }

    inline _Vb_const_iterator& operator++() noexcept {
        _Inc();
        return *this;
    }

    inline _Vb_const_iterator operator++(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Inc();
        return _Tmp;
    }

    inline _Vb_const_iterator& operator--() noexcept {
        _Dec();
        return *this;
    }

    inline _Vb_const_iterator operator--(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Dec();
        return _Tmp;
    }

    inline _Vb_const_iterator& operator+=(const difference_type _Off) noexcept {

        if (_Off != 0) {
            const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
            if (!(_Cont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2582, 0, "%s", "cannot seek value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
            const auto _Start_offset = this->_Total_off(_Cont);
            if (_Off < 0) {
                if (!(-_Start_offset <= _Off)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2585, 0, "%s", "cannot seek vector<bool> iterator before begin")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
            } else if (0 < _Off) {
                if (!(_Off <= static_cast<difference_type>(_Cont->_Mysize - _Start_offset))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2588, 0, "%s", "cannot seek vector<bool> iterator after end")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 2589 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
            }
        }
#line 2592 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off)) { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
            this->_Myoff %= _VBITS;
        } else { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr += this->_Myoff / _VBITS;
            this->_Myoff %= _VBITS;
        }
        return *this;
    }

    [[nodiscard]] inline _Vb_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend inline _Vb_const_iterator operator+(
        const difference_type _Off, _Vb_const_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    inline _Vb_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] inline _Vb_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline difference_type operator-(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return static_cast<difference_type>(_Mybase::_VBITS_DIFF * (this->_Myptr - _Right._Myptr))
             + static_cast<difference_type>(this->_Myoff) - static_cast<difference_type>(_Right._Myoff);
    }

    [[nodiscard]] inline const_reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] inline bool operator==(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff;
    }









#line 2651 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    [[nodiscard]] bool operator!=(const _Vb_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    [[nodiscard]] bool operator<(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myptr < _Right._Myptr || (this->_Myptr == _Right._Myptr && this->_Myoff < _Right._Myoff);
    }

    [[nodiscard]] bool operator>(const _Vb_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    [[nodiscard]] bool operator<=(const _Vb_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    [[nodiscard]] bool operator>=(const _Vb_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#line 2672 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void _Compat(const _Vb_const_iterator& _Right) const noexcept {
        


#line 2678 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        if (!(this->_Getcont() == _Right._Getcont())) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2678, 0, "%s", "vector<bool> iterators incompatible")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 2680 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }


    using _Prevent_inheriting_unwrap = _Vb_const_iterator;

    friend inline void _Verify_range(const _Vb_const_iterator& _First, const _Vb_const_iterator& _Last) noexcept {
        
        if (!(_First <= _Last)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2687, 0, "%s", "vector<bool> iterator range transposed")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
    }
#line 2690 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void _Dec() noexcept { 

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        if (!(_Cont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2694, 0, "%s", "cannot decrement value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(this->_Total_off(_Cont) > 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2695, 0, "%s", "cannot decrement vector<bool> begin iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 2697 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        if (this->_Myoff != 0) {
            --this->_Myoff;
        } else { 
            this->_Myoff = _VBITS - 1;
            --this->_Myptr;
        }
    }

    inline void _Inc() noexcept { 

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        if (!(_Cont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2709, 0, "%s", "cannot increment value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(this->_Total_off(_Cont) < static_cast<difference_type>(_Cont->_Mysize))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2711, 0, "%s", "cannot increment vector<bool> end iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 2712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 2713 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        if (this->_Myoff < _VBITS - 1) {
            ++this->_Myoff;
        } else { 
            this->_Myoff = 0;
            ++this->_Myptr;
        }
    }
};

template <class _Alvbase_wrapped>
class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> {
public:
    using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;
    using _Mycont = typename _Mybase::_Mycont;

    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;

    using _Mybase::_Mybase;

    [[nodiscard]] inline reference operator*() const noexcept {

        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        if (!(_Cont)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2743, 0, "%s", "cannot dereference value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        if (!(this->_Total_off(_Cont) < static_cast<difference_type>(_Cont->_Mysize))) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 2745, 0, "%s", "vector<bool> iterator not dereferenceable")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 2746 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 2747 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return _Reft(*this);
    }

    inline _Vb_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    inline _Vb_iterator operator++(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    inline _Vb_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    inline _Vb_iterator operator--(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    inline _Vb_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] inline _Vb_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend inline _Vb_iterator operator+(const difference_type _Off, _Vb_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    inline _Vb_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] inline _Vb_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] inline reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};

template <class _Alloc>
class _Vb_val : public _Container_base {
public:
    using _Alvbase         = _Rebind_alloc_t<_Alloc, _Vbase>;
    using _Alvbase_traits  = allocator_traits<_Alvbase>;
    using _Vectype         = vector<_Vbase, _Alvbase>;
    using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
    using size_type        = typename _Alvbase_traits::size_type;

    inline _Vb_val() noexcept(is_nothrow_default_constructible_v<_Vectype>) : _Myvec(), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(const _Alloc& _Al) noexcept : _Myvec(static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(size_type _Count, const bool& _Val)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0)), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
        : _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(_Vb_val&& _Right) noexcept(is_nothrow_move_constructible_v<_Vectype>)
        : _Myvec(::std:: move(_Right._Myvec)), _Mysize(::std:: exchange(_Right._Mysize, size_type{0})) {
        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline _Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
        noexcept(is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
        : _Myvec(::std:: move(_Right._Myvec), static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        if (_Right._Myvec.empty()) {
            
            _Right._Mysize = 0;
        }

        this->_Alloc_proxy(static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(_Getal()));
    }

    inline ~_Vb_val() noexcept {

        this->_Orphan_all();
        auto&& _Alproxy = static_cast<_Rebind_alloc_t<_Alvbase, _Container_proxy>>(this->_Getal());
        _Delete_plain_internal(_Alproxy, ::std:: exchange(this->_Myproxy, nullptr));
#line 2867 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"





#line 2873 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }

    inline _Alvbase& _Getal() noexcept {
        return _Myvec._Getal();
    }

    inline const _Alvbase& _Getal() const noexcept {
        return _Myvec._Getal();
    }

    static inline size_type _Nw(size_type _Count) noexcept {
        return (_Count + _VBITS - 1) / _VBITS;
    }

    inline void _Emplace_back_unchecked(const _Vbase _Val) noexcept {
        ;
        _Myvec._Emplace_back_with_unused_capacity(_Val);
    }

    _Vectype _Myvec; 
    size_type _Mysize; 
};

template <class _Alloc>
class vector<bool, _Alloc> : public _Vb_val<_Alloc> {
public:
    static_assert(!0 || is_same_v<bool, typename _Alloc::value_type>,
        "vector<bool, Allocator>" " requires that Allocator's value_type match " "bool" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");

    using _Mybase          = _Vb_val<_Alloc>;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;

    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;

    using reference       = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using value_type      = bool;

    using _Reft          = reference;
    using iterator       = _Vb_iterator<_Alvbase_wrapped>;
    using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    enum { _EEN_VBITS = _VBITS }; 

    inline vector() noexcept(is_nothrow_default_constructible_v<_Alloc>) : _Mybase(_Alloc()) {}

    inline explicit vector(const _Alloc& _Al) noexcept : _Mybase(_Al) {}

    inline explicit vector(__declspec(guard(overflow)) size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, false, _Al) {
        _Trim(_Count);
    }

    inline vector(__declspec(guard(overflow)) size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) {
        _Trim(_Count);
    }

    inline vector(const vector& _Right) : _Mybase(_Right) {}

    inline vector(const vector& _Right, const _Identity_t<_Alloc>& _Al) : _Mybase(_Right, _Al) {}

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mybase(_Al) {
        insert(begin(), _First, _Last);
    }












#line 2961 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline vector(vector&& _Right) noexcept : _Mybase(::std:: move(_Right)) {
        this->_Swap_proxy_and_iterators(_Right);
    }

    inline vector(vector&& _Right, const _Identity_t<_Alloc>& _Al)
        noexcept(is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>) 
        : _Mybase(::std:: move(_Right), _Al) {
        if constexpr (!_Alvbase_traits::is_always_equal::value) {
            if (this->_Getal() != _Right._Getal()) {
                return;
            }
        }

        this->_Swap_proxy_and_iterators(_Right);
    }

    inline vector& operator=(vector&& _Right)
        noexcept(_Choose_pocma_v<_Alvbase> != _Pocma_values::_No_propagate_allocators) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }




#line 2988 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        this->_Orphan_all();
        auto& _Al                 = this->_Getal();
        auto& _Right_al           = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alvbase>;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
            if (_Al != _Right_al) { 
                
                _Alproxy_type _Oldal(_Al);
                _Alproxy_type _Right_proxy_al(_Right_al);
                _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
                this->_Myvec  = ::std:: move(_Right._Myvec);
                this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
                _Proxy._Bind(_Oldal, this);
                this->_Swap_proxy_and_iterators(_Right);
                return *this;
            }
        } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            this->_Myvec  = ::std:: move(_Right._Myvec);
            this->_Mysize = _Right._Mysize;
            if (_Right._Myvec.empty()) {
                
                _Right._Mysize = 0;
            }

            if (_Al == _Right_al) {
                this->_Swap_proxy_and_iterators(_Right);
            }
            return *this;
        }

        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});
        this->_Swap_proxy_and_iterators(_Right);

#line 3024 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        return *this;
    }

    template <class... _Valty>
    inline void emplace_back(_Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        push_back(_Tmp);



#line 3035 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    }

    template <class... _Valty>
    inline iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        return insert(_Where, _Tmp);
    }

    inline vector(initializer_list<bool> _Ilist, const _Alloc& _Al = allocator_type()) : _Mybase(0, false, _Al) {
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }

    inline vector& operator=(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    inline void assign(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
    }

    inline iterator insert(const_iterator _Where, initializer_list<bool> _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    inline ~vector() noexcept {}

    inline vector& operator=(const vector& _Right) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }




#line 3071 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        this->_Orphan_all();
        auto& _Al       = this->_Getal();
        auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alvbase>) {
            if (_Al != _Right_al) {
                
                using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
                _Alproxy_type _Oldal(_Al);
                _Alproxy_type _Right_proxy_al(_Right_al);
                _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
                this->_Myvec  = _Right._Myvec;
                this->_Mysize = _Right._Mysize;
                _Proxy._Bind(_Oldal, this);
                return *this;
            }
        }

        this->_Myvec  = _Right._Myvec;
        this->_Mysize = _Right._Mysize;
#line 3091 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *this;
    }

    inline void reserve(__declspec(guard(overflow)) size_type _Count) {
        this->_Myvec.reserve(this->_Nw(_Count));
    }

    [[nodiscard]] inline size_type capacity() const noexcept {
        return this->_Myvec.capacity() * _VBITS;
    }

    [[nodiscard]] inline iterator begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline const_iterator begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline iterator end() noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator end() const noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] inline const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] inline const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] inline const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] inline iterator _Unchecked_begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline const_iterator _Unchecked_begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] inline iterator _Unchecked_end() noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] inline const_iterator _Unchecked_end() const noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    inline void shrink_to_fit() {
        if (this->_Myvec.capacity() != this->_Myvec.size()) {
            this->_Orphan_all();
            this->_Myvec.shrink_to_fit();
        }
    }

    inline iterator _Make_iter(const_iterator _Where) noexcept {
        iterator _Tmp = begin();
        if (0 < this->_Mysize) {
            _Tmp += _Where - begin();
        }

        return _Tmp;
    }

    [[nodiscard]] inline reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] inline const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] inline reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] inline const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    inline void resize(__declspec(guard(overflow)) size_type _Newsize, bool _Val = false) {
        if (size() < _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize < size()) {
            erase(begin() + static_cast<difference_type>(_Newsize), end());
        }
    }

    [[nodiscard]] inline size_type size() const noexcept {
        return this->_Mysize;
    }

    [[nodiscard]] inline size_type max_size() const noexcept {
        constexpr auto _Diff_max  = static_cast<size_type>(::std:: _Max_limit<difference_type>());
        const size_type _Ints_max = this->_Myvec.max_size();
        if (_Ints_max > _Diff_max / _VBITS) { 
            return _Diff_max;
        }

        
        return _Ints_max * _VBITS;
    }

    [[nodiscard("This member function returns a bool indicating whether the collection is empty and has no other effects. " "It is not useful to call this member function and discard the return value. " "Use the 'clear()' member function if you want to erase all elements.")]] inline bool empty() const noexcept {
        return this->_Mysize == 0;
    }

    [[nodiscard]] inline allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(this->_Myvec.get_allocator());
    }

    [[nodiscard]] inline const_reference at(size_type _Off) const {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] inline reference at(size_type _Off) {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] inline const_reference operator[](size_type _Off) const noexcept  {

        if (!(_Off < this->_Mysize)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3232, 0, "%s", "vector<bool> subscript out of range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] inline reference operator[](size_type _Off) noexcept  {

        if (!(_Off < this->_Mysize)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3242, 0, "%s", "vector<bool> subscript out of range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] inline reference front() noexcept  {

        if (!(this->_Mysize != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3252, 0, "%s", "front() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *begin();
    }

    [[nodiscard]] inline const_reference front() const noexcept  {

        if (!(this->_Mysize != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3260, 0, "%s", "front() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3262 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *begin();
    }

    [[nodiscard]] inline reference back() noexcept  {

        if (!(this->_Mysize != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3268, 0, "%s", "back() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3270 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *(end() - 1);
    }

    [[nodiscard]] inline const_reference back() const noexcept  {

        if (!(this->_Mysize != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3276, 0, "%s", "back() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        return *(end() - 1);
    }

    inline void push_back(const bool& _Val) {
        insert(end(), _Val);
    }






#line 3292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void pop_back() noexcept  {

        if (!(this->_Mysize != 0)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3295, 0, "%s", "pop_back() called on empty vector<bool>")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        erase(end() - 1);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline void assign(_Iter _First, _Iter _Last) {
        clear();
        insert(begin(), _First, _Last);
    }





























































#line 3368 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void assign(__declspec(guard(overflow)) size_type _Count, const bool& _Val) {
        clear();
        _Insert_n(begin(), _Count, _Val);
    }

    inline iterator insert(const_iterator _Where, const bool& _Val) {
        return _Insert_n(_Where, size_type{1}, _Val);
    }

    inline iterator insert(const_iterator _Where, __declspec(guard(overflow)) size_type _Count, const bool& _Val) {
        return _Insert_n(_Where, _Count, _Val);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    inline iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const difference_type _Saved_offset = _Where - begin();
        ::std:: _Adl_verify_range(_First, _Last);
        auto _UFirst      = ::std:: _Get_unwrapped(_First);
        const auto _ULast = ::std:: _Get_unwrapped(_Last);

        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = ::std:: _Convert_size<size_type>(_Length);
            const auto _Off    = static_cast<difference_type>(_Insert_x(_Where, _Count));
            ::std:: _Copy_unchecked(_UFirst, _ULast, begin() + _Off);






#line 3401 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        } else {
            const auto _Old_size = this->_Mysize;
            for (; _UFirst != _ULast; ++_UFirst) {
                emplace_back(*_UFirst);
            }

            _Orphan_range(static_cast<size_type>(_Saved_offset), _Old_size);
#line 3409 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
            ::std:: rotate(begin() + _Saved_offset, begin() + static_cast<difference_type>(_Old_size), end());
        }

        return begin() + _Saved_offset;
    }


























#line 3441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline iterator erase(const_iterator _Where_arg) noexcept  {
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();


        if (!(end() > _Where)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3447, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3449 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        ::std:: copy(_Next_iter(_Where), end(), _Where);


        _Orphan_range(static_cast<size_type>(_Off), this->_Mysize);
#line 3455 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        _Trim(this->_Mysize - 1);
        return begin() + _Off;
    }

    inline iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept
     {
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();

        if (_First != _Last) { 

            if (!(_Last >= _First && end() >= _Last)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3468, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
#line 3470 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

            iterator _Next      = ::std:: copy(_Last, end(), _First);
            const auto _Newsize = static_cast<size_type>(_Next - begin());


            _Orphan_range(_Newsize, this->_Mysize);
#line 3477 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

            _Trim(_Newsize);
        }
        return begin() + _Off;
    }

    inline void clear() noexcept {
        this->_Orphan_all();
        this->_Myvec.clear();
        this->_Mysize = 0;
    }

    inline void flip() noexcept { 
        for (auto& _Elem : this->_Myvec) {
            _Elem = ~_Elem;
        }

        _Trim(this->_Mysize);
    }

    inline void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            this->_Swap_proxy_and_iterators(_Right);
            this->_Myvec.swap(_Right._Myvec);
            ::std:: swap(this->_Mysize, _Right._Mysize);
        }
    }

    static inline void swap(reference _Left, reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

    friend hash<vector<bool, _Alloc>>;

    inline iterator _Insert_n(const_iterator _Where, size_type _Count, const bool& _Val) {
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast<difference_type>(_Off);
        ::std:: fill_n(_Result, _Count, _Val);
        return _Result;
    }

    inline size_type _Insert_x(const_iterator _Where, size_type _Count) {
        const difference_type _Off = _Where - begin();


        if (!(end() >= _Where)) { (void) ((1 != _CrtDbgReport(2, "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector", 3524, 0, "%s", "vector<bool> insert iterator outside range")) || (__debugbreak(), 0)); ::_invoke_watson(nullptr, nullptr, nullptr, 0, 0); } ;
        const bool _Realloc = capacity() - size() < _Count;
#line 3527 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

        if (_Count != 0) {
            if (max_size() - size() < _Count) {
                _Xlen(); 
            }


            _Orphan_range(static_cast<size_type>(_Realloc ? 0 : _Off), this->_Mysize);
#line 3536 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
            this->_Myvec.resize(this->_Nw(size() + _Count), 0);
            if (empty()) {
                this->_Mysize += _Count;
            } else { 
                iterator _Oldend = end();
                this->_Mysize += _Count;
                ::std:: copy_backward(begin() + _Off, _Oldend, end());
            }
        }

        return static_cast<size_type>(_Off);
    }


    inline void _Orphan_range_unlocked(size_type _Offlo, size_type _Offhi) const {
        const auto _Base = this->_Myvec.data();

        _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
        while (*_Pnext) { 
            const auto& _Pnextiter = static_cast<typename const_iterator::_Mybase&>(**_Pnext);
            const auto _Temp       = *_Pnext;
            if (!_Pnextiter._Myptr) { 
                _Temp->_Myproxy = nullptr;
                *_Pnext         = _Temp->_Mynextiter;
                continue;
            }
            const auto _Off =
                static_cast<size_type>(const_iterator::_VBITS_DIFF * (_Pnextiter._Myptr - _Base)) + _Pnextiter._Myoff;
            if (_Off < _Offlo || _Offhi < _Off) {
                _Pnext = &_Temp->_Mynextiter;
            } else { 
                _Temp->_Myproxy = nullptr;
                *_Pnext         = _Temp->_Mynextiter;
            }
        }
    }

    void _Orphan_range_locked(size_type _Offlo, size_type _Offhi) const {
        _Lockit _Lock(3);
        _Orphan_range_unlocked(_Offlo, _Offhi);
    }

    inline void _Orphan_range(size_type _Offlo, size_type _Offhi) const {




#line 3584 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
        {
            _Orphan_range_locked(_Offlo, _Offhi);
        }
    }
#line 3589 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

    inline void _Trim(size_type _Size) {
        if (max_size() < _Size) {
            _Xlen(); 
        }

        const size_type _Words = this->_Nw(_Size);
        if (_Words < this->_Myvec.size()) {
            this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());
        }

        this->_Mysize = _Size;
        _Size %= _VBITS;
        if (0 < _Size) {
            this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
        }
    }

    [[noreturn]] static void _Xlen() {
        _Xlength_error("vector<bool> too long");
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid vector<bool> subscript");
    }
};

template <class _Alloc>
struct hash<vector<bool, _Alloc>> {
    using argument_type  = vector<bool, _Alloc>;
    using result_type    = size_t;

    [[nodiscard]] static size_t operator()(
        const vector<bool, _Alloc>& _Keyval)  noexcept {
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};






#line 3633 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

























#line 3659 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"

template <class _Alloc, bool _RequiresMutable>
constexpr bool _Is_vb_iterator<_Vb_iterator<_Alloc>, _RequiresMutable> = true;

template <class _Alloc>
constexpr bool _Is_vb_iterator<_Vb_const_iterator<_Alloc>, false> = true;

template <class _VbIt>
inline void _Fill_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    
    if (_First == _Last) {
        return;
    }

    _Vbase* _VbFirst      = const_cast<_Vbase*>(_First._Myptr);
    _Vbase* const _VbLast = const_cast<_Vbase*>(_Last._Myptr);

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;
    const auto _FirstDestMask   = ~_FirstSourceMask;
    const auto _FillVal         = static_cast<_Vbase>(_Val ? -1 : 0);

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _DestMask       = _FirstDestMask | _LastDestMask;
        *_VbFirst                  = (*_VbFirst & _DestMask) | (_FillVal & _SourceMask);
        return;
    }

    *_VbFirst = (*_VbFirst & _FirstDestMask) | (_FillVal & _FirstSourceMask);
    ++_VbFirst;







#line 3700 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    {
        const auto _VbFirst_ch = reinterpret_cast<const char*>(_VbFirst);
        const auto _VbLast_ch  = reinterpret_cast<const char*>(_VbLast);
        const auto _Count_ch   = static_cast<size_t>(_VbLast_ch - _VbFirst_ch);
        const auto _ValChar    = static_cast<unsigned char>(_Val ? -1 : 0);
        :: memset(_VbFirst, _ValChar, _Count_ch);
        _VbFirst = _VbLast;
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        *_VbFirst                  = (*_VbFirst & _LastDestMask) | (_FillVal & _LastSourceMask);
    }
}

template <class _VbIt>
[[nodiscard]] inline _VbIt _Find_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    
    if (_First == _Last) {
        return _First;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) & _SourceMask;
        const auto _Count          = _Countr_zero(_SelectVal);
        return _Count == _VBITS ? _Last : _First + static_cast<ptrdiff_t>(_Count - _First._Myoff);
    }

    const auto _FirstVal   = (_Val ? *_VbFirst : ~*_VbFirst) & _FirstSourceMask;
    const auto _FirstCount = _Countr_zero(_FirstVal);
    if (_FirstCount != _VBITS) {
        return _First + static_cast<ptrdiff_t>(_FirstCount - _First._Myoff);
    }
    ++_VbFirst;

    _Iter_diff_t<_VbIt> _TotalCount = static_cast<ptrdiff_t>(_VBITS - _First._Myoff);
    for (; _VbFirst != _VbLast; ++_VbFirst, _TotalCount += _VBITS) {
        const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
        const auto _Count     = _Countr_zero(_SelectVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) & _LastSourceMask;
        const auto _Count          = _Countr_zero(_LastVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    return _Last;
}

template <class _VbIt>
[[nodiscard]] inline _Iter_diff_t<_VbIt> _Count_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    if (_First == _Last) {
        return 0;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) & _SourceMask;
        return _Popcount(_SelectVal);
    }

    return _Select_popcount_impl<_Vbase>(
        [_Last, _Val, _VbFirst, _VbLast, _FirstSourceMask](auto _Popcount_impl) mutable noexcept {
            const auto _FirstVal       = (_Val ? *_VbFirst : ~*_VbFirst) & _FirstSourceMask;
            _Iter_diff_t<_VbIt> _Count = _Popcount_impl(_FirstVal);
            ++_VbFirst;

            for (; _VbFirst != _VbLast; ++_VbFirst) {
                const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
                _Count += _Popcount_impl(_SelectVal);
            }

            if (_Last._Myoff != 0) {
                const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
                const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) & _LastSourceMask;
                _Count += _Popcount_impl(_LastVal);
            }

            return _Count;
        });
}

template <class _VbIt, class _OutIt>
inline _OutIt _Copy_vbool(_VbIt _First, _VbIt _Last, _OutIt _Dest) {
    
    if (_First == _Last) {
        return _Dest;
    }

    auto _VbFirst       = _First._Myptr;
    const auto _VbLast  = _Last._Myptr;
    auto _VbDest        = const_cast<_Vbase*>(_Dest._Myptr);
    const auto _DestEnd = _Dest + (_Last - _First);

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;
    const auto _FirstDestMask   = _Dest._Myoff == 0 ? 0 : (static_cast<_Vbase>(-1) >> (_VBITS - _Dest._Myoff));
    const auto _LastSourceMask  = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
    const auto _LastDestMask    = static_cast<_Vbase>(-1) << _DestEnd._Myoff;

    const bool _IsSingleBlockSource = _VbFirst == _VbLast;
    const bool _IsSingleBlockDest   = _VbDest == _DestEnd._Myptr - (_DestEnd._Myoff == 0 ? 1 : 0);
    const bool _IsRightShift        = _Dest._Myoff < _First._Myoff;
    if (_IsSingleBlockSource) {
        
        const auto _SourceMask  = _FirstSourceMask & _LastSourceMask;
        const auto _SourceShift = _IsRightShift ? _First._Myoff - _Dest._Myoff : _Dest._Myoff - _First._Myoff;
        const auto _SourceVal   = _IsRightShift ? (*_VbFirst & _SourceMask) >> _SourceShift 
                                                : (*_VbFirst & _SourceMask) << _SourceShift;
        if (_IsSingleBlockDest) {
            const auto _DestMask = _FirstDestMask | (_DestEnd._Myoff == 0 ? 0 : _LastDestMask);
            *_VbDest             = (*_VbDest & _DestMask) | _SourceVal;
        } else {
            *_VbDest = (*_VbDest & _FirstDestMask) | _SourceVal;
            ++_VbDest;

            const auto _LastShift     = _Last._Myoff - _DestEnd._Myoff;
            const auto _LastSourceVal = (*_VbFirst & _SourceMask) >> _LastShift;
            *_VbDest                  = (*_VbDest & _LastDestMask) | _LastSourceVal;
        }

        return _DestEnd;
    } else if (_IsSingleBlockDest) {
        const auto _SourceShift = _IsRightShift ? _First._Myoff - _Dest._Myoff : _Dest._Myoff - _First._Myoff;
        const auto _SourceVal   = _IsRightShift ? (*_VbFirst & _FirstSourceMask) >> _SourceShift 
                                                : (*_VbFirst & _FirstSourceMask) << _SourceShift;

        const auto _DestMask = _FirstDestMask | (_DestEnd._Myoff == 0 ? 0 : _LastDestMask);
        if (_Last._Myoff != 0) {
            const auto _LastShift     = _DestEnd._Myoff - _Last._Myoff;
            const auto _LastSourceVal = (*_VbLast & _LastSourceMask) << _LastShift;
            *_VbDest                  = (*_VbDest & _DestMask) | _SourceVal | _LastSourceVal;
        } else {
            *_VbDest = (*_VbDest & _DestMask) | _SourceVal;
        }

        return _DestEnd;
    }



#line 3864 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
    {
        
        const auto _UnalignedFirstBits = _First._Myoff & _Vbase{7};
        const auto _UnalignedDestBits  = _Dest._Myoff & _Vbase{7};
        if (_UnalignedFirstBits == _UnalignedDestBits) {
            const auto _UnalignedLastBits = _Last._Myoff & _Vbase{7};

            auto _VbFirst_ch      = reinterpret_cast<const char*>(_VbFirst) + (_First._Myoff - _UnalignedFirstBits) / 8;
            const auto _VbLast_ch = reinterpret_cast<const char*>(_VbLast) + (_Last._Myoff - _UnalignedLastBits) / 8;
            auto _VbDest_ch       = reinterpret_cast<char*>(_VbDest) + (_Dest._Myoff - _UnalignedDestBits) / 8;

            
            if (_UnalignedFirstBits != 0) {
                const auto _SourceBitMask = static_cast<char>(0xff << _UnalignedFirstBits);
                const auto _DestBitMask   = static_cast<char>(0xff >> (8 - _UnalignedFirstBits));
                *_VbDest_ch               = (*_VbDest_ch & _DestBitMask) | (*_VbFirst_ch & _SourceBitMask);
                ++_VbFirst_ch;
                ++_VbDest_ch;
            }

            _VbDest_ch = _Copy_unchecked(_VbFirst_ch, _VbLast_ch, _VbDest_ch);

            
            if (_UnalignedLastBits != 0) {
                const auto _SourceBitMask = static_cast<char>(0xff >> (8 - _UnalignedLastBits));
                const auto _DestBitMask   = static_cast<char>(0xff << _UnalignedLastBits);
                *_VbDest_ch               = (*_VbDest_ch & _DestBitMask) | (*_VbLast_ch & _SourceBitMask);
            }

            return _DestEnd;
        }
    }

    
    if (_IsRightShift) {
        const auto _SourceShift = _First._Myoff - _Dest._Myoff;
        const auto _CarryShift  = _VBITS - _SourceShift;
        const auto _CarryMask   = static_cast<_Vbase>(-1) >> _SourceShift;
        const auto _DestMask    = ~_CarryMask;

        const auto _FirstSourceVal = (*_VbFirst & _FirstSourceMask) >> _SourceShift;
        *_VbDest                   = (*_VbDest & _FirstDestMask) | _FirstSourceVal;

        ++_VbFirst;
        for (; _VbFirst != _VbLast; ++_VbFirst) {
            const auto _CarryVal = *_VbFirst << _CarryShift;
            *_VbDest             = (*_VbDest & _CarryMask) | _CarryVal;

            ++_VbDest;
            const auto _SourceVal = *_VbFirst >> _SourceShift;
            *_VbDest              = (*_VbDest & _DestMask) | _SourceVal;
        }

        if (_Last._Myoff != 0) {
            const auto _CarryVal = (*_VbFirst & _LastSourceMask) << _CarryShift;
            if (_Last._Myoff >= _SourceShift) {
                *_VbDest = (*_VbDest & _CarryMask) | _CarryVal;

                
                if (_Last._Myoff != _SourceShift) {
                    ++_VbDest;
                    const auto _SourceVal = (*_VbFirst & _LastSourceMask) >> _SourceShift;
                    *_VbDest              = (*_VbDest & _LastDestMask) | _SourceVal;
                }
            } else {
                
                const auto _FinalMask = _CarryMask | _LastDestMask;
                *_VbDest              = (*_VbDest & _FinalMask) | _CarryVal;
            }
        }
    } else {
        const auto _SourceShift = _Dest._Myoff - _First._Myoff;
        const auto _CarryShift  = _VBITS - _SourceShift;

        const auto _FirstSourceVal = (*_VbFirst & _FirstSourceMask) << _SourceShift;
        *_VbDest                   = (*_VbDest & _FirstDestMask) | _FirstSourceVal;
        auto _CarryVal             = *_VbFirst >> _CarryShift;

        ++_VbFirst;
        ++_VbDest;
        for (; _VbFirst != _VbLast; ++_VbFirst, ++_VbDest) {
            const auto _SourceVal = *_VbFirst << _SourceShift;
            *_VbDest              = _CarryVal | _SourceVal;
            _CarryVal             = *_VbFirst >> _CarryShift;
        }

        if (_Last._Myoff >= _CarryShift) {
            const auto _SourceVal = *_VbFirst << _SourceShift;
            *_VbDest              = _CarryVal | _SourceVal;
            _CarryVal             = *_VbFirst >> _CarryShift;

            
            if (_Last._Myoff != _CarryShift) {
                ++_VbDest;
                const auto _LastCarryMask = ~_LastDestMask;
                *_VbDest                  = (*_VbDest & _LastDestMask) | (_CarryVal & _LastCarryMask);
            }
        } else if (_Last._Myoff != 0) {
            
            const auto _LastSourceVal = (*_VbFirst & _LastSourceMask) << _SourceShift;
            *_VbDest                  = (*_VbDest & _LastDestMask) | _CarryVal | _LastSourceVal;
        } else {
            
            *_VbDest = (*_VbDest & _LastDestMask) | _CarryVal;
        }
    }

    return _DestEnd;
}








} 



#pragma warning(pop)
#pragma pack(pop)
#line 3988 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#line 3989 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\vector"
#pragma external_header(pop)
#line 3 "C:\\Users\\rapul\\FYSM\\Impi\\Impi\\headers\\rendering\\assets\\SphereMesh.h"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"


























































extern "C" {
#line 61 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"





  
    
  

#line 71 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
#line 72 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"


  


    
  #line 79 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
#line 80 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"


  


    
  #line 87 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
#line 88 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"


  
    
      
        
      #line 95 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
    

#line 98 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
  #line 99 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"

  
    #pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winpackagefamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winpackagefamily.h"
#pragma once
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winpackagefamily.h"



#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winpackagefamily.h"


























































#pragma warning(pop)
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winpackagefamily.h"
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winpackagefamily.h"

#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winpackagefamily.h"
#pragma external_header(pop)
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"































































#line 91 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"



















































#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"



#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"






#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"





#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"



#line 169 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"





#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"











#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"






































 

















#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"



#pragma warning(pop)
#line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"
#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"

#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared\\winapifamily.h"
#pragma external_header(pop)
#line 102 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
    

#line 105 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
  #line 106 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"

  
    
  #line 110 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
#line 111 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"




  
#line 117 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"




  



















#line 142 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
    
  #line 144 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
#line 145 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"




  


#line 153 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"



#line 157 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"



#line 161 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"







typedef void (*GLADapiproc)(void);

typedef GLADapiproc (*GLADloadfunc)(const char *name);
typedef GLADapiproc (*GLADuserptrloadfunc)(void *userptr, const char *name);

typedef void (*GLADprecallback)(const char *name, GLADapiproc apiproc, int len_args, ...);
typedef void (*GLADpostcallback)(void *ret, const char *name, GLADapiproc apiproc, int len_args, ...);

#line 177 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"






























































































#line 96 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"










#line 107 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"







#line 115 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"








    



#line 128 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"








#line 137 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"

#line 139 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"
































#line 172 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"












#line 185 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"




typedef __int32                 khronos_int32_t;
typedef unsigned __int32        khronos_uint32_t;
typedef __int64                 khronos_int64_t;
typedef unsigned __int64        khronos_uint64_t;











































#line 237 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"





typedef signed   char          khronos_int8_t;
typedef unsigned char          khronos_uint8_t;
typedef signed   short int     khronos_int16_t;
typedef unsigned short int     khronos_uint16_t;










typedef signed   long long int khronos_intptr_t;
typedef unsigned long long int khronos_uintptr_t;



#line 262 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"


typedef signed   long long int khronos_ssize_t;
typedef unsigned long long int khronos_usize_t;



#line 270 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"





typedef          float         khronos_float_t;
#line 277 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"











typedef khronos_uint64_t       khronos_utime_nanoseconds_t;
typedef khronos_int64_t        khronos_stime_nanoseconds_t;
#line 291 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"






#line 298 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"







typedef enum {
    KHRONOS_FALSE = 0,
    KHRONOS_TRUE  = 1,
    KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 0x7FFFFFFF
} khronos_boolean_enum_t;

#line 312 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\KHR\\khrplatform.h"
#line 4658 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef khronos_int8_t GLbyte;
typedef khronos_uint8_t GLubyte;
typedef khronos_int16_t GLshort;
typedef khronos_uint16_t GLushort;
typedef int GLint;
typedef unsigned int GLuint;
typedef khronos_int32_t GLclampx;
typedef int GLsizei;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void *GLeglClientBufferEXT;
typedef void *GLeglImageOES;
typedef char GLchar;
typedef char GLcharARB;



typedef unsigned int GLhandleARB;
#line 4683 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
typedef khronos_uint16_t GLhalf;
typedef khronos_uint16_t GLhalfARB;
typedef khronos_int32_t GLfixed;


#line 4689 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
typedef khronos_intptr_t GLintptr;
#line 4691 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"


#line 4694 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
typedef khronos_intptr_t GLintptrARB;
#line 4696 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"


#line 4699 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
typedef khronos_ssize_t GLsizeiptr;
#line 4701 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"


#line 4704 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
typedef khronos_ssize_t GLsizeiptrARB;
#line 4706 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
typedef khronos_int64_t GLint64;
typedef khronos_int64_t GLint64EXT;
typedef khronos_uint64_t GLuint64;
typedef khronos_uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void (__stdcall *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (__stdcall *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (__stdcall *GLDEBUGPROCKHR)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (__stdcall *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;
typedef void (__stdcall *GLVULKANPROCNV)(void);



extern int GLAD_GL_VERSION_1_0;

extern int GLAD_GL_VERSION_1_1;

extern int GLAD_GL_VERSION_1_2;

extern int GLAD_GL_VERSION_1_3;

extern int GLAD_GL_VERSION_1_4;

extern int GLAD_GL_VERSION_1_5;

extern int GLAD_GL_VERSION_2_0;

extern int GLAD_GL_VERSION_2_1;

extern int GLAD_GL_VERSION_3_0;

extern int GLAD_GL_VERSION_3_1;

extern int GLAD_GL_VERSION_3_2;

extern int GLAD_GL_VERSION_3_3;

extern int GLAD_GL_3DFX_multisample;

extern int GLAD_GL_3DFX_tbuffer;

extern int GLAD_GL_3DFX_texture_compression_FXT1;

extern int GLAD_GL_AMD_blend_minmax_factor;

extern int GLAD_GL_AMD_conservative_depth;

extern int GLAD_GL_AMD_debug_output;

extern int GLAD_GL_AMD_depth_clamp_separate;

extern int GLAD_GL_AMD_draw_buffers_blend;

extern int GLAD_GL_AMD_framebuffer_multisample_advanced;

extern int GLAD_GL_AMD_framebuffer_sample_positions;

extern int GLAD_GL_AMD_gcn_shader;

extern int GLAD_GL_AMD_gpu_shader_half_float;

extern int GLAD_GL_AMD_gpu_shader_int16;

extern int GLAD_GL_AMD_gpu_shader_int64;

extern int GLAD_GL_AMD_interleaved_elements;

extern int GLAD_GL_AMD_multi_draw_indirect;

extern int GLAD_GL_AMD_name_gen_delete;

extern int GLAD_GL_AMD_occlusion_query_event;

extern int GLAD_GL_AMD_performance_monitor;

extern int GLAD_GL_AMD_pinned_memory;

extern int GLAD_GL_AMD_query_buffer_object;

extern int GLAD_GL_AMD_sample_positions;

extern int GLAD_GL_AMD_seamless_cubemap_per_texture;

extern int GLAD_GL_AMD_shader_atomic_counter_ops;

extern int GLAD_GL_AMD_shader_ballot;

extern int GLAD_GL_AMD_shader_explicit_vertex_parameter;

extern int GLAD_GL_AMD_shader_gpu_shader_half_float_fetch;

extern int GLAD_GL_AMD_shader_image_load_store_lod;

extern int GLAD_GL_AMD_shader_stencil_export;

extern int GLAD_GL_AMD_shader_trinary_minmax;

extern int GLAD_GL_AMD_sparse_texture;

extern int GLAD_GL_AMD_stencil_operation_extended;

extern int GLAD_GL_AMD_texture_gather_bias_lod;

extern int GLAD_GL_AMD_texture_texture4;

extern int GLAD_GL_AMD_transform_feedback3_lines_triangles;

extern int GLAD_GL_AMD_transform_feedback4;

extern int GLAD_GL_AMD_vertex_shader_layer;

extern int GLAD_GL_AMD_vertex_shader_tessellator;

extern int GLAD_GL_AMD_vertex_shader_viewport_index;

extern int GLAD_GL_APPLE_aux_depth_stencil;

extern int GLAD_GL_APPLE_client_storage;

extern int GLAD_GL_APPLE_element_array;

extern int GLAD_GL_APPLE_fence;

extern int GLAD_GL_APPLE_float_pixels;

extern int GLAD_GL_APPLE_flush_buffer_range;

extern int GLAD_GL_APPLE_object_purgeable;

extern int GLAD_GL_APPLE_rgb_422;

extern int GLAD_GL_APPLE_row_bytes;

extern int GLAD_GL_APPLE_specular_vector;

extern int GLAD_GL_APPLE_texture_range;

extern int GLAD_GL_APPLE_transform_hint;

extern int GLAD_GL_APPLE_vertex_array_object;

extern int GLAD_GL_APPLE_vertex_array_range;

extern int GLAD_GL_APPLE_vertex_program_evaluators;

extern int GLAD_GL_APPLE_ycbcr_422;

extern int GLAD_GL_ARB_ES2_compatibility;

extern int GLAD_GL_ARB_ES3_1_compatibility;

extern int GLAD_GL_ARB_ES3_2_compatibility;

extern int GLAD_GL_ARB_ES3_compatibility;

extern int GLAD_GL_ARB_arrays_of_arrays;

extern int GLAD_GL_ARB_base_instance;

extern int GLAD_GL_ARB_bindless_texture;

extern int GLAD_GL_ARB_blend_func_extended;

extern int GLAD_GL_ARB_buffer_storage;

extern int GLAD_GL_ARB_cl_event;

extern int GLAD_GL_ARB_clear_buffer_object;

extern int GLAD_GL_ARB_clear_texture;

extern int GLAD_GL_ARB_clip_control;

extern int GLAD_GL_ARB_color_buffer_float;

extern int GLAD_GL_ARB_compatibility;

extern int GLAD_GL_ARB_compressed_texture_pixel_storage;

extern int GLAD_GL_ARB_compute_shader;

extern int GLAD_GL_ARB_compute_variable_group_size;

extern int GLAD_GL_ARB_conditional_render_inverted;

extern int GLAD_GL_ARB_conservative_depth;

extern int GLAD_GL_ARB_copy_buffer;

extern int GLAD_GL_ARB_copy_image;

extern int GLAD_GL_ARB_cull_distance;

extern int GLAD_GL_ARB_debug_output;

extern int GLAD_GL_ARB_depth_buffer_float;

extern int GLAD_GL_ARB_depth_clamp;

extern int GLAD_GL_ARB_depth_texture;

extern int GLAD_GL_ARB_derivative_control;

extern int GLAD_GL_ARB_direct_state_access;

extern int GLAD_GL_ARB_draw_buffers;

extern int GLAD_GL_ARB_draw_buffers_blend;

extern int GLAD_GL_ARB_draw_elements_base_vertex;

extern int GLAD_GL_ARB_draw_indirect;

extern int GLAD_GL_ARB_draw_instanced;

extern int GLAD_GL_ARB_enhanced_layouts;

extern int GLAD_GL_ARB_explicit_attrib_location;

extern int GLAD_GL_ARB_explicit_uniform_location;

extern int GLAD_GL_ARB_fragment_coord_conventions;

extern int GLAD_GL_ARB_fragment_layer_viewport;

extern int GLAD_GL_ARB_fragment_program;

extern int GLAD_GL_ARB_fragment_program_shadow;

extern int GLAD_GL_ARB_fragment_shader;

extern int GLAD_GL_ARB_fragment_shader_interlock;

extern int GLAD_GL_ARB_framebuffer_no_attachments;

extern int GLAD_GL_ARB_framebuffer_object;

extern int GLAD_GL_ARB_framebuffer_sRGB;

extern int GLAD_GL_ARB_geometry_shader4;

extern int GLAD_GL_ARB_get_program_binary;

extern int GLAD_GL_ARB_get_texture_sub_image;

extern int GLAD_GL_ARB_gl_spirv;

extern int GLAD_GL_ARB_gpu_shader5;

extern int GLAD_GL_ARB_gpu_shader_fp64;

extern int GLAD_GL_ARB_gpu_shader_int64;

extern int GLAD_GL_ARB_half_float_pixel;

extern int GLAD_GL_ARB_half_float_vertex;

extern int GLAD_GL_ARB_imaging;

extern int GLAD_GL_ARB_indirect_parameters;

extern int GLAD_GL_ARB_instanced_arrays;

extern int GLAD_GL_ARB_internalformat_query;

extern int GLAD_GL_ARB_internalformat_query2;

extern int GLAD_GL_ARB_invalidate_subdata;

extern int GLAD_GL_ARB_map_buffer_alignment;

extern int GLAD_GL_ARB_map_buffer_range;

extern int GLAD_GL_ARB_matrix_palette;

extern int GLAD_GL_ARB_multi_bind;

extern int GLAD_GL_ARB_multi_draw_indirect;

extern int GLAD_GL_ARB_multisample;

extern int GLAD_GL_ARB_multitexture;

extern int GLAD_GL_ARB_occlusion_query;

extern int GLAD_GL_ARB_occlusion_query2;

extern int GLAD_GL_ARB_parallel_shader_compile;

extern int GLAD_GL_ARB_pipeline_statistics_query;

extern int GLAD_GL_ARB_pixel_buffer_object;

extern int GLAD_GL_ARB_point_parameters;

extern int GLAD_GL_ARB_point_sprite;

extern int GLAD_GL_ARB_polygon_offset_clamp;

extern int GLAD_GL_ARB_post_depth_coverage;

extern int GLAD_GL_ARB_program_interface_query;

extern int GLAD_GL_ARB_provoking_vertex;

extern int GLAD_GL_ARB_query_buffer_object;

extern int GLAD_GL_ARB_robust_buffer_access_behavior;

extern int GLAD_GL_ARB_robustness;

extern int GLAD_GL_ARB_robustness_isolation;

extern int GLAD_GL_ARB_sample_locations;

extern int GLAD_GL_ARB_sample_shading;

extern int GLAD_GL_ARB_sampler_objects;

extern int GLAD_GL_ARB_seamless_cube_map;

extern int GLAD_GL_ARB_seamless_cubemap_per_texture;

extern int GLAD_GL_ARB_separate_shader_objects;

extern int GLAD_GL_ARB_shader_atomic_counter_ops;

extern int GLAD_GL_ARB_shader_atomic_counters;

extern int GLAD_GL_ARB_shader_ballot;

extern int GLAD_GL_ARB_shader_bit_encoding;

extern int GLAD_GL_ARB_shader_clock;

extern int GLAD_GL_ARB_shader_draw_parameters;

extern int GLAD_GL_ARB_shader_group_vote;

extern int GLAD_GL_ARB_shader_image_load_store;

extern int GLAD_GL_ARB_shader_image_size;

extern int GLAD_GL_ARB_shader_objects;

extern int GLAD_GL_ARB_shader_precision;

extern int GLAD_GL_ARB_shader_stencil_export;

extern int GLAD_GL_ARB_shader_storage_buffer_object;

extern int GLAD_GL_ARB_shader_subroutine;

extern int GLAD_GL_ARB_shader_texture_image_samples;

extern int GLAD_GL_ARB_shader_texture_lod;

extern int GLAD_GL_ARB_shader_viewport_layer_array;

extern int GLAD_GL_ARB_shading_language_100;

extern int GLAD_GL_ARB_shading_language_420pack;

extern int GLAD_GL_ARB_shading_language_include;

extern int GLAD_GL_ARB_shading_language_packing;

extern int GLAD_GL_ARB_shadow;

extern int GLAD_GL_ARB_shadow_ambient;

extern int GLAD_GL_ARB_sparse_buffer;

extern int GLAD_GL_ARB_sparse_texture;

extern int GLAD_GL_ARB_sparse_texture2;

extern int GLAD_GL_ARB_sparse_texture_clamp;

extern int GLAD_GL_ARB_spirv_extensions;

extern int GLAD_GL_ARB_stencil_texturing;

extern int GLAD_GL_ARB_sync;

extern int GLAD_GL_ARB_tessellation_shader;

extern int GLAD_GL_ARB_texture_barrier;

extern int GLAD_GL_ARB_texture_border_clamp;

extern int GLAD_GL_ARB_texture_buffer_object;

extern int GLAD_GL_ARB_texture_buffer_object_rgb32;

extern int GLAD_GL_ARB_texture_buffer_range;

extern int GLAD_GL_ARB_texture_compression;

extern int GLAD_GL_ARB_texture_compression_bptc;

extern int GLAD_GL_ARB_texture_compression_rgtc;

extern int GLAD_GL_ARB_texture_cube_map;

extern int GLAD_GL_ARB_texture_cube_map_array;

extern int GLAD_GL_ARB_texture_env_add;

extern int GLAD_GL_ARB_texture_env_combine;

extern int GLAD_GL_ARB_texture_env_crossbar;

extern int GLAD_GL_ARB_texture_env_dot3;

extern int GLAD_GL_ARB_texture_filter_anisotropic;

extern int GLAD_GL_ARB_texture_filter_minmax;

extern int GLAD_GL_ARB_texture_float;

extern int GLAD_GL_ARB_texture_gather;

extern int GLAD_GL_ARB_texture_mirror_clamp_to_edge;

extern int GLAD_GL_ARB_texture_mirrored_repeat;

extern int GLAD_GL_ARB_texture_multisample;

extern int GLAD_GL_ARB_texture_non_power_of_two;

extern int GLAD_GL_ARB_texture_query_levels;

extern int GLAD_GL_ARB_texture_query_lod;

extern int GLAD_GL_ARB_texture_rectangle;

extern int GLAD_GL_ARB_texture_rg;

extern int GLAD_GL_ARB_texture_rgb10_a2ui;

extern int GLAD_GL_ARB_texture_stencil8;

extern int GLAD_GL_ARB_texture_storage;

extern int GLAD_GL_ARB_texture_storage_multisample;

extern int GLAD_GL_ARB_texture_swizzle;

extern int GLAD_GL_ARB_texture_view;

extern int GLAD_GL_ARB_timer_query;

extern int GLAD_GL_ARB_transform_feedback2;

extern int GLAD_GL_ARB_transform_feedback3;

extern int GLAD_GL_ARB_transform_feedback_instanced;

extern int GLAD_GL_ARB_transform_feedback_overflow_query;

extern int GLAD_GL_ARB_transpose_matrix;

extern int GLAD_GL_ARB_uniform_buffer_object;

extern int GLAD_GL_ARB_vertex_array_bgra;

extern int GLAD_GL_ARB_vertex_array_object;

extern int GLAD_GL_ARB_vertex_attrib_64bit;

extern int GLAD_GL_ARB_vertex_attrib_binding;

extern int GLAD_GL_ARB_vertex_blend;

extern int GLAD_GL_ARB_vertex_buffer_object;

extern int GLAD_GL_ARB_vertex_program;

extern int GLAD_GL_ARB_vertex_shader;

extern int GLAD_GL_ARB_vertex_type_10f_11f_11f_rev;

extern int GLAD_GL_ARB_vertex_type_2_10_10_10_rev;

extern int GLAD_GL_ARB_viewport_array;

extern int GLAD_GL_ARB_window_pos;

extern int GLAD_GL_ATI_draw_buffers;

extern int GLAD_GL_ATI_element_array;

extern int GLAD_GL_ATI_envmap_bumpmap;

extern int GLAD_GL_ATI_fragment_shader;

extern int GLAD_GL_ATI_map_object_buffer;

extern int GLAD_GL_ATI_meminfo;

extern int GLAD_GL_ATI_pixel_format_float;

extern int GLAD_GL_ATI_pn_triangles;

extern int GLAD_GL_ATI_separate_stencil;

extern int GLAD_GL_ATI_text_fragment_shader;

extern int GLAD_GL_ATI_texture_env_combine3;

extern int GLAD_GL_ATI_texture_float;

extern int GLAD_GL_ATI_texture_mirror_once;

extern int GLAD_GL_ATI_vertex_array_object;

extern int GLAD_GL_ATI_vertex_attrib_array_object;

extern int GLAD_GL_ATI_vertex_streams;

extern int GLAD_GL_EXT_422_pixels;

extern int GLAD_GL_EXT_EGL_image_storage;

extern int GLAD_GL_EXT_EGL_sync;

extern int GLAD_GL_EXT_abgr;

extern int GLAD_GL_EXT_bgra;

extern int GLAD_GL_EXT_bindable_uniform;

extern int GLAD_GL_EXT_blend_color;

extern int GLAD_GL_EXT_blend_equation_separate;

extern int GLAD_GL_EXT_blend_func_separate;

extern int GLAD_GL_EXT_blend_logic_op;

extern int GLAD_GL_EXT_blend_minmax;

extern int GLAD_GL_EXT_blend_subtract;

extern int GLAD_GL_EXT_clip_volume_hint;

extern int GLAD_GL_EXT_cmyka;

extern int GLAD_GL_EXT_color_subtable;

extern int GLAD_GL_EXT_compiled_vertex_array;

extern int GLAD_GL_EXT_convolution;

extern int GLAD_GL_EXT_coordinate_frame;

extern int GLAD_GL_EXT_copy_texture;

extern int GLAD_GL_EXT_cull_vertex;

extern int GLAD_GL_EXT_debug_label;

extern int GLAD_GL_EXT_debug_marker;

extern int GLAD_GL_EXT_depth_bounds_test;

extern int GLAD_GL_EXT_direct_state_access;

extern int GLAD_GL_EXT_draw_buffers2;

extern int GLAD_GL_EXT_draw_instanced;

extern int GLAD_GL_EXT_draw_range_elements;

extern int GLAD_GL_EXT_external_buffer;

extern int GLAD_GL_EXT_fog_coord;

extern int GLAD_GL_EXT_framebuffer_blit;

extern int GLAD_GL_EXT_framebuffer_blit_layers;

extern int GLAD_GL_EXT_framebuffer_multisample;

extern int GLAD_GL_EXT_framebuffer_multisample_blit_scaled;

extern int GLAD_GL_EXT_framebuffer_object;

extern int GLAD_GL_EXT_framebuffer_sRGB;

extern int GLAD_GL_EXT_geometry_shader4;

extern int GLAD_GL_EXT_gpu_program_parameters;

extern int GLAD_GL_EXT_gpu_shader4;

extern int GLAD_GL_EXT_histogram;

extern int GLAD_GL_EXT_index_array_formats;

extern int GLAD_GL_EXT_index_func;

extern int GLAD_GL_EXT_index_material;

extern int GLAD_GL_EXT_index_texture;

extern int GLAD_GL_EXT_light_texture;

extern int GLAD_GL_EXT_memory_object;

extern int GLAD_GL_EXT_memory_object_fd;

extern int GLAD_GL_EXT_memory_object_win32;

extern int GLAD_GL_EXT_misc_attribute;

extern int GLAD_GL_EXT_multi_draw_arrays;

extern int GLAD_GL_EXT_multisample;

extern int GLAD_GL_EXT_multiview_tessellation_geometry_shader;

extern int GLAD_GL_EXT_multiview_texture_multisample;

extern int GLAD_GL_EXT_multiview_timer_query;

extern int GLAD_GL_EXT_packed_depth_stencil;

extern int GLAD_GL_EXT_packed_float;

extern int GLAD_GL_EXT_packed_pixels;

extern int GLAD_GL_EXT_paletted_texture;

extern int GLAD_GL_EXT_pixel_buffer_object;

extern int GLAD_GL_EXT_pixel_transform;

extern int GLAD_GL_EXT_pixel_transform_color_table;

extern int GLAD_GL_EXT_point_parameters;

extern int GLAD_GL_EXT_polygon_offset;

extern int GLAD_GL_EXT_polygon_offset_clamp;

extern int GLAD_GL_EXT_post_depth_coverage;

extern int GLAD_GL_EXT_provoking_vertex;

extern int GLAD_GL_EXT_raster_multisample;

extern int GLAD_GL_EXT_rescale_normal;

extern int GLAD_GL_EXT_secondary_color;

extern int GLAD_GL_EXT_semaphore;

extern int GLAD_GL_EXT_semaphore_fd;

extern int GLAD_GL_EXT_semaphore_win32;

extern int GLAD_GL_EXT_separate_shader_objects;

extern int GLAD_GL_EXT_separate_specular_color;

extern int GLAD_GL_EXT_shader_framebuffer_fetch;

extern int GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent;

extern int GLAD_GL_EXT_shader_image_load_formatted;

extern int GLAD_GL_EXT_shader_image_load_store;

extern int GLAD_GL_EXT_shader_integer_mix;

extern int GLAD_GL_EXT_shader_samples_identical;

extern int GLAD_GL_EXT_shadow_funcs;

extern int GLAD_GL_EXT_shared_texture_palette;

extern int GLAD_GL_EXT_sparse_texture2;

extern int GLAD_GL_EXT_stencil_clear_tag;

extern int GLAD_GL_EXT_stencil_two_side;

extern int GLAD_GL_EXT_stencil_wrap;

extern int GLAD_GL_EXT_subtexture;

extern int GLAD_GL_EXT_texture;

extern int GLAD_GL_EXT_texture3D;

extern int GLAD_GL_EXT_texture_array;

extern int GLAD_GL_EXT_texture_buffer_object;

extern int GLAD_GL_EXT_texture_compression_latc;

extern int GLAD_GL_EXT_texture_compression_rgtc;

extern int GLAD_GL_EXT_texture_compression_s3tc;

extern int GLAD_GL_EXT_texture_cube_map;

extern int GLAD_GL_EXT_texture_env_add;

extern int GLAD_GL_EXT_texture_env_combine;

extern int GLAD_GL_EXT_texture_env_dot3;

extern int GLAD_GL_EXT_texture_filter_anisotropic;

extern int GLAD_GL_EXT_texture_filter_minmax;

extern int GLAD_GL_EXT_texture_integer;

extern int GLAD_GL_EXT_texture_lod_bias;

extern int GLAD_GL_EXT_texture_mirror_clamp;

extern int GLAD_GL_EXT_texture_object;

extern int GLAD_GL_EXT_texture_perturb_normal;

extern int GLAD_GL_EXT_texture_sRGB;

extern int GLAD_GL_EXT_texture_sRGB_R8;

extern int GLAD_GL_EXT_texture_sRGB_RG8;

extern int GLAD_GL_EXT_texture_sRGB_decode;

extern int GLAD_GL_EXT_texture_shadow_lod;

extern int GLAD_GL_EXT_texture_shared_exponent;

extern int GLAD_GL_EXT_texture_snorm;

extern int GLAD_GL_EXT_texture_storage;

extern int GLAD_GL_EXT_texture_swizzle;

extern int GLAD_GL_EXT_timer_query;

extern int GLAD_GL_EXT_transform_feedback;

extern int GLAD_GL_EXT_vertex_array;

extern int GLAD_GL_EXT_vertex_array_bgra;

extern int GLAD_GL_EXT_vertex_attrib_64bit;

extern int GLAD_GL_EXT_vertex_shader;

extern int GLAD_GL_EXT_vertex_weighting;

extern int GLAD_GL_EXT_win32_keyed_mutex;

extern int GLAD_GL_EXT_window_rectangles;

extern int GLAD_GL_EXT_x11_sync_object;

extern int GLAD_GL_GREMEDY_frame_terminator;

extern int GLAD_GL_GREMEDY_string_marker;

extern int GLAD_GL_HP_convolution_border_modes;

extern int GLAD_GL_HP_image_transform;

extern int GLAD_GL_HP_occlusion_test;

extern int GLAD_GL_HP_texture_lighting;

extern int GLAD_GL_IBM_cull_vertex;

extern int GLAD_GL_IBM_multimode_draw_arrays;

extern int GLAD_GL_IBM_rasterpos_clip;

extern int GLAD_GL_IBM_static_data;

extern int GLAD_GL_IBM_texture_mirrored_repeat;

extern int GLAD_GL_IBM_vertex_array_lists;

extern int GLAD_GL_INGR_blend_func_separate;

extern int GLAD_GL_INGR_color_clamp;

extern int GLAD_GL_INGR_interlace_read;

extern int GLAD_GL_INTEL_blackhole_render;

extern int GLAD_GL_INTEL_conservative_rasterization;

extern int GLAD_GL_INTEL_fragment_shader_ordering;

extern int GLAD_GL_INTEL_framebuffer_CMAA;

extern int GLAD_GL_INTEL_map_texture;

extern int GLAD_GL_INTEL_parallel_arrays;

extern int GLAD_GL_INTEL_performance_query;

extern int GLAD_GL_KHR_blend_equation_advanced;

extern int GLAD_GL_KHR_blend_equation_advanced_coherent;

extern int GLAD_GL_KHR_context_flush_control;

extern int GLAD_GL_KHR_debug;

extern int GLAD_GL_KHR_no_error;

extern int GLAD_GL_KHR_parallel_shader_compile;

extern int GLAD_GL_KHR_robust_buffer_access_behavior;

extern int GLAD_GL_KHR_robustness;

extern int GLAD_GL_KHR_shader_subgroup;

extern int GLAD_GL_KHR_texture_compression_astc_hdr;

extern int GLAD_GL_KHR_texture_compression_astc_ldr;

extern int GLAD_GL_KHR_texture_compression_astc_sliced_3d;

extern int GLAD_GL_MESAX_texture_stack;

extern int GLAD_GL_MESA_framebuffer_flip_x;

extern int GLAD_GL_MESA_framebuffer_flip_y;

extern int GLAD_GL_MESA_framebuffer_swap_xy;

extern int GLAD_GL_MESA_pack_invert;

extern int GLAD_GL_MESA_program_binary_formats;

extern int GLAD_GL_MESA_resize_buffers;

extern int GLAD_GL_MESA_shader_integer_functions;

extern int GLAD_GL_MESA_texture_const_bandwidth;

extern int GLAD_GL_MESA_tile_raster_order;

extern int GLAD_GL_MESA_window_pos;

extern int GLAD_GL_MESA_ycbcr_texture;

extern int GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers;

extern int GLAD_GL_NVX_conditional_render;

extern int GLAD_GL_NVX_gpu_memory_info;

extern int GLAD_GL_NVX_gpu_multicast2;

extern int GLAD_GL_NVX_linked_gpu_multicast;

extern int GLAD_GL_NVX_progress_fence;

extern int GLAD_GL_NV_alpha_to_coverage_dither_control;

extern int GLAD_GL_NV_bindless_multi_draw_indirect;

extern int GLAD_GL_NV_bindless_multi_draw_indirect_count;

extern int GLAD_GL_NV_bindless_texture;

extern int GLAD_GL_NV_blend_equation_advanced;

extern int GLAD_GL_NV_blend_equation_advanced_coherent;

extern int GLAD_GL_NV_blend_minmax_factor;

extern int GLAD_GL_NV_blend_square;

extern int GLAD_GL_NV_clip_space_w_scaling;

extern int GLAD_GL_NV_command_list;

extern int GLAD_GL_NV_compute_program5;

extern int GLAD_GL_NV_compute_shader_derivatives;

extern int GLAD_GL_NV_conditional_render;

extern int GLAD_GL_NV_conservative_raster;

extern int GLAD_GL_NV_conservative_raster_dilate;

extern int GLAD_GL_NV_conservative_raster_pre_snap;

extern int GLAD_GL_NV_conservative_raster_pre_snap_triangles;

extern int GLAD_GL_NV_conservative_raster_underestimation;

extern int GLAD_GL_NV_copy_depth_to_color;

extern int GLAD_GL_NV_copy_image;

extern int GLAD_GL_NV_deep_texture3D;

extern int GLAD_GL_NV_depth_buffer_float;

extern int GLAD_GL_NV_depth_clamp;

extern int GLAD_GL_NV_draw_texture;

extern int GLAD_GL_NV_draw_vulkan_image;

extern int GLAD_GL_NV_evaluators;

extern int GLAD_GL_NV_explicit_multisample;

extern int GLAD_GL_NV_fence;

extern int GLAD_GL_NV_fill_rectangle;

extern int GLAD_GL_NV_float_buffer;

extern int GLAD_GL_NV_fog_distance;

extern int GLAD_GL_NV_fragment_coverage_to_color;

extern int GLAD_GL_NV_fragment_program;

extern int GLAD_GL_NV_fragment_program2;

extern int GLAD_GL_NV_fragment_program4;

extern int GLAD_GL_NV_fragment_program_option;

extern int GLAD_GL_NV_fragment_shader_barycentric;

extern int GLAD_GL_NV_fragment_shader_interlock;

extern int GLAD_GL_NV_framebuffer_mixed_samples;

extern int GLAD_GL_NV_framebuffer_multisample_coverage;

extern int GLAD_GL_NV_geometry_program4;

extern int GLAD_GL_NV_geometry_shader4;

extern int GLAD_GL_NV_geometry_shader_passthrough;

extern int GLAD_GL_NV_gpu_multicast;

extern int GLAD_GL_NV_gpu_program4;

extern int GLAD_GL_NV_gpu_program5;

extern int GLAD_GL_NV_gpu_program5_mem_extended;

extern int GLAD_GL_NV_gpu_shader5;

extern int GLAD_GL_NV_half_float;

extern int GLAD_GL_NV_internalformat_sample_query;

extern int GLAD_GL_NV_light_max_exponent;

extern int GLAD_GL_NV_memory_attachment;

extern int GLAD_GL_NV_memory_object_sparse;

extern int GLAD_GL_NV_mesh_shader;

extern int GLAD_GL_NV_multisample_coverage;

extern int GLAD_GL_NV_multisample_filter_hint;

extern int GLAD_GL_NV_occlusion_query;

extern int GLAD_GL_NV_packed_depth_stencil;

extern int GLAD_GL_NV_parameter_buffer_object;

extern int GLAD_GL_NV_parameter_buffer_object2;

extern int GLAD_GL_NV_path_rendering;

extern int GLAD_GL_NV_path_rendering_shared_edge;

extern int GLAD_GL_NV_pixel_data_range;

extern int GLAD_GL_NV_point_sprite;

extern int GLAD_GL_NV_present_video;

extern int GLAD_GL_NV_primitive_restart;

extern int GLAD_GL_NV_primitive_shading_rate;

extern int GLAD_GL_NV_query_resource;

extern int GLAD_GL_NV_query_resource_tag;

extern int GLAD_GL_NV_register_combiners;

extern int GLAD_GL_NV_register_combiners2;

extern int GLAD_GL_NV_representative_fragment_test;

extern int GLAD_GL_NV_robustness_video_memory_purge;

extern int GLAD_GL_NV_sample_locations;

extern int GLAD_GL_NV_sample_mask_override_coverage;

extern int GLAD_GL_NV_scissor_exclusive;

extern int GLAD_GL_NV_shader_atomic_counters;

extern int GLAD_GL_NV_shader_atomic_float;

extern int GLAD_GL_NV_shader_atomic_float64;

extern int GLAD_GL_NV_shader_atomic_fp16_vector;

extern int GLAD_GL_NV_shader_atomic_int64;

extern int GLAD_GL_NV_shader_buffer_load;

extern int GLAD_GL_NV_shader_buffer_store;

extern int GLAD_GL_NV_shader_storage_buffer_object;

extern int GLAD_GL_NV_shader_subgroup_partitioned;

extern int GLAD_GL_NV_shader_texture_footprint;

extern int GLAD_GL_NV_shader_thread_group;

extern int GLAD_GL_NV_shader_thread_shuffle;

extern int GLAD_GL_NV_shading_rate_image;

extern int GLAD_GL_NV_stereo_view_rendering;

extern int GLAD_GL_NV_tessellation_program5;

extern int GLAD_GL_NV_texgen_emboss;

extern int GLAD_GL_NV_texgen_reflection;

extern int GLAD_GL_NV_texture_barrier;

extern int GLAD_GL_NV_texture_compression_vtc;

extern int GLAD_GL_NV_texture_env_combine4;

extern int GLAD_GL_NV_texture_expand_normal;

extern int GLAD_GL_NV_texture_multisample;

extern int GLAD_GL_NV_texture_rectangle;

extern int GLAD_GL_NV_texture_rectangle_compressed;

extern int GLAD_GL_NV_texture_shader;

extern int GLAD_GL_NV_texture_shader2;

extern int GLAD_GL_NV_texture_shader3;

extern int GLAD_GL_NV_timeline_semaphore;

extern int GLAD_GL_NV_transform_feedback;

extern int GLAD_GL_NV_transform_feedback2;

extern int GLAD_GL_NV_uniform_buffer_std430_layout;

extern int GLAD_GL_NV_uniform_buffer_unified_memory;

extern int GLAD_GL_NV_vdpau_interop;

extern int GLAD_GL_NV_vdpau_interop2;

extern int GLAD_GL_NV_vertex_array_range;

extern int GLAD_GL_NV_vertex_array_range2;

extern int GLAD_GL_NV_vertex_attrib_integer_64bit;

extern int GLAD_GL_NV_vertex_buffer_unified_memory;

extern int GLAD_GL_NV_vertex_program;

extern int GLAD_GL_NV_vertex_program1_1;

extern int GLAD_GL_NV_vertex_program2;

extern int GLAD_GL_NV_vertex_program2_option;

extern int GLAD_GL_NV_vertex_program3;

extern int GLAD_GL_NV_vertex_program4;

extern int GLAD_GL_NV_video_capture;

extern int GLAD_GL_NV_viewport_array2;

extern int GLAD_GL_NV_viewport_swizzle;

extern int GLAD_GL_OES_byte_coordinates;

extern int GLAD_GL_OES_compressed_paletted_texture;

extern int GLAD_GL_OES_fixed_point;

extern int GLAD_GL_OES_query_matrix;

extern int GLAD_GL_OES_read_format;

extern int GLAD_GL_OES_single_precision;

extern int GLAD_GL_OML_interlace;

extern int GLAD_GL_OML_resample;

extern int GLAD_GL_OML_subsample;

extern int GLAD_GL_OVR_multiview;

extern int GLAD_GL_OVR_multiview2;

extern int GLAD_GL_PGI_misc_hints;

extern int GLAD_GL_PGI_vertex_hints;

extern int GLAD_GL_REND_screen_coordinates;

extern int GLAD_GL_S3_s3tc;

extern int GLAD_GL_SGIS_detail_texture;

extern int GLAD_GL_SGIS_fog_function;

extern int GLAD_GL_SGIS_generate_mipmap;

extern int GLAD_GL_SGIS_multisample;

extern int GLAD_GL_SGIS_pixel_texture;

extern int GLAD_GL_SGIS_point_line_texgen;

extern int GLAD_GL_SGIS_point_parameters;

extern int GLAD_GL_SGIS_sharpen_texture;

extern int GLAD_GL_SGIS_texture4D;

extern int GLAD_GL_SGIS_texture_border_clamp;

extern int GLAD_GL_SGIS_texture_color_mask;

extern int GLAD_GL_SGIS_texture_edge_clamp;

extern int GLAD_GL_SGIS_texture_filter4;

extern int GLAD_GL_SGIS_texture_lod;

extern int GLAD_GL_SGIS_texture_select;

extern int GLAD_GL_SGIX_async;

extern int GLAD_GL_SGIX_async_histogram;

extern int GLAD_GL_SGIX_async_pixel;

extern int GLAD_GL_SGIX_blend_alpha_minmax;

extern int GLAD_GL_SGIX_calligraphic_fragment;

extern int GLAD_GL_SGIX_clipmap;

extern int GLAD_GL_SGIX_convolution_accuracy;

extern int GLAD_GL_SGIX_depth_pass_instrument;

extern int GLAD_GL_SGIX_depth_texture;

extern int GLAD_GL_SGIX_flush_raster;

extern int GLAD_GL_SGIX_fog_offset;

extern int GLAD_GL_SGIX_fragment_lighting;

extern int GLAD_GL_SGIX_framezoom;

extern int GLAD_GL_SGIX_igloo_interface;

extern int GLAD_GL_SGIX_instruments;

extern int GLAD_GL_SGIX_interlace;

extern int GLAD_GL_SGIX_ir_instrument1;

extern int GLAD_GL_SGIX_list_priority;

extern int GLAD_GL_SGIX_pixel_texture;

extern int GLAD_GL_SGIX_pixel_tiles;

extern int GLAD_GL_SGIX_polynomial_ffd;

extern int GLAD_GL_SGIX_reference_plane;

extern int GLAD_GL_SGIX_resample;

extern int GLAD_GL_SGIX_scalebias_hint;

extern int GLAD_GL_SGIX_shadow;

extern int GLAD_GL_SGIX_shadow_ambient;

extern int GLAD_GL_SGIX_sprite;

extern int GLAD_GL_SGIX_subsample;

extern int GLAD_GL_SGIX_tag_sample_buffer;

extern int GLAD_GL_SGIX_texture_add_env;

extern int GLAD_GL_SGIX_texture_coordinate_clamp;

extern int GLAD_GL_SGIX_texture_lod_bias;

extern int GLAD_GL_SGIX_texture_multi_buffer;

extern int GLAD_GL_SGIX_texture_scale_bias;

extern int GLAD_GL_SGIX_vertex_preclip;

extern int GLAD_GL_SGIX_ycrcb;

extern int GLAD_GL_SGIX_ycrcb_subsample;

extern int GLAD_GL_SGIX_ycrcba;

extern int GLAD_GL_SGI_color_matrix;

extern int GLAD_GL_SGI_color_table;

extern int GLAD_GL_SGI_texture_color_table;

extern int GLAD_GL_SUNX_constant_data;

extern int GLAD_GL_SUN_convolution_border_modes;

extern int GLAD_GL_SUN_global_alpha;

extern int GLAD_GL_SUN_mesh_array;

extern int GLAD_GL_SUN_slice_accum;

extern int GLAD_GL_SUN_triangle_list;

extern int GLAD_GL_SUN_vertex;

extern int GLAD_GL_WIN_phong_shading;

extern int GLAD_GL_WIN_specular_fog;


typedef void (__stdcall *PFNGLACCUMXOESPROC)(GLenum op, GLfixed value);
typedef GLboolean (__stdcall *PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key, GLuint timeout);
typedef void (__stdcall *PFNGLACTIVEPROGRAMEXTPROC)(GLuint program);
typedef void (__stdcall *PFNGLACTIVESHADERPROGRAMPROC)(GLuint pipeline, GLuint program);
typedef void (__stdcall *PFNGLACTIVESTENCILFACEEXTPROC)(GLenum face);
typedef void (__stdcall *PFNGLACTIVETEXTUREPROC)(GLenum texture);
typedef void (__stdcall *PFNGLACTIVETEXTUREARBPROC)(GLenum texture);
typedef void (__stdcall *PFNGLACTIVEVARYINGNVPROC)(GLuint program, const GLchar * name);
typedef void (__stdcall *PFNGLALPHAFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall *PFNGLALPHAFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall *PFNGLALPHAFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall *PFNGLALPHAFUNCXOESPROC)(GLenum func, GLfixed ref);
typedef void (__stdcall *PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC)(GLenum mode);
typedef void (__stdcall *PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC)(void);
typedef void (__stdcall *PFNGLAPPLYTEXTUREEXTPROC)(GLenum mode);
typedef GLboolean (__stdcall *PFNGLAREPROGRAMSRESIDENTNVPROC)(GLsizei n, const GLuint * programs, GLboolean * residences);
typedef GLboolean (__stdcall *PFNGLARETEXTURESRESIDENTEXTPROC)(GLsizei n, const GLuint * textures, GLboolean * residences);
typedef void (__stdcall *PFNGLARRAYELEMENTEXTPROC)(GLint i);
typedef void (__stdcall *PFNGLARRAYOBJECTATIPROC)(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef GLuint (__stdcall *PFNGLASYNCCOPYBUFFERSUBDATANVXPROC)(GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray);
typedef GLuint (__stdcall *PFNGLASYNCCOPYIMAGESUBDATANVXPROC)(GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray);
typedef void (__stdcall *PFNGLASYNCMARKERSGIXPROC)(GLuint marker);
typedef void (__stdcall *PFNGLATTACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB obj);
typedef void (__stdcall *PFNGLATTACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (__stdcall *PFNGLBEGINCONDITIONALRENDERPROC)(GLuint id, GLenum mode);
typedef void (__stdcall *PFNGLBEGINCONDITIONALRENDERNVPROC)(GLuint id, GLenum mode);
typedef void (__stdcall *PFNGLBEGINCONDITIONALRENDERNVXPROC)(GLuint id);
typedef void (__stdcall *PFNGLBEGINFRAGMENTSHADERATIPROC)(void);
typedef void (__stdcall *PFNGLBEGINOCCLUSIONQUERYNVPROC)(GLuint id);
typedef void (__stdcall *PFNGLBEGINPERFMONITORAMDPROC)(GLuint monitor);
typedef void (__stdcall *PFNGLBEGINPERFQUERYINTELPROC)(GLuint queryHandle);
typedef void (__stdcall *PFNGLBEGINQUERYPROC)(GLenum target, GLuint id);
typedef void (__stdcall *PFNGLBEGINQUERYARBPROC)(GLenum target, GLuint id);
typedef void (__stdcall *PFNGLBEGINQUERYINDEXEDPROC)(GLenum target, GLuint index, GLuint id);
typedef void (__stdcall *PFNGLBEGINTRANSFORMFEEDBACKPROC)(GLenum primitiveMode);
typedef void (__stdcall *PFNGLBEGINTRANSFORMFEEDBACKEXTPROC)(GLenum primitiveMode);
typedef void (__stdcall *PFNGLBEGINTRANSFORMFEEDBACKNVPROC)(GLenum primitiveMode);
typedef void (__stdcall *PFNGLBEGINVERTEXSHADEREXTPROC)(void);
typedef void (__stdcall *PFNGLBEGINVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
typedef void (__stdcall *PFNGLBINDATTRIBLOCATIONPROC)(GLuint program, GLuint index, const GLchar * name);
typedef void (__stdcall *PFNGLBINDATTRIBLOCATIONARBPROC)(GLhandleARB programObj, GLuint index, const GLcharARB * name);
typedef void (__stdcall *PFNGLBINDBUFFERPROC)(GLenum target, GLuint buffer);
typedef void (__stdcall *PFNGLBINDBUFFERARBPROC)(GLenum target, GLuint buffer);
typedef void (__stdcall *PFNGLBINDBUFFERBASEPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall *PFNGLBINDBUFFERBASEEXTPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall *PFNGLBINDBUFFERBASENVPROC)(GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall *PFNGLBINDBUFFEROFFSETEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall *PFNGLBINDBUFFEROFFSETNVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall *PFNGLBINDBUFFERRANGEPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLBINDBUFFERRANGEEXTPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLBINDBUFFERRANGENVPROC)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLBINDBUFFERSBASEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers);
typedef void (__stdcall *PFNGLBINDBUFFERSRANGEPROC)(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes);
typedef void (__stdcall *PFNGLBINDFRAGDATALOCATIONPROC)(GLuint program, GLuint color, const GLchar * name);
typedef void (__stdcall *PFNGLBINDFRAGDATALOCATIONEXTPROC)(GLuint program, GLuint color, const GLchar * name);
typedef void (__stdcall *PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef void (__stdcall *PFNGLBINDFRAGMENTSHADERATIPROC)(GLuint id);
typedef void (__stdcall *PFNGLBINDFRAMEBUFFERPROC)(GLenum target, GLuint framebuffer);
typedef void (__stdcall *PFNGLBINDFRAMEBUFFEREXTPROC)(GLenum target, GLuint framebuffer);
typedef void (__stdcall *PFNGLBINDIMAGETEXTUREPROC)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (__stdcall *PFNGLBINDIMAGETEXTUREEXTPROC)(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void (__stdcall *PFNGLBINDIMAGETEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef GLuint (__stdcall *PFNGLBINDLIGHTPARAMETEREXTPROC)(GLenum light, GLenum value);
typedef GLuint (__stdcall *PFNGLBINDMATERIALPARAMETEREXTPROC)(GLenum face, GLenum value);
typedef void (__stdcall *PFNGLBINDMULTITEXTUREEXTPROC)(GLenum texunit, GLenum target, GLuint texture);
typedef GLuint (__stdcall *PFNGLBINDPARAMETEREXTPROC)(GLenum value);
typedef void (__stdcall *PFNGLBINDPROGRAMARBPROC)(GLenum target, GLuint program);
typedef void (__stdcall *PFNGLBINDPROGRAMNVPROC)(GLenum target, GLuint id);
typedef void (__stdcall *PFNGLBINDPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (__stdcall *PFNGLBINDRENDERBUFFERPROC)(GLenum target, GLuint renderbuffer);
typedef void (__stdcall *PFNGLBINDRENDERBUFFEREXTPROC)(GLenum target, GLuint renderbuffer);
typedef void (__stdcall *PFNGLBINDSAMPLERPROC)(GLuint unit, GLuint sampler);
typedef void (__stdcall *PFNGLBINDSAMPLERSPROC)(GLuint first, GLsizei count, const GLuint * samplers);
typedef void (__stdcall *PFNGLBINDSHADINGRATEIMAGENVPROC)(GLuint texture);
typedef GLuint (__stdcall *PFNGLBINDTEXGENPARAMETEREXTPROC)(GLenum unit, GLenum coord, GLenum value);
typedef void (__stdcall *PFNGLBINDTEXTUREPROC)(GLenum target, GLuint texture);
typedef void (__stdcall *PFNGLBINDTEXTUREEXTPROC)(GLenum target, GLuint texture);
typedef void (__stdcall *PFNGLBINDTEXTUREUNITPROC)(GLuint unit, GLuint texture);
typedef GLuint (__stdcall *PFNGLBINDTEXTUREUNITPARAMETEREXTPROC)(GLenum unit, GLenum value);
typedef void (__stdcall *PFNGLBINDTEXTURESPROC)(GLuint first, GLsizei count, const GLuint * textures);
typedef void (__stdcall *PFNGLBINDTRANSFORMFEEDBACKPROC)(GLenum target, GLuint id);
typedef void (__stdcall *PFNGLBINDTRANSFORMFEEDBACKNVPROC)(GLenum target, GLuint id);
typedef void (__stdcall *PFNGLBINDVERTEXARRAYPROC)(GLuint array);
typedef void (__stdcall *PFNGLBINDVERTEXARRAYAPPLEPROC)(GLuint array);
typedef void (__stdcall *PFNGLBINDVERTEXBUFFERPROC)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall *PFNGLBINDVERTEXBUFFERSPROC)(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (__stdcall *PFNGLBINDVERTEXSHADEREXTPROC)(GLuint id);
typedef void (__stdcall *PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void (__stdcall *PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC)(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void (__stdcall *PFNGLBINORMAL3BEXTPROC)(GLbyte bx, GLbyte by, GLbyte bz);
typedef void (__stdcall *PFNGLBINORMAL3BVEXTPROC)(const GLbyte * v);
typedef void (__stdcall *PFNGLBINORMAL3DEXTPROC)(GLdouble bx, GLdouble by, GLdouble bz);
typedef void (__stdcall *PFNGLBINORMAL3DVEXTPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLBINORMAL3FEXTPROC)(GLfloat bx, GLfloat by, GLfloat bz);
typedef void (__stdcall *PFNGLBINORMAL3FVEXTPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLBINORMAL3IEXTPROC)(GLint bx, GLint by, GLint bz);
typedef void (__stdcall *PFNGLBINORMAL3IVEXTPROC)(const GLint * v);
typedef void (__stdcall *PFNGLBINORMAL3SEXTPROC)(GLshort bx, GLshort by, GLshort bz);
typedef void (__stdcall *PFNGLBINORMAL3SVEXTPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLBINORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLBITMAPXOESPROC)(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte * bitmap);
typedef void (__stdcall *PFNGLBLENDBARRIERKHRPROC)(void);
typedef void (__stdcall *PFNGLBLENDBARRIERNVPROC)(void);
typedef void (__stdcall *PFNGLBLENDCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (__stdcall *PFNGLBLENDCOLOREXTPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (__stdcall *PFNGLBLENDCOLORXOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall *PFNGLBLENDEQUATIONPROC)(GLenum mode);
typedef void (__stdcall *PFNGLBLENDEQUATIONEXTPROC)(GLenum mode);
typedef void (__stdcall *PFNGLBLENDEQUATIONINDEXEDAMDPROC)(GLuint buf, GLenum mode);
typedef void (__stdcall *PFNGLBLENDEQUATIONSEPARATEPROC)(GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall *PFNGLBLENDEQUATIONSEPARATEEXTPROC)(GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall *PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall *PFNGLBLENDEQUATIONSEPARATEIARBPROC)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall *PFNGLBLENDEQUATIONIARBPROC)(GLuint buf, GLenum mode);
typedef void (__stdcall *PFNGLBLENDFUNCPROC)(GLenum sfactor, GLenum dfactor);
typedef void (__stdcall *PFNGLBLENDFUNCINDEXEDAMDPROC)(GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall *PFNGLBLENDFUNCSEPARATEPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (__stdcall *PFNGLBLENDFUNCSEPARATEEXTPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (__stdcall *PFNGLBLENDFUNCSEPARATEINGRPROC)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (__stdcall *PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall *PFNGLBLENDFUNCSEPARATEIARBPROC)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall *PFNGLBLENDFUNCIARBPROC)(GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall *PFNGLBLENDPARAMETERINVPROC)(GLenum pname, GLint value);
typedef void (__stdcall *PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (__stdcall *PFNGLBLITFRAMEBUFFEREXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (__stdcall *PFNGLBLITFRAMEBUFFERLAYEREXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint srcLayer, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLint dstLayer, GLbitfield mask, GLenum filter);
typedef void (__stdcall *PFNGLBLITFRAMEBUFFERLAYERSEXTPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (__stdcall *PFNGLBLITNAMEDFRAMEBUFFERPROC)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (__stdcall *PFNGLBUFFERADDRESSRANGENVPROC)(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void (__stdcall *PFNGLBUFFERATTACHMEMORYNVPROC)(GLenum target, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLBUFFERDATAPROC)(GLenum target, GLsizeiptr size, const void * data, GLenum usage);
typedef void (__stdcall *PFNGLBUFFERDATAARBPROC)(GLenum target, GLsizeiptrARB size, const void * data, GLenum usage);
typedef void (__stdcall *PFNGLBUFFERPAGECOMMITMENTARBPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
typedef void (__stdcall *PFNGLBUFFERPAGECOMMITMENTMEMNVPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
typedef void (__stdcall *PFNGLBUFFERPARAMETERIAPPLEPROC)(GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLBUFFERSTORAGEPROC)(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (__stdcall *PFNGLBUFFERSTORAGEEXTERNALEXTPROC)(GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void (__stdcall *PFNGLBUFFERSTORAGEMEMEXTPROC)(GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (__stdcall *PFNGLBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void * data);
typedef void (__stdcall *PFNGLCALLCOMMANDLISTNVPROC)(GLuint list);
typedef GLenum (__stdcall *PFNGLCHECKFRAMEBUFFERSTATUSPROC)(GLenum target);
typedef GLenum (__stdcall *PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)(GLenum target);
typedef GLenum (__stdcall *PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)(GLuint framebuffer, GLenum target);
typedef GLenum (__stdcall *PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC)(GLuint framebuffer, GLenum target);
typedef void (__stdcall *PFNGLCLAMPCOLORPROC)(GLenum target, GLenum clamp);
typedef void (__stdcall *PFNGLCLAMPCOLORARBPROC)(GLenum target, GLenum clamp);
typedef void (__stdcall *PFNGLCLEARPROC)(GLbitfield mask);
typedef void (__stdcall *PFNGLCLEARACCUMXOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall *PFNGLCLEARBUFFERDATAPROC)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLEARBUFFERSUBDATAPROC)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLEARBUFFERFIPROC)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (__stdcall *PFNGLCLEARBUFFERFVPROC)(GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (__stdcall *PFNGLCLEARBUFFERIVPROC)(GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (__stdcall *PFNGLCLEARBUFFERUIVPROC)(GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (__stdcall *PFNGLCLEARCOLORPROC)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (__stdcall *PFNGLCLEARCOLORIIEXTPROC)(GLint red, GLint green, GLint blue, GLint alpha);
typedef void (__stdcall *PFNGLCLEARCOLORIUIEXTPROC)(GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void (__stdcall *PFNGLCLEARCOLORXOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall *PFNGLCLEARDEPTHPROC)(GLdouble depth);
typedef void (__stdcall *PFNGLCLEARDEPTHDNVPROC)(GLdouble depth);
typedef void (__stdcall *PFNGLCLEARDEPTHFPROC)(GLfloat d);
typedef void (__stdcall *PFNGLCLEARDEPTHFOESPROC)(GLclampf depth);
typedef void (__stdcall *PFNGLCLEARDEPTHXOESPROC)(GLfixed depth);
typedef void (__stdcall *PFNGLCLEARNAMEDBUFFERDATAPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLEARNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLEARNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (__stdcall *PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value);
typedef void (__stdcall *PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value);
typedef void (__stdcall *PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value);
typedef void (__stdcall *PFNGLCLEARSTENCILPROC)(GLint s);
typedef void (__stdcall *PFNGLCLEARTEXIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLEARTEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCLIENTACTIVETEXTUREARBPROC)(GLenum texture);
typedef void (__stdcall *PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC)(GLenum stream);
typedef void (__stdcall *PFNGLCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
typedef void (__stdcall *PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC)(GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);
typedef GLenum (__stdcall *PFNGLCLIENTWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (__stdcall *PFNGLCLIPCONTROLPROC)(GLenum origin, GLenum depth);
typedef void (__stdcall *PFNGLCLIPPLANEFOESPROC)(GLenum plane, const GLfloat * equation);
typedef void (__stdcall *PFNGLCLIPPLANEXOESPROC)(GLenum plane, const GLfixed * equation);
typedef void (__stdcall *PFNGLCOLOR3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLCOLOR3FVERTEX3FVSUNPROC)(const GLfloat * c, const GLfloat * v);
typedef void (__stdcall *PFNGLCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void (__stdcall *PFNGLCOLOR3HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLCOLOR3XOESPROC)(GLfixed red, GLfixed green, GLfixed blue);
typedef void (__stdcall *PFNGLCOLOR3XVOESPROC)(const GLfixed * components);
typedef void (__stdcall *PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat * c, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLCOLOR4HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
typedef void (__stdcall *PFNGLCOLOR4HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLCOLOR4UBVERTEX2FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void (__stdcall *PFNGLCOLOR4UBVERTEX2FVSUNPROC)(const GLubyte * c, const GLfloat * v);
typedef void (__stdcall *PFNGLCOLOR4UBVERTEX3FSUNPROC)(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLCOLOR4UBVERTEX3FVSUNPROC)(const GLubyte * c, const GLfloat * v);
typedef void (__stdcall *PFNGLCOLOR4XOESPROC)(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall *PFNGLCOLOR4XVOESPROC)(const GLfixed * components);
typedef void (__stdcall *PFNGLCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLCOLORFRAGMENTOP1ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall *PFNGLCOLORFRAGMENTOP2ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall *PFNGLCOLORFRAGMENTOP3ATIPROC)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall *PFNGLCOLORMASKPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (__stdcall *PFNGLCOLORMASKINDEXEDEXTPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall *PFNGLCOLORMASKIPROC)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall *PFNGLCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (__stdcall *PFNGLCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLCOLORPOINTERVINTELPROC)(GLint size, GLenum type, const void ** pointer);
typedef void (__stdcall *PFNGLCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data);
typedef void (__stdcall *PFNGLCOLORTABLEEXTPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void * table);
typedef void (__stdcall *PFNGLCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * table);
typedef void (__stdcall *PFNGLCOMBINERINPUTNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall *PFNGLCOMBINEROUTPUTNVPROC)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void (__stdcall *PFNGLCOMBINERPARAMETERFNVPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLCOMBINERPARAMETERFVNVPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLCOMBINERPARAMETERINVPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLCOMBINERPARAMETERIVNVPROC)(GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLCOMMANDLISTSEGMENTSNVPROC)(GLuint list, GLuint segments);
typedef void (__stdcall *PFNGLCOMPILECOMMANDLISTNVPROC)(GLuint list);
typedef void (__stdcall *PFNGLCOMPILESHADERPROC)(GLuint shader);
typedef void (__stdcall *PFNGLCOMPILESHADERARBPROC)(GLhandleARB shaderObj);
typedef void (__stdcall *PFNGLCOMPILESHADERINCLUDEARBPROC)(GLuint shader, GLsizei count, const GLchar *const* path, const GLint * length);
typedef void (__stdcall *PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXIMAGE1DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXIMAGE2DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXIMAGE3DPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXIMAGE3DARBPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data);
typedef void (__stdcall *PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * bits);
typedef void (__stdcall *PFNGLCONSERVATIVERASTERPARAMETERFNVPROC)(GLenum pname, GLfloat value);
typedef void (__stdcall *PFNGLCONSERVATIVERASTERPARAMETERINVPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * image);
typedef void (__stdcall *PFNGLCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * image);
typedef void (__stdcall *PFNGLCONVOLUTIONPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat params);
typedef void (__stdcall *PFNGLCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLCONVOLUTIONPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint params);
typedef void (__stdcall *PFNGLCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLCONVOLUTIONPARAMETERXOESPROC)(GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLCONVOLUTIONPARAMETERXVOESPROC)(GLenum target, GLenum pname, const GLfixed * params);
typedef void (__stdcall *PFNGLCOPYBUFFERSUBDATAPROC)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall *PFNGLCOPYCOLORSUBTABLEEXTPROC)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYCOLORTABLESGIPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYIMAGESUBDATAPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (__stdcall *PFNGLCOPYIMAGESUBDATANVPROC)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall *PFNGLCOPYMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall *PFNGLCOPYMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall *PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYNAMEDBUFFERSUBDATAPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall *PFNGLCOPYPATHNVPROC)(GLuint resultPath, GLuint srcPath);
typedef void (__stdcall *PFNGLCOPYTEXIMAGE1DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall *PFNGLCOPYTEXIMAGE1DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall *PFNGLCOPYTEXIMAGE2DPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall *PFNGLCOPYTEXIMAGE2DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall *PFNGLCOPYTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall *PFNGLCOPYTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall *PFNGLCOPYTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall *PFNGLCOPYTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLCOVERFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (__stdcall *PFNGLCOVERFILLPATHNVPROC)(GLuint path, GLenum coverMode);
typedef void (__stdcall *PFNGLCOVERSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (__stdcall *PFNGLCOVERSTROKEPATHNVPROC)(GLuint path, GLenum coverMode);
typedef void (__stdcall *PFNGLCOVERAGEMODULATIONNVPROC)(GLenum components);
typedef void (__stdcall *PFNGLCOVERAGEMODULATIONTABLENVPROC)(GLsizei n, const GLfloat * v);
typedef void (__stdcall *PFNGLCREATEBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (__stdcall *PFNGLCREATECOMMANDLISTSNVPROC)(GLsizei n, GLuint * lists);
typedef void (__stdcall *PFNGLCREATEFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef void (__stdcall *PFNGLCREATEMEMORYOBJECTSEXTPROC)(GLsizei n, GLuint * memoryObjects);
typedef void (__stdcall *PFNGLCREATEPERFQUERYINTELPROC)(GLuint queryId, GLuint * queryHandle);
typedef GLuint (__stdcall *PFNGLCREATEPROGRAMPROC)(void);
typedef GLhandleARB (__stdcall *PFNGLCREATEPROGRAMOBJECTARBPROC)(void);
typedef void (__stdcall *PFNGLCREATEPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef GLuint (__stdcall *PFNGLCREATEPROGRESSFENCENVXPROC)(void);
typedef void (__stdcall *PFNGLCREATEQUERIESPROC)(GLenum target, GLsizei n, GLuint * ids);
typedef void (__stdcall *PFNGLCREATERENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (__stdcall *PFNGLCREATESAMPLERSPROC)(GLsizei n, GLuint * samplers);
typedef void (__stdcall *PFNGLCREATESEMAPHORESNVPROC)(GLsizei n, GLuint * semaphores);
typedef GLuint (__stdcall *PFNGLCREATESHADERPROC)(GLenum type);
typedef GLhandleARB (__stdcall *PFNGLCREATESHADEROBJECTARBPROC)(GLenum shaderType);
typedef GLuint (__stdcall *PFNGLCREATESHADERPROGRAMEXTPROC)(GLenum type, const GLchar * string);
typedef GLuint (__stdcall *PFNGLCREATESHADERPROGRAMVPROC)(GLenum type, GLsizei count, const GLchar *const* strings);
typedef void (__stdcall *PFNGLCREATESTATESNVPROC)(GLsizei n, GLuint * states);
typedef GLsync (__stdcall *PFNGLCREATESYNCFROMCLEVENTARBPROC)(struct _cl_context * context, struct _cl_event * event, GLbitfield flags);
typedef void (__stdcall *PFNGLCREATETEXTURESPROC)(GLenum target, GLsizei n, GLuint * textures);
typedef void (__stdcall *PFNGLCREATETRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (__stdcall *PFNGLCREATEVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (__stdcall *PFNGLCULLFACEPROC)(GLenum mode);
typedef void (__stdcall *PFNGLCULLPARAMETERDVEXTPROC)(GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLCULLPARAMETERFVEXTPROC)(GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLCURRENTPALETTEMATRIXARBPROC)(GLint index);
typedef void (__stdcall *PFNGLDEBUGMESSAGECALLBACKPROC)(GLDEBUGPROC callback, const void * userParam);
typedef void (__stdcall *PFNGLDEBUGMESSAGECALLBACKAMDPROC)(GLDEBUGPROCAMD callback, void * userParam);
typedef void (__stdcall *PFNGLDEBUGMESSAGECALLBACKARBPROC)(GLDEBUGPROCARB callback, const void * userParam);
typedef void (__stdcall *PFNGLDEBUGMESSAGECONTROLPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (__stdcall *PFNGLDEBUGMESSAGECONTROLARBPROC)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (__stdcall *PFNGLDEBUGMESSAGEENABLEAMDPROC)(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled);
typedef void (__stdcall *PFNGLDEBUGMESSAGEINSERTPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
typedef void (__stdcall *PFNGLDEBUGMESSAGEINSERTAMDPROC)(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf);
typedef void (__stdcall *PFNGLDEBUGMESSAGEINSERTARBPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf);
typedef void (__stdcall *PFNGLDEFORMSGIXPROC)(GLbitfield mask);
typedef void (__stdcall *PFNGLDEFORMATIONMAP3DSGIXPROC)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points);
typedef void (__stdcall *PFNGLDEFORMATIONMAP3FSGIXPROC)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points);
typedef void (__stdcall *PFNGLDELETEASYNCMARKERSSGIXPROC)(GLuint marker, GLsizei range);
typedef void (__stdcall *PFNGLDELETEBUFFERSPROC)(GLsizei n, const GLuint * buffers);
typedef void (__stdcall *PFNGLDELETEBUFFERSARBPROC)(GLsizei n, const GLuint * buffers);
typedef void (__stdcall *PFNGLDELETECOMMANDLISTSNVPROC)(GLsizei n, const GLuint * lists);
typedef void (__stdcall *PFNGLDELETEFENCESAPPLEPROC)(GLsizei n, const GLuint * fences);
typedef void (__stdcall *PFNGLDELETEFENCESNVPROC)(GLsizei n, const GLuint * fences);
typedef void (__stdcall *PFNGLDELETEFRAGMENTSHADERATIPROC)(GLuint id);
typedef void (__stdcall *PFNGLDELETEFRAMEBUFFERSPROC)(GLsizei n, const GLuint * framebuffers);
typedef void (__stdcall *PFNGLDELETEFRAMEBUFFERSEXTPROC)(GLsizei n, const GLuint * framebuffers);
typedef void (__stdcall *PFNGLDELETEMEMORYOBJECTSEXTPROC)(GLsizei n, const GLuint * memoryObjects);
typedef void (__stdcall *PFNGLDELETENAMEDSTRINGARBPROC)(GLint namelen, const GLchar * name);
typedef void (__stdcall *PFNGLDELETENAMESAMDPROC)(GLenum identifier, GLuint num, const GLuint * names);
typedef void (__stdcall *PFNGLDELETEOBJECTARBPROC)(GLhandleARB obj);
typedef void (__stdcall *PFNGLDELETEOCCLUSIONQUERIESNVPROC)(GLsizei n, const GLuint * ids);
typedef void (__stdcall *PFNGLDELETEPATHSNVPROC)(GLuint path, GLsizei range);
typedef void (__stdcall *PFNGLDELETEPERFMONITORSAMDPROC)(GLsizei n, GLuint * monitors);
typedef void (__stdcall *PFNGLDELETEPERFQUERYINTELPROC)(GLuint queryHandle);
typedef void (__stdcall *PFNGLDELETEPROGRAMPROC)(GLuint program);
typedef void (__stdcall *PFNGLDELETEPROGRAMPIPELINESPROC)(GLsizei n, const GLuint * pipelines);
typedef void (__stdcall *PFNGLDELETEPROGRAMSARBPROC)(GLsizei n, const GLuint * programs);
typedef void (__stdcall *PFNGLDELETEPROGRAMSNVPROC)(GLsizei n, const GLuint * programs);
typedef void (__stdcall *PFNGLDELETEQUERIESPROC)(GLsizei n, const GLuint * ids);
typedef void (__stdcall *PFNGLDELETEQUERIESARBPROC)(GLsizei n, const GLuint * ids);
typedef void (__stdcall *PFNGLDELETEQUERYRESOURCETAGNVPROC)(GLsizei n, const GLint * tagIds);
typedef void (__stdcall *PFNGLDELETERENDERBUFFERSPROC)(GLsizei n, const GLuint * renderbuffers);
typedef void (__stdcall *PFNGLDELETERENDERBUFFERSEXTPROC)(GLsizei n, const GLuint * renderbuffers);
typedef void (__stdcall *PFNGLDELETESAMPLERSPROC)(GLsizei count, const GLuint * samplers);
typedef void (__stdcall *PFNGLDELETESEMAPHORESEXTPROC)(GLsizei n, const GLuint * semaphores);
typedef void (__stdcall *PFNGLDELETESHADERPROC)(GLuint shader);
typedef void (__stdcall *PFNGLDELETESTATESNVPROC)(GLsizei n, const GLuint * states);
typedef void (__stdcall *PFNGLDELETESYNCPROC)(GLsync sync);
typedef void (__stdcall *PFNGLDELETETEXTURESPROC)(GLsizei n, const GLuint * textures);
typedef void (__stdcall *PFNGLDELETETEXTURESEXTPROC)(GLsizei n, const GLuint * textures);
typedef void (__stdcall *PFNGLDELETETRANSFORMFEEDBACKSPROC)(GLsizei n, const GLuint * ids);
typedef void (__stdcall *PFNGLDELETETRANSFORMFEEDBACKSNVPROC)(GLsizei n, const GLuint * ids);
typedef void (__stdcall *PFNGLDELETEVERTEXARRAYSPROC)(GLsizei n, const GLuint * arrays);
typedef void (__stdcall *PFNGLDELETEVERTEXARRAYSAPPLEPROC)(GLsizei n, const GLuint * arrays);
typedef void (__stdcall *PFNGLDELETEVERTEXSHADEREXTPROC)(GLuint id);
typedef void (__stdcall *PFNGLDEPTHBOUNDSEXTPROC)(GLclampd zmin, GLclampd zmax);
typedef void (__stdcall *PFNGLDEPTHBOUNDSDNVPROC)(GLdouble zmin, GLdouble zmax);
typedef void (__stdcall *PFNGLDEPTHFUNCPROC)(GLenum func);
typedef void (__stdcall *PFNGLDEPTHMASKPROC)(GLboolean flag);
typedef void (__stdcall *PFNGLDEPTHRANGEPROC)(GLdouble n, GLdouble f);
typedef void (__stdcall *PFNGLDEPTHRANGEARRAYDVNVPROC)(GLuint first, GLsizei count, const GLdouble * v);
typedef void (__stdcall *PFNGLDEPTHRANGEARRAYVPROC)(GLuint first, GLsizei count, const GLdouble * v);
typedef void (__stdcall *PFNGLDEPTHRANGEINDEXEDPROC)(GLuint index, GLdouble n, GLdouble f);
typedef void (__stdcall *PFNGLDEPTHRANGEINDEXEDDNVPROC)(GLuint index, GLdouble n, GLdouble f);
typedef void (__stdcall *PFNGLDEPTHRANGEDNVPROC)(GLdouble zNear, GLdouble zFar);
typedef void (__stdcall *PFNGLDEPTHRANGEFPROC)(GLfloat n, GLfloat f);
typedef void (__stdcall *PFNGLDEPTHRANGEFOESPROC)(GLclampf n, GLclampf f);
typedef void (__stdcall *PFNGLDEPTHRANGEXOESPROC)(GLfixed n, GLfixed f);
typedef void (__stdcall *PFNGLDETACHOBJECTARBPROC)(GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void (__stdcall *PFNGLDETACHSHADERPROC)(GLuint program, GLuint shader);
typedef void (__stdcall *PFNGLDETAILTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat * points);
typedef void (__stdcall *PFNGLDISABLEPROC)(GLenum cap);
typedef void (__stdcall *PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
typedef void (__stdcall *PFNGLDISABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
typedef void (__stdcall *PFNGLDISABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
typedef void (__stdcall *PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
typedef void (__stdcall *PFNGLDISABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (__stdcall *PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
typedef void (__stdcall *PFNGLDISABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
typedef void (__stdcall *PFNGLDISABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
typedef void (__stdcall *PFNGLDISABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (__stdcall *PFNGLDISABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
typedef void (__stdcall *PFNGLDISABLEIPROC)(GLenum target, GLuint index);
typedef void (__stdcall *PFNGLDISPATCHCOMPUTEPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (__stdcall *PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
typedef void (__stdcall *PFNGLDISPATCHCOMPUTEINDIRECTPROC)(GLintptr indirect);
typedef void (__stdcall *PFNGLDRAWARRAYSPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall *PFNGLDRAWARRAYSEXTPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall *PFNGLDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect);
typedef void (__stdcall *PFNGLDRAWARRAYSINSTANCEDPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
typedef void (__stdcall *PFNGLDRAWARRAYSINSTANCEDARBPROC)(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall *PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void (__stdcall *PFNGLDRAWARRAYSINSTANCEDEXTPROC)(GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void (__stdcall *PFNGLDRAWBUFFERPROC)(GLenum buf);
typedef void (__stdcall *PFNGLDRAWBUFFERSPROC)(GLsizei n, const GLenum * bufs);
typedef void (__stdcall *PFNGLDRAWBUFFERSARBPROC)(GLsizei n, const GLenum * bufs);
typedef void (__stdcall *PFNGLDRAWBUFFERSATIPROC)(GLsizei n, const GLenum * bufs);
typedef void (__stdcall *PFNGLDRAWCOMMANDSADDRESSNVPROC)(GLenum primitiveMode, const GLuint64 * indirects, const GLsizei * sizes, GLuint count);
typedef void (__stdcall *PFNGLDRAWCOMMANDSNVPROC)(GLenum primitiveMode, GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, GLuint count);
typedef void (__stdcall *PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC)(const GLuint64 * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);
typedef void (__stdcall *PFNGLDRAWCOMMANDSSTATESNVPROC)(GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);
typedef void (__stdcall *PFNGLDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall *PFNGLDRAWELEMENTARRAYATIPROC)(GLenum mode, GLsizei count);
typedef void (__stdcall *PFNGLDRAWELEMENTSPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices);
typedef void (__stdcall *PFNGLDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (__stdcall *PFNGLDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect);
typedef void (__stdcall *PFNGLDRAWELEMENTSINSTANCEDPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount);
typedef void (__stdcall *PFNGLDRAWELEMENTSINSTANCEDARBPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
typedef void (__stdcall *PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance);
typedef void (__stdcall *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex);
typedef void (__stdcall *PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
typedef void (__stdcall *PFNGLDRAWELEMENTSINSTANCEDEXTPROC)(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
typedef void (__stdcall *PFNGLDRAWMESHARRAYSSUNPROC)(GLenum mode, GLint first, GLsizei count, GLsizei width);
typedef void (__stdcall *PFNGLDRAWMESHTASKSINDIRECTNVPROC)(GLintptr indirect);
typedef void (__stdcall *PFNGLDRAWMESHTASKSNVPROC)(GLuint first, GLuint count);
typedef void (__stdcall *PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void (__stdcall *PFNGLDRAWRANGEELEMENTARRAYATIPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void (__stdcall *PFNGLDRAWRANGEELEMENTSPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
typedef void (__stdcall *PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex);
typedef void (__stdcall *PFNGLDRAWRANGEELEMENTSEXTPROC)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices);
typedef void (__stdcall *PFNGLDRAWTEXTURENVPROC)(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef void (__stdcall *PFNGLDRAWTRANSFORMFEEDBACKPROC)(GLenum mode, GLuint id);
typedef void (__stdcall *PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)(GLenum mode, GLuint id, GLsizei instancecount);
typedef void (__stdcall *PFNGLDRAWTRANSFORMFEEDBACKNVPROC)(GLenum mode, GLuint id);
typedef void (__stdcall *PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)(GLenum mode, GLuint id, GLuint stream);
typedef void (__stdcall *PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
typedef void (__stdcall *PFNGLDRAWVKIMAGENVPROC)(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef void (__stdcall *PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC)(GLenum target, GLeglImageOES image, const GLint * attrib_list);
typedef void (__stdcall *PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC)(GLuint texture, GLeglImageOES image, const GLint * attrib_list);
typedef void (__stdcall *PFNGLEDGEFLAGFORMATNVPROC)(GLsizei stride);
typedef void (__stdcall *PFNGLEDGEFLAGPOINTEREXTPROC)(GLsizei stride, GLsizei count, const GLboolean * pointer);
typedef void (__stdcall *PFNGLEDGEFLAGPOINTERLISTIBMPROC)(GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLELEMENTPOINTERAPPLEPROC)(GLenum type, const void * pointer);
typedef void (__stdcall *PFNGLELEMENTPOINTERATIPROC)(GLenum type, const void * pointer);
typedef void (__stdcall *PFNGLENABLEPROC)(GLenum cap);
typedef void (__stdcall *PFNGLENABLECLIENTSTATEINDEXEDEXTPROC)(GLenum array, GLuint index);
typedef void (__stdcall *PFNGLENABLECLIENTSTATEIEXTPROC)(GLenum array, GLuint index);
typedef void (__stdcall *PFNGLENABLEINDEXEDEXTPROC)(GLenum target, GLuint index);
typedef void (__stdcall *PFNGLENABLEVARIANTCLIENTSTATEEXTPROC)(GLuint id);
typedef void (__stdcall *PFNGLENABLEVERTEXARRAYATTRIBPROC)(GLuint vaobj, GLuint index);
typedef void (__stdcall *PFNGLENABLEVERTEXARRAYATTRIBEXTPROC)(GLuint vaobj, GLuint index);
typedef void (__stdcall *PFNGLENABLEVERTEXARRAYEXTPROC)(GLuint vaobj, GLenum array);
typedef void (__stdcall *PFNGLENABLEVERTEXATTRIBAPPLEPROC)(GLuint index, GLenum pname);
typedef void (__stdcall *PFNGLENABLEVERTEXATTRIBARRAYPROC)(GLuint index);
typedef void (__stdcall *PFNGLENABLEVERTEXATTRIBARRAYARBPROC)(GLuint index);
typedef void (__stdcall *PFNGLENABLEIPROC)(GLenum target, GLuint index);
typedef void (__stdcall *PFNGLENDCONDITIONALRENDERPROC)(void);
typedef void (__stdcall *PFNGLENDCONDITIONALRENDERNVPROC)(void);
typedef void (__stdcall *PFNGLENDCONDITIONALRENDERNVXPROC)(void);
typedef void (__stdcall *PFNGLENDFRAGMENTSHADERATIPROC)(void);
typedef void (__stdcall *PFNGLENDOCCLUSIONQUERYNVPROC)(void);
typedef void (__stdcall *PFNGLENDPERFMONITORAMDPROC)(GLuint monitor);
typedef void (__stdcall *PFNGLENDPERFQUERYINTELPROC)(GLuint queryHandle);
typedef void (__stdcall *PFNGLENDQUERYPROC)(GLenum target);
typedef void (__stdcall *PFNGLENDQUERYARBPROC)(GLenum target);
typedef void (__stdcall *PFNGLENDQUERYINDEXEDPROC)(GLenum target, GLuint index);
typedef void (__stdcall *PFNGLENDTRANSFORMFEEDBACKPROC)(void);
typedef void (__stdcall *PFNGLENDTRANSFORMFEEDBACKEXTPROC)(void);
typedef void (__stdcall *PFNGLENDTRANSFORMFEEDBACKNVPROC)(void);
typedef void (__stdcall *PFNGLENDVERTEXSHADEREXTPROC)(void);
typedef void (__stdcall *PFNGLENDVIDEOCAPTURENVPROC)(GLuint video_capture_slot);
typedef void (__stdcall *PFNGLEVALCOORD1XOESPROC)(GLfixed u);
typedef void (__stdcall *PFNGLEVALCOORD1XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLEVALCOORD2XOESPROC)(GLfixed u, GLfixed v);
typedef void (__stdcall *PFNGLEVALCOORD2XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLEVALMAPSNVPROC)(GLenum target, GLenum mode);
typedef void (__stdcall *PFNGLEVALUATEDEPTHVALUESARBPROC)(void);
typedef void (__stdcall *PFNGLEXECUTEPROGRAMNVPROC)(GLenum target, GLuint id, const GLfloat * params);
typedef void (__stdcall *PFNGLEXTRACTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
typedef void (__stdcall *PFNGLFEEDBACKBUFFERXOESPROC)(GLsizei n, GLenum type, const GLfixed * buffer);
typedef GLsync (__stdcall *PFNGLFENCESYNCPROC)(GLenum condition, GLbitfield flags);
typedef void (__stdcall *PFNGLFINALCOMBINERINPUTNVPROC)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall *PFNGLFINISHPROC)(void);
typedef GLint (__stdcall *PFNGLFINISHASYNCSGIXPROC)(GLuint * markerp);
typedef void (__stdcall *PFNGLFINISHFENCEAPPLEPROC)(GLuint fence);
typedef void (__stdcall *PFNGLFINISHFENCENVPROC)(GLuint fence);
typedef void (__stdcall *PFNGLFINISHOBJECTAPPLEPROC)(GLenum object, GLint name);
typedef void (__stdcall *PFNGLFINISHTEXTURESUNXPROC)(void);
typedef void (__stdcall *PFNGLFLUSHPROC)(void);
typedef void (__stdcall *PFNGLFLUSHMAPPEDBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall *PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC)(GLenum target, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall *PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall *PFNGLFLUSHPIXELDATARANGENVPROC)(GLenum target);
typedef void (__stdcall *PFNGLFLUSHRASTERSGIXPROC)(void);
typedef void (__stdcall *PFNGLFLUSHSTATICDATAIBMPROC)(GLenum target);
typedef void (__stdcall *PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void * pointer);
typedef void (__stdcall *PFNGLFLUSHVERTEXARRAYRANGENVPROC)(void);
typedef void (__stdcall *PFNGLFOGCOORDFORMATNVPROC)(GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLFOGCOORDPOINTEREXTPROC)(GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLFOGCOORDPOINTERLISTIBMPROC)(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLFOGCOORDDEXTPROC)(GLdouble coord);
typedef void (__stdcall *PFNGLFOGCOORDDVEXTPROC)(const GLdouble * coord);
typedef void (__stdcall *PFNGLFOGCOORDFEXTPROC)(GLfloat coord);
typedef void (__stdcall *PFNGLFOGCOORDFVEXTPROC)(const GLfloat * coord);
typedef void (__stdcall *PFNGLFOGCOORDHNVPROC)(GLhalfNV fog);
typedef void (__stdcall *PFNGLFOGCOORDHVNVPROC)(const GLhalfNV * fog);
typedef void (__stdcall *PFNGLFOGFUNCSGISPROC)(GLsizei n, const GLfloat * points);
typedef void (__stdcall *PFNGLFOGXOESPROC)(GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLFOGXVOESPROC)(GLenum pname, const GLfixed * param);
typedef void (__stdcall *PFNGLFRAGMENTCOLORMATERIALSGIXPROC)(GLenum face, GLenum mode);
typedef void (__stdcall *PFNGLFRAGMENTCOVERAGECOLORNVPROC)(GLuint color);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTMODELFSGIXPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTMODELFVSGIXPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTMODELISGIXPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTMODELIVSGIXPROC)(GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTFSGIXPROC)(GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTISGIXPROC)(GLenum light, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLFRAGMENTMATERIALFSGIXPROC)(GLenum face, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLFRAGMENTMATERIALISGIXPROC)(GLenum face, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLFRAMETERMINATORGREMEDYPROC)(void);
typedef void (__stdcall *PFNGLFRAMEZOOMSGIXPROC)(GLint factor);
typedef void (__stdcall *PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
typedef void (__stdcall *PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC)(GLuint framebuffer, GLsizei n, const GLenum * bufs);
typedef void (__stdcall *PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC)(void);
typedef void (__stdcall *PFNGLFRAMEBUFFERPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLFRAMEBUFFERPARAMETERIMESAPROC)(GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLFRAMEBUFFERREADBUFFEREXTPROC)(GLuint framebuffer, GLenum mode);
typedef void (__stdcall *PFNGLFRAMEBUFFERRENDERBUFFERPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall *PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall *PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(GLenum target, GLuint start, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLenum target, GLuint start, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat * values);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTUREPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURE1DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURE2DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURE3DPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTUREARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTUREEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTUREFACEARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURELAYERPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURELAYERARBPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall *PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
typedef void (__stdcall *PFNGLFREEOBJECTBUFFERATIPROC)(GLuint buffer);
typedef void (__stdcall *PFNGLFRONTFACEPROC)(GLenum mode);
typedef void (__stdcall *PFNGLFRUSTUMFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void (__stdcall *PFNGLFRUSTUMXOESPROC)(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);
typedef GLuint (__stdcall *PFNGLGENASYNCMARKERSSGIXPROC)(GLsizei range);
typedef void (__stdcall *PFNGLGENBUFFERSPROC)(GLsizei n, GLuint * buffers);
typedef void (__stdcall *PFNGLGENBUFFERSARBPROC)(GLsizei n, GLuint * buffers);
typedef void (__stdcall *PFNGLGENFENCESAPPLEPROC)(GLsizei n, GLuint * fences);
typedef void (__stdcall *PFNGLGENFENCESNVPROC)(GLsizei n, GLuint * fences);
typedef GLuint (__stdcall *PFNGLGENFRAGMENTSHADERSATIPROC)(GLuint range);
typedef void (__stdcall *PFNGLGENFRAMEBUFFERSPROC)(GLsizei n, GLuint * framebuffers);
typedef void (__stdcall *PFNGLGENFRAMEBUFFERSEXTPROC)(GLsizei n, GLuint * framebuffers);
typedef void (__stdcall *PFNGLGENNAMESAMDPROC)(GLenum identifier, GLuint num, GLuint * names);
typedef void (__stdcall *PFNGLGENOCCLUSIONQUERIESNVPROC)(GLsizei n, GLuint * ids);
typedef GLuint (__stdcall *PFNGLGENPATHSNVPROC)(GLsizei range);
typedef void (__stdcall *PFNGLGENPERFMONITORSAMDPROC)(GLsizei n, GLuint * monitors);
typedef void (__stdcall *PFNGLGENPROGRAMPIPELINESPROC)(GLsizei n, GLuint * pipelines);
typedef void (__stdcall *PFNGLGENPROGRAMSARBPROC)(GLsizei n, GLuint * programs);
typedef void (__stdcall *PFNGLGENPROGRAMSNVPROC)(GLsizei n, GLuint * programs);
typedef void (__stdcall *PFNGLGENQUERIESPROC)(GLsizei n, GLuint * ids);
typedef void (__stdcall *PFNGLGENQUERIESARBPROC)(GLsizei n, GLuint * ids);
typedef void (__stdcall *PFNGLGENQUERYRESOURCETAGNVPROC)(GLsizei n, GLint * tagIds);
typedef void (__stdcall *PFNGLGENRENDERBUFFERSPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (__stdcall *PFNGLGENRENDERBUFFERSEXTPROC)(GLsizei n, GLuint * renderbuffers);
typedef void (__stdcall *PFNGLGENSAMPLERSPROC)(GLsizei count, GLuint * samplers);
typedef void (__stdcall *PFNGLGENSEMAPHORESEXTPROC)(GLsizei n, GLuint * semaphores);
typedef GLuint (__stdcall *PFNGLGENSYMBOLSEXTPROC)(GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
typedef void (__stdcall *PFNGLGENTEXTURESPROC)(GLsizei n, GLuint * textures);
typedef void (__stdcall *PFNGLGENTEXTURESEXTPROC)(GLsizei n, GLuint * textures);
typedef void (__stdcall *PFNGLGENTRANSFORMFEEDBACKSPROC)(GLsizei n, GLuint * ids);
typedef void (__stdcall *PFNGLGENTRANSFORMFEEDBACKSNVPROC)(GLsizei n, GLuint * ids);
typedef void (__stdcall *PFNGLGENVERTEXARRAYSPROC)(GLsizei n, GLuint * arrays);
typedef void (__stdcall *PFNGLGENVERTEXARRAYSAPPLEPROC)(GLsizei n, GLuint * arrays);
typedef GLuint (__stdcall *PFNGLGENVERTEXSHADERSEXTPROC)(GLuint range);
typedef void (__stdcall *PFNGLGENERATEMIPMAPPROC)(GLenum target);
typedef void (__stdcall *PFNGLGENERATEMIPMAPEXTPROC)(GLenum target);
typedef void (__stdcall *PFNGLGENERATEMULTITEXMIPMAPEXTPROC)(GLenum texunit, GLenum target);
typedef void (__stdcall *PFNGLGENERATETEXTUREMIPMAPPROC)(GLuint texture);
typedef void (__stdcall *PFNGLGENERATETEXTUREMIPMAPEXTPROC)(GLuint texture, GLenum target);
typedef void (__stdcall *PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETACTIVEATTRIBPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (__stdcall *PFNGLGETACTIVEATTRIBARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);
typedef void (__stdcall *PFNGLGETACTIVESUBROUTINENAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (__stdcall *PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (__stdcall *PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values);
typedef void (__stdcall *PFNGLGETACTIVEUNIFORMPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name);
typedef void (__stdcall *PFNGLGETACTIVEUNIFORMARBPROC)(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name);
typedef void (__stdcall *PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName);
typedef void (__stdcall *PFNGLGETACTIVEUNIFORMBLOCKIVPROC)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETACTIVEUNIFORMNAMEPROC)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName);
typedef void (__stdcall *PFNGLGETACTIVEUNIFORMSIVPROC)(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETACTIVEVARYINGNVPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (__stdcall *PFNGLGETARRAYOBJECTFVATIPROC)(GLenum array, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETARRAYOBJECTIVATIPROC)(GLenum array, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETATTACHEDOBJECTSARBPROC)(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj);
typedef void (__stdcall *PFNGLGETATTACHEDSHADERSPROC)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders);
typedef GLint (__stdcall *PFNGLGETATTRIBLOCATIONPROC)(GLuint program, const GLchar * name);
typedef GLint (__stdcall *PFNGLGETATTRIBLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB * name);
typedef void (__stdcall *PFNGLGETBOOLEANINDEXEDVEXTPROC)(GLenum target, GLuint index, GLboolean * data);
typedef void (__stdcall *PFNGLGETBOOLEANI_VPROC)(GLenum target, GLuint index, GLboolean * data);
typedef void (__stdcall *PFNGLGETBOOLEANVPROC)(GLenum pname, GLboolean * data);
typedef void (__stdcall *PFNGLGETBUFFERPARAMETERI64VPROC)(GLenum target, GLenum pname, GLint64 * params);
typedef void (__stdcall *PFNGLGETBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETBUFFERPARAMETERIVARBPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETBUFFERPARAMETERUI64VNVPROC)(GLenum target, GLenum pname, GLuint64EXT * params);
typedef void (__stdcall *PFNGLGETBUFFERPOINTERVPROC)(GLenum target, GLenum pname, void ** params);
typedef void (__stdcall *PFNGLGETBUFFERPOINTERVARBPROC)(GLenum target, GLenum pname, void ** params);
typedef void (__stdcall *PFNGLGETBUFFERSUBDATAPROC)(GLenum target, GLintptr offset, GLsizeiptr size, void * data);
typedef void (__stdcall *PFNGLGETBUFFERSUBDATAARBPROC)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data);
typedef void (__stdcall *PFNGLGETCLIPPLANEFOESPROC)(GLenum plane, GLfloat * equation);
typedef void (__stdcall *PFNGLGETCLIPPLANEXOESPROC)(GLenum plane, GLfixed * equation);
typedef void (__stdcall *PFNGLGETCOLORTABLEEXTPROC)(GLenum target, GLenum format, GLenum type, void * data);
typedef void (__stdcall *PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETCOLORTABLEPARAMETERFVSGIPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETCOLORTABLEPARAMETERIVSGIPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETCOLORTABLESGIPROC)(GLenum target, GLenum format, GLenum type, void * table);
typedef void (__stdcall *PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC)(GLenum stage, GLenum portion, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC)(GLenum stage, GLenum pname, GLfloat * params);
typedef GLuint (__stdcall *PFNGLGETCOMMANDHEADERNVPROC)(GLenum tokenID, GLuint size);
typedef void (__stdcall *PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint lod, void * img);
typedef void (__stdcall *PFNGLGETCOMPRESSEDTEXIMAGEPROC)(GLenum target, GLint level, void * img);
typedef void (__stdcall *PFNGLGETCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint level, void * img);
typedef void (__stdcall *PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLsizei bufSize, void * pixels);
typedef void (__stdcall *PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint lod, void * img);
typedef void (__stdcall *PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels);
typedef void (__stdcall *PFNGLGETCONVOLUTIONFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void * image);
typedef void (__stdcall *PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETCONVOLUTIONPARAMETERXVOESPROC)(GLenum target, GLenum pname, GLfixed * params);
typedef void (__stdcall *PFNGLGETCOVERAGEMODULATIONTABLENVPROC)(GLsizei bufSize, GLfloat * v);
typedef GLuint (__stdcall *PFNGLGETDEBUGMESSAGELOGPROC)(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
typedef GLuint (__stdcall *PFNGLGETDEBUGMESSAGELOGAMDPROC)(GLuint count, GLsizei bufSize, GLenum * categories, GLenum * severities, GLuint * ids, GLsizei * lengths, GLchar * message);
typedef GLuint (__stdcall *PFNGLGETDEBUGMESSAGELOGARBPROC)(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog);
typedef void (__stdcall *PFNGLGETDETAILTEXFUNCSGISPROC)(GLenum target, GLfloat * points);
typedef void (__stdcall *PFNGLGETDOUBLEINDEXEDVEXTPROC)(GLenum target, GLuint index, GLdouble * data);
typedef void (__stdcall *PFNGLGETDOUBLEI_VPROC)(GLenum target, GLuint index, GLdouble * data);
typedef void (__stdcall *PFNGLGETDOUBLEI_VEXTPROC)(GLenum pname, GLuint index, GLdouble * params);
typedef void (__stdcall *PFNGLGETDOUBLEVPROC)(GLenum pname, GLdouble * data);
typedef GLenum (__stdcall *PFNGLGETERRORPROC)(void);
typedef void (__stdcall *PFNGLGETFENCEIVNVPROC)(GLuint fence, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC)(GLenum variable, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC)(GLenum variable, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFIRSTPERFQUERYIDINTELPROC)(GLuint * queryId);
typedef void (__stdcall *PFNGLGETFIXEDVOESPROC)(GLenum pname, GLfixed * params);
typedef void (__stdcall *PFNGLGETFLOATINDEXEDVEXTPROC)(GLenum target, GLuint index, GLfloat * data);
typedef void (__stdcall *PFNGLGETFLOATI_VPROC)(GLenum target, GLuint index, GLfloat * data);
typedef void (__stdcall *PFNGLGETFLOATI_VEXTPROC)(GLenum pname, GLuint index, GLfloat * params);
typedef void (__stdcall *PFNGLGETFLOATVPROC)(GLenum pname, GLfloat * data);
typedef void (__stdcall *PFNGLGETFOGFUNCSGISPROC)(GLfloat * points);
typedef GLint (__stdcall *PFNGLGETFRAGDATAINDEXPROC)(GLuint program, const GLchar * name);
typedef GLint (__stdcall *PFNGLGETFRAGDATALOCATIONPROC)(GLuint program, const GLchar * name);
typedef GLint (__stdcall *PFNGLGETFRAGDATALOCATIONEXTPROC)(GLuint program, const GLchar * name);
typedef void (__stdcall *PFNGLGETFRAGMENTLIGHTFVSGIXPROC)(GLenum light, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETFRAGMENTLIGHTIVSGIXPROC)(GLenum light, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFRAGMENTMATERIALFVSGIXPROC)(GLenum face, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETFRAGMENTMATERIALIVSGIXPROC)(GLenum face, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLenum target, GLenum attachment, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC)(GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);
typedef void (__stdcall *PFNGLGETFRAMEBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC)(GLenum target, GLenum pname, GLint * params);
typedef GLenum (__stdcall *PFNGLGETGRAPHICSRESETSTATUSPROC)(void);
typedef GLenum (__stdcall *PFNGLGETGRAPHICSRESETSTATUSARBPROC)(void);
typedef GLhandleARB (__stdcall *PFNGLGETHANDLEARBPROC)(GLenum pname);
typedef void (__stdcall *PFNGLGETHISTOGRAMEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);
typedef void (__stdcall *PFNGLGETHISTOGRAMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETHISTOGRAMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETHISTOGRAMPARAMETERXVOESPROC)(GLenum target, GLenum pname, GLfixed * params);
typedef GLuint64 (__stdcall *PFNGLGETIMAGEHANDLEARBPROC)(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall *PFNGLGETIMAGEHANDLENVPROC)(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef void (__stdcall *PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETINFOLOGARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog);
typedef GLint (__stdcall *PFNGLGETINSTRUMENTSSGIXPROC)(void);
typedef void (__stdcall *PFNGLGETINTEGER64I_VPROC)(GLenum target, GLuint index, GLint64 * data);
typedef void (__stdcall *PFNGLGETINTEGER64VPROC)(GLenum pname, GLint64 * data);
typedef void (__stdcall *PFNGLGETINTEGERINDEXEDVEXTPROC)(GLenum target, GLuint index, GLint * data);
typedef void (__stdcall *PFNGLGETINTEGERI_VPROC)(GLenum target, GLuint index, GLint * data);
typedef void (__stdcall *PFNGLGETINTEGERUI64I_VNVPROC)(GLenum value, GLuint index, GLuint64EXT * result);
typedef void (__stdcall *PFNGLGETINTEGERUI64VNVPROC)(GLenum value, GLuint64EXT * result);
typedef void (__stdcall *PFNGLGETINTEGERVPROC)(GLenum pname, GLint * data);
typedef void (__stdcall *PFNGLGETINTERNALFORMATSAMPLEIVNVPROC)(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint * params);
typedef void (__stdcall *PFNGLGETINTERNALFORMATI64VPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 * params);
typedef void (__stdcall *PFNGLGETINTERNALFORMATIVPROC)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint * params);
typedef void (__stdcall *PFNGLGETINVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean * data);
typedef void (__stdcall *PFNGLGETINVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat * data);
typedef void (__stdcall *PFNGLGETINVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint * data);
typedef void (__stdcall *PFNGLGETLIGHTXOESPROC)(GLenum light, GLenum pname, GLfixed * params);
typedef void (__stdcall *PFNGLGETLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean * data);
typedef void (__stdcall *PFNGLGETLOCALCONSTANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat * data);
typedef void (__stdcall *PFNGLGETLOCALCONSTANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint * data);
typedef void (__stdcall *PFNGLGETMAPATTRIBPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETMAPATTRIBPARAMETERIVNVPROC)(GLenum target, GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void * points);
typedef void (__stdcall *PFNGLGETMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMAPXVOESPROC)(GLenum target, GLenum query, GLfixed * v);
typedef void (__stdcall *PFNGLGETMATERIALXOESPROC)(GLenum face, GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC)(GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint * params);
typedef void (__stdcall *PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC)(GLuint memoryObject, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMINMAXEXTPROC)(GLenum target, GLboolean reset, GLenum format, GLenum type, void * values);
typedef void (__stdcall *PFNGLGETMINMAXPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETMINMAXPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMULTITEXIMAGEEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (__stdcall *PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETMULTISAMPLEFVPROC)(GLenum pname, GLuint index, GLfloat * val);
typedef void (__stdcall *PFNGLGETMULTISAMPLEFVNVPROC)(GLenum pname, GLuint index, GLfloat * val);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)(GLuint buffer, GLenum pname, GLint64 * params);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERPARAMETERIVPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC)(GLuint buffer, GLenum pname, GLuint64EXT * params);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERPOINTERVPROC)(GLuint buffer, GLenum pname, void ** params);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERPOINTERVEXTPROC)(GLuint buffer, GLenum pname, void ** params);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);
typedef void (__stdcall *PFNGLGETNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data);
typedef void (__stdcall *PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC)(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values);
typedef void (__stdcall *PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)(GLuint framebuffer, GLenum pname, GLint * param);
typedef void (__stdcall *PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC)(GLuint framebuffer, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint * params);
typedef void (__stdcall *PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble * params);
typedef void (__stdcall *PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat * params);
typedef void (__stdcall *PFNGLGETNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum pname, void * string);
typedef void (__stdcall *PFNGLGETNAMEDPROGRAMIVEXTPROC)(GLuint program, GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)(GLuint renderbuffer, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC)(GLuint renderbuffer, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNAMEDSTRINGARBPROC)(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string);
typedef void (__stdcall *PFNGLGETNAMEDSTRINGIVARBPROC)(GLint namelen, const GLchar * name, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETNEXTPERFQUERYIDINTELPROC)(GLuint queryId, GLuint * nextQueryId);
typedef void (__stdcall *PFNGLGETOBJECTBUFFERFVATIPROC)(GLuint buffer, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETOBJECTBUFFERIVATIPROC)(GLuint buffer, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (__stdcall *PFNGLGETOBJECTLABELEXTPROC)(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (__stdcall *PFNGLGETOBJECTPARAMETERFVARBPROC)(GLhandleARB obj, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETOBJECTPARAMETERIVAPPLEPROC)(GLenum objectType, GLuint name, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETOBJECTPARAMETERIVARBPROC)(GLhandleARB obj, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETOBJECTPTRLABELPROC)(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label);
typedef void (__stdcall *PFNGLGETOCCLUSIONQUERYIVNVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETOCCLUSIONQUERYUIVNVPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETPATHCOMMANDSNVPROC)(GLuint path, GLubyte * commands);
typedef void (__stdcall *PFNGLGETPATHCOORDSNVPROC)(GLuint path, GLfloat * coords);
typedef void (__stdcall *PFNGLGETPATHDASHARRAYNVPROC)(GLuint path, GLfloat * dashArray);
typedef GLfloat (__stdcall *PFNGLGETPATHLENGTHNVPROC)(GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void (__stdcall *PFNGLGETPATHMETRICRANGENVPROC)(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics);
typedef void (__stdcall *PFNGLGETPATHMETRICSNVPROC)(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics);
typedef void (__stdcall *PFNGLGETPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname, GLfloat * value);
typedef void (__stdcall *PFNGLGETPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname, GLint * value);
typedef void (__stdcall *PFNGLGETPATHSPACINGNVPROC)(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing);
typedef void (__stdcall *PFNGLGETPERFCOUNTERINFOINTELPROC)(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar * counterName, GLuint counterDescLength, GLchar * counterDesc, GLuint * counterOffset, GLuint * counterDataSize, GLuint * counterTypeEnum, GLuint * counterDataTypeEnum, GLuint64 * rawCounterMaxValue);
typedef void (__stdcall *PFNGLGETPERFMONITORCOUNTERDATAAMDPROC)(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten);
typedef void (__stdcall *PFNGLGETPERFMONITORCOUNTERINFOAMDPROC)(GLuint group, GLuint counter, GLenum pname, void * data);
typedef void (__stdcall *PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC)(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString);
typedef void (__stdcall *PFNGLGETPERFMONITORCOUNTERSAMDPROC)(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters);
typedef void (__stdcall *PFNGLGETPERFMONITORGROUPSTRINGAMDPROC)(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString);
typedef void (__stdcall *PFNGLGETPERFMONITORGROUPSAMDPROC)(GLint * numGroups, GLsizei groupsSize, GLuint * groups);
typedef void (__stdcall *PFNGLGETPERFQUERYDATAINTELPROC)(GLuint queryHandle, GLuint flags, GLsizei dataSize, void * data, GLuint * bytesWritten);
typedef void (__stdcall *PFNGLGETPERFQUERYIDBYNAMEINTELPROC)(GLchar * queryName, GLuint * queryId);
typedef void (__stdcall *PFNGLGETPERFQUERYINFOINTELPROC)(GLuint queryId, GLuint queryNameLength, GLchar * queryName, GLuint * dataSize, GLuint * noCounters, GLuint * noInstances, GLuint * capsMask);
typedef void (__stdcall *PFNGLGETPIXELMAPXVPROC)(GLenum map, GLint size, GLfixed * values);
typedef void (__stdcall *PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETPOINTERINDEXEDVEXTPROC)(GLenum target, GLuint index, void ** data);
typedef void (__stdcall *PFNGLGETPOINTERI_VEXTPROC)(GLenum pname, GLuint index, void ** params);
typedef void (__stdcall *PFNGLGETPOINTERVPROC)(GLenum pname, void ** params);
typedef void (__stdcall *PFNGLGETPOINTERVEXTPROC)(GLenum pname, void ** params);
typedef void (__stdcall *PFNGLGETPROGRAMBINARYPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary);
typedef void (__stdcall *PFNGLGETPROGRAMENVPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint * params);
typedef void (__stdcall *PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint * params);
typedef void (__stdcall *PFNGLGETPROGRAMENVPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble * params);
typedef void (__stdcall *PFNGLGETPROGRAMENVPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat * params);
typedef void (__stdcall *PFNGLGETPROGRAMINFOLOGPROC)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (__stdcall *PFNGLGETPROGRAMINTERFACEIVPROC)(GLuint program, GLenum programInterface, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC)(GLenum target, GLuint index, GLint * params);
typedef void (__stdcall *PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC)(GLenum target, GLuint index, GLuint * params);
typedef void (__stdcall *PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC)(GLenum target, GLuint index, GLdouble * params);
typedef void (__stdcall *PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC)(GLenum target, GLuint index, GLfloat * params);
typedef void (__stdcall *PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params);
typedef void (__stdcall *PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params);
typedef void (__stdcall *PFNGLGETPROGRAMPARAMETERDVNVPROC)(GLenum target, GLuint index, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETPROGRAMPARAMETERFVNVPROC)(GLenum target, GLuint index, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETPROGRAMPIPELINEINFOLOGPROC)(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (__stdcall *PFNGLGETPROGRAMPIPELINEIVPROC)(GLuint pipeline, GLenum pname, GLint * params);
typedef GLuint (__stdcall *PFNGLGETPROGRAMRESOURCEINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (__stdcall *PFNGLGETPROGRAMRESOURCELOCATIONPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef GLint (__stdcall *PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)(GLuint program, GLenum programInterface, const GLchar * name);
typedef void (__stdcall *PFNGLGETPROGRAMRESOURCENAMEPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name);
typedef void (__stdcall *PFNGLGETPROGRAMRESOURCEFVNVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLfloat * params);
typedef void (__stdcall *PFNGLGETPROGRAMRESOURCEIVPROC)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLint * params);
typedef void (__stdcall *PFNGLGETPROGRAMSTAGEIVPROC)(GLuint program, GLenum shadertype, GLenum pname, GLint * values);
typedef void (__stdcall *PFNGLGETPROGRAMSTRINGARBPROC)(GLenum target, GLenum pname, void * string);
typedef void (__stdcall *PFNGLGETPROGRAMSTRINGNVPROC)(GLuint id, GLenum pname, GLubyte * program);
typedef void (__stdcall *PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC)(GLenum target, GLuint index, GLuint * param);
typedef void (__stdcall *PFNGLGETPROGRAMIVPROC)(GLuint program, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETPROGRAMIVARBPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETPROGRAMIVNVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETQUERYBUFFEROBJECTI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall *PFNGLGETQUERYBUFFEROBJECTIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall *PFNGLGETQUERYBUFFEROBJECTUI64VPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall *PFNGLGETQUERYBUFFEROBJECTUIVPROC)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall *PFNGLGETQUERYINDEXEDIVPROC)(GLenum target, GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTI64VPROC)(GLuint id, GLenum pname, GLint64 * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTI64VEXTPROC)(GLuint id, GLenum pname, GLint64 * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTIVPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTIVARBPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTUI64VPROC)(GLuint id, GLenum pname, GLuint64 * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTUI64VEXTPROC)(GLuint id, GLenum pname, GLuint64 * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTUIVPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETQUERYOBJECTUIVARBPROC)(GLuint id, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETQUERYIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETQUERYIVARBPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETRENDERBUFFERPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETSEMAPHOREPARAMETERIVNVPROC)(GLuint semaphore, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC)(GLuint semaphore, GLenum pname, GLuint64 * params);
typedef void (__stdcall *PFNGLGETSEPARABLEFILTEREXTPROC)(GLenum target, GLenum format, GLenum type, void * row, void * column, void * span);
typedef void (__stdcall *PFNGLGETSHADERINFOLOGPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog);
typedef void (__stdcall *PFNGLGETSHADERPRECISIONFORMATPROC)(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision);
typedef void (__stdcall *PFNGLGETSHADERSOURCEPROC)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source);
typedef void (__stdcall *PFNGLGETSHADERSOURCEARBPROC)(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source);
typedef void (__stdcall *PFNGLGETSHADERIVPROC)(GLuint shader, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETSHADINGRATEIMAGEPALETTENVPROC)(GLuint viewport, GLuint entry, GLenum * rate);
typedef void (__stdcall *PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC)(GLenum rate, GLuint samples, GLuint index, GLint * location);
typedef void (__stdcall *PFNGLGETSHARPENTEXFUNCSGISPROC)(GLenum target, GLfloat * points);
typedef GLushort (__stdcall *PFNGLGETSTAGEINDEXNVPROC)(GLenum shadertype);
typedef const GLubyte * (__stdcall *PFNGLGETSTRINGPROC)(GLenum name);
typedef const GLubyte * (__stdcall *PFNGLGETSTRINGIPROC)(GLenum name, GLuint index);
typedef GLuint (__stdcall *PFNGLGETSUBROUTINEINDEXPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef GLint (__stdcall *PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)(GLuint program, GLenum shadertype, const GLchar * name);
typedef void (__stdcall *PFNGLGETSYNCIVPROC)(GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values);
typedef void (__stdcall *PFNGLGETTEXBUMPPARAMETERFVATIPROC)(GLenum pname, GLfloat * param);
typedef void (__stdcall *PFNGLGETTEXBUMPPARAMETERIVATIPROC)(GLenum pname, GLint * param);
typedef void (__stdcall *PFNGLGETTEXENVXVOESPROC)(GLenum target, GLenum pname, GLfixed * params);
typedef void (__stdcall *PFNGLGETTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLfloat * weights);
typedef void (__stdcall *PFNGLGETTEXGENXVOESPROC)(GLenum coord, GLenum pname, GLfixed * params);
typedef void (__stdcall *PFNGLGETTEXIMAGEPROC)(GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (__stdcall *PFNGLGETTEXLEVELPARAMETERFVPROC)(GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETTEXLEVELPARAMETERIVPROC)(GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXLEVELPARAMETERXVOESPROC)(GLenum target, GLint level, GLenum pname, GLfixed * params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC)(GLenum target, GLenum pname, void ** params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERFVPROC)(GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERIVPROC)(GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXPARAMETERXVOESPROC)(GLenum target, GLenum pname, GLfixed * params);
typedef GLuint64 (__stdcall *PFNGLGETTEXTUREHANDLEARBPROC)(GLuint texture);
typedef GLuint64 (__stdcall *PFNGLGETTEXTUREHANDLENVPROC)(GLuint texture);
typedef void (__stdcall *PFNGLGETTEXTUREIMAGEPROC)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (__stdcall *PFNGLGETTEXTUREIMAGEEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void * pixels);
typedef void (__stdcall *PFNGLGETTEXTURELEVELPARAMETERFVPROC)(GLuint texture, GLint level, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETTEXTURELEVELPARAMETERIVPROC)(GLuint texture, GLint level, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint * params);
typedef GLuint64 (__stdcall *PFNGLGETTEXTURESAMPLERHANDLEARBPROC)(GLuint texture, GLuint sampler);
typedef GLuint64 (__stdcall *PFNGLGETTEXTURESAMPLERHANDLENVPROC)(GLuint texture, GLuint sampler);
typedef void (__stdcall *PFNGLGETTEXTURESUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels);
typedef void (__stdcall *PFNGLGETTRACKMATRIXIVNVPROC)(GLenum target, GLuint address, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (__stdcall *PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (__stdcall *PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC)(GLuint program, GLuint index, GLint * location);
typedef void (__stdcall *PFNGLGETTRANSFORMFEEDBACKI64_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint64 * param);
typedef void (__stdcall *PFNGLGETTRANSFORMFEEDBACKI_VPROC)(GLuint xfb, GLenum pname, GLuint index, GLint * param);
typedef void (__stdcall *PFNGLGETTRANSFORMFEEDBACKIVPROC)(GLuint xfb, GLenum pname, GLint * param);
typedef GLuint (__stdcall *PFNGLGETUNIFORMBLOCKINDEXPROC)(GLuint program, const GLchar * uniformBlockName);
typedef GLint (__stdcall *PFNGLGETUNIFORMBUFFERSIZEEXTPROC)(GLuint program, GLint location);
typedef void (__stdcall *PFNGLGETUNIFORMINDICESPROC)(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices);
typedef GLint (__stdcall *PFNGLGETUNIFORMLOCATIONPROC)(GLuint program, const GLchar * name);
typedef GLint (__stdcall *PFNGLGETUNIFORMLOCATIONARBPROC)(GLhandleARB programObj, const GLcharARB * name);
typedef GLintptr (__stdcall *PFNGLGETUNIFORMOFFSETEXTPROC)(GLuint program, GLint location);
typedef void (__stdcall *PFNGLGETUNIFORMSUBROUTINEUIVPROC)(GLenum shadertype, GLint location, GLuint * params);
typedef void (__stdcall *PFNGLGETUNIFORMDVPROC)(GLuint program, GLint location, GLdouble * params);
typedef void (__stdcall *PFNGLGETUNIFORMFVPROC)(GLuint program, GLint location, GLfloat * params);
typedef void (__stdcall *PFNGLGETUNIFORMFVARBPROC)(GLhandleARB programObj, GLint location, GLfloat * params);
typedef void (__stdcall *PFNGLGETUNIFORMI64VARBPROC)(GLuint program, GLint location, GLint64 * params);
typedef void (__stdcall *PFNGLGETUNIFORMI64VNVPROC)(GLuint program, GLint location, GLint64EXT * params);
typedef void (__stdcall *PFNGLGETUNIFORMIVPROC)(GLuint program, GLint location, GLint * params);
typedef void (__stdcall *PFNGLGETUNIFORMIVARBPROC)(GLhandleARB programObj, GLint location, GLint * params);
typedef void (__stdcall *PFNGLGETUNIFORMUI64VARBPROC)(GLuint program, GLint location, GLuint64 * params);
typedef void (__stdcall *PFNGLGETUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLuint64EXT * params);
typedef void (__stdcall *PFNGLGETUNIFORMUIVPROC)(GLuint program, GLint location, GLuint * params);
typedef void (__stdcall *PFNGLGETUNIFORMUIVEXTPROC)(GLuint program, GLint location, GLuint * params);
typedef void (__stdcall *PFNGLGETUNSIGNEDBYTEI_VEXTPROC)(GLenum target, GLuint index, GLubyte * data);
typedef void (__stdcall *PFNGLGETUNSIGNEDBYTEVEXTPROC)(GLenum pname, GLubyte * data);
typedef void (__stdcall *PFNGLGETVARIANTARRAYOBJECTFVATIPROC)(GLuint id, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETVARIANTARRAYOBJECTIVATIPROC)(GLuint id, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVARIANTBOOLEANVEXTPROC)(GLuint id, GLenum value, GLboolean * data);
typedef void (__stdcall *PFNGLGETVARIANTFLOATVEXTPROC)(GLuint id, GLenum value, GLfloat * data);
typedef void (__stdcall *PFNGLGETVARIANTINTEGERVEXTPROC)(GLuint id, GLenum value, GLint * data);
typedef void (__stdcall *PFNGLGETVARIANTPOINTERVEXTPROC)(GLuint id, GLenum value, void ** data);
typedef GLint (__stdcall *PFNGLGETVARYINGLOCATIONNVPROC)(GLuint program, const GLchar * name);
typedef void (__stdcall *PFNGLGETVERTEXARRAYINDEXED64IVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param);
typedef void (__stdcall *PFNGLGETVERTEXARRAYINDEXEDIVPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint * param);
typedef void (__stdcall *PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, GLint * param);
typedef void (__stdcall *PFNGLGETVERTEXARRAYINTEGERVEXTPROC)(GLuint vaobj, GLenum pname, GLint * param);
typedef void (__stdcall *PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC)(GLuint vaobj, GLuint index, GLenum pname, void ** param);
typedef void (__stdcall *PFNGLGETVERTEXARRAYPOINTERVEXTPROC)(GLuint vaobj, GLenum pname, void ** param);
typedef void (__stdcall *PFNGLGETVERTEXARRAYIVPROC)(GLuint vaobj, GLenum pname, GLint * param);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBIIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBIIVEXTPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBIUIVPROC)(GLuint index, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBIUIVEXTPROC)(GLuint index, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBLDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBLDVEXTPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBLI64VNVPROC)(GLuint index, GLenum pname, GLint64EXT * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBLUI64VARBPROC)(GLuint index, GLenum pname, GLuint64EXT * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBLUI64VNVPROC)(GLuint index, GLenum pname, GLuint64EXT * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBPOINTERVPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBPOINTERVARBPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBPOINTERVNVPROC)(GLuint index, GLenum pname, void ** pointer);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBDVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBDVARBPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBDVNVPROC)(GLuint index, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBFVPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBFVARBPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBFVNVPROC)(GLuint index, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBIVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBIVARBPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVERTEXATTRIBIVNVPROC)(GLuint index, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVIDEOCAPTURESTREAMDVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params);
typedef void (__stdcall *PFNGLGETVIDEOCAPTURESTREAMFVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params);
typedef void (__stdcall *PFNGLGETVIDEOCAPTURESTREAMIVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVIDEOCAPTUREIVNVPROC)(GLuint video_capture_slot, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVIDEOI64VNVPROC)(GLuint video_slot, GLenum pname, GLint64EXT * params);
typedef void (__stdcall *PFNGLGETVIDEOIVNVPROC)(GLuint video_slot, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLGETVIDEOUI64VNVPROC)(GLuint video_slot, GLenum pname, GLuint64EXT * params);
typedef void (__stdcall *PFNGLGETVIDEOUIVNVPROC)(GLuint video_slot, GLenum pname, GLuint * params);
typedef GLVULKANPROCNV (__stdcall *PFNGLGETVKPROCADDRNVPROC)(const GLchar * name);
typedef void (__stdcall *PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC)(GLenum target, GLint lod, GLsizei bufSize, void * img);
typedef void (__stdcall *PFNGLGETNTEXIMAGEARBPROC)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * img);
typedef void (__stdcall *PFNGLGETNUNIFORMDVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLdouble * params);
typedef void (__stdcall *PFNGLGETNUNIFORMFVPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);
typedef void (__stdcall *PFNGLGETNUNIFORMFVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLfloat * params);
typedef void (__stdcall *PFNGLGETNUNIFORMI64VARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLint64 * params);
typedef void (__stdcall *PFNGLGETNUNIFORMIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLint * params);
typedef void (__stdcall *PFNGLGETNUNIFORMIVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLint * params);
typedef void (__stdcall *PFNGLGETNUNIFORMUI64VARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint64 * params);
typedef void (__stdcall *PFNGLGETNUNIFORMUIVPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint * params);
typedef void (__stdcall *PFNGLGETNUNIFORMUIVARBPROC)(GLuint program, GLint location, GLsizei bufSize, GLuint * params);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORBSUNPROC)(GLbyte factor);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORDSUNPROC)(GLdouble factor);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORFSUNPROC)(GLfloat factor);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORISUNPROC)(GLint factor);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORSSUNPROC)(GLshort factor);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORUBSUNPROC)(GLubyte factor);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORUISUNPROC)(GLuint factor);
typedef void (__stdcall *PFNGLGLOBALALPHAFACTORUSSUNPROC)(GLushort factor);
typedef void (__stdcall *PFNGLHINTPROC)(GLenum target, GLenum mode);
typedef void (__stdcall *PFNGLHINTPGIPROC)(GLenum target, GLint mode);
typedef void (__stdcall *PFNGLHISTOGRAMEXTPROC)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall *PFNGLIGLOOINTERFACESGIXPROC)(GLenum pname, const void * params);
typedef void (__stdcall *PFNGLIMAGETRANSFORMPARAMETERFHPPROC)(GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLIMAGETRANSFORMPARAMETERFVHPPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLIMAGETRANSFORMPARAMETERIHPPROC)(GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLIMAGETRANSFORMPARAMETERIVHPPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLIMPORTMEMORYFDEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, GLint fd);
typedef void (__stdcall *PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, void * handle);
typedef void (__stdcall *PFNGLIMPORTMEMORYWIN32NAMEEXTPROC)(GLuint memory, GLuint64 size, GLenum handleType, const void * name);
typedef void (__stdcall *PFNGLIMPORTSEMAPHOREFDEXTPROC)(GLuint semaphore, GLenum handleType, GLint fd);
typedef void (__stdcall *PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC)(GLuint semaphore, GLenum handleType, void * handle);
typedef void (__stdcall *PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC)(GLuint semaphore, GLenum handleType, const void * name);
typedef GLsync (__stdcall *PFNGLIMPORTSYNCEXTPROC)(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
typedef void (__stdcall *PFNGLINDEXFORMATNVPROC)(GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLINDEXFUNCEXTPROC)(GLenum func, GLclampf ref);
typedef void (__stdcall *PFNGLINDEXMATERIALEXTPROC)(GLenum face, GLenum mode);
typedef void (__stdcall *PFNGLINDEXPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (__stdcall *PFNGLINDEXPOINTERLISTIBMPROC)(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLINDEXXOESPROC)(GLfixed component);
typedef void (__stdcall *PFNGLINDEXXVOESPROC)(const GLfixed * component);
typedef void (__stdcall *PFNGLINSERTCOMPONENTEXTPROC)(GLuint res, GLuint src, GLuint num);
typedef void (__stdcall *PFNGLINSERTEVENTMARKEREXTPROC)(GLsizei length, const GLchar * marker);
typedef void (__stdcall *PFNGLINSTRUMENTSBUFFERSGIXPROC)(GLsizei size, GLint * buffer);
typedef void (__stdcall *PFNGLINTERPOLATEPATHSNVPROC)(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef void (__stdcall *PFNGLINVALIDATEBUFFERDATAPROC)(GLuint buffer);
typedef void (__stdcall *PFNGLINVALIDATEBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall *PFNGLINVALIDATEFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments);
typedef void (__stdcall *PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments);
typedef void (__stdcall *PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLINVALIDATESUBFRAMEBUFFERPROC)(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLINVALIDATETEXIMAGEPROC)(GLuint texture, GLint level);
typedef void (__stdcall *PFNGLINVALIDATETEXSUBIMAGEPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
typedef GLboolean (__stdcall *PFNGLISASYNCMARKERSGIXPROC)(GLuint marker);
typedef GLboolean (__stdcall *PFNGLISBUFFERPROC)(GLuint buffer);
typedef GLboolean (__stdcall *PFNGLISBUFFERARBPROC)(GLuint buffer);
typedef GLboolean (__stdcall *PFNGLISBUFFERRESIDENTNVPROC)(GLenum target);
typedef GLboolean (__stdcall *PFNGLISCOMMANDLISTNVPROC)(GLuint list);
typedef GLboolean (__stdcall *PFNGLISENABLEDPROC)(GLenum cap);
typedef GLboolean (__stdcall *PFNGLISENABLEDINDEXEDEXTPROC)(GLenum target, GLuint index);
typedef GLboolean (__stdcall *PFNGLISENABLEDIPROC)(GLenum target, GLuint index);
typedef GLboolean (__stdcall *PFNGLISFENCEAPPLEPROC)(GLuint fence);
typedef GLboolean (__stdcall *PFNGLISFENCENVPROC)(GLuint fence);
typedef GLboolean (__stdcall *PFNGLISFRAMEBUFFERPROC)(GLuint framebuffer);
typedef GLboolean (__stdcall *PFNGLISFRAMEBUFFEREXTPROC)(GLuint framebuffer);
typedef GLboolean (__stdcall *PFNGLISIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle);
typedef GLboolean (__stdcall *PFNGLISIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle);
typedef GLboolean (__stdcall *PFNGLISMEMORYOBJECTEXTPROC)(GLuint memoryObject);
typedef GLboolean (__stdcall *PFNGLISNAMEAMDPROC)(GLenum identifier, GLuint name);
typedef GLboolean (__stdcall *PFNGLISNAMEDBUFFERRESIDENTNVPROC)(GLuint buffer);
typedef GLboolean (__stdcall *PFNGLISNAMEDSTRINGARBPROC)(GLint namelen, const GLchar * name);
typedef GLboolean (__stdcall *PFNGLISOBJECTBUFFERATIPROC)(GLuint buffer);
typedef GLboolean (__stdcall *PFNGLISOCCLUSIONQUERYNVPROC)(GLuint id);
typedef GLboolean (__stdcall *PFNGLISPATHNVPROC)(GLuint path);
typedef GLboolean (__stdcall *PFNGLISPOINTINFILLPATHNVPROC)(GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean (__stdcall *PFNGLISPOINTINSTROKEPATHNVPROC)(GLuint path, GLfloat x, GLfloat y);
typedef GLboolean (__stdcall *PFNGLISPROGRAMPROC)(GLuint program);
typedef GLboolean (__stdcall *PFNGLISPROGRAMARBPROC)(GLuint program);
typedef GLboolean (__stdcall *PFNGLISPROGRAMNVPROC)(GLuint id);
typedef GLboolean (__stdcall *PFNGLISPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef GLboolean (__stdcall *PFNGLISQUERYPROC)(GLuint id);
typedef GLboolean (__stdcall *PFNGLISQUERYARBPROC)(GLuint id);
typedef GLboolean (__stdcall *PFNGLISRENDERBUFFERPROC)(GLuint renderbuffer);
typedef GLboolean (__stdcall *PFNGLISRENDERBUFFEREXTPROC)(GLuint renderbuffer);
typedef GLboolean (__stdcall *PFNGLISSAMPLERPROC)(GLuint sampler);
typedef GLboolean (__stdcall *PFNGLISSEMAPHOREEXTPROC)(GLuint semaphore);
typedef GLboolean (__stdcall *PFNGLISSHADERPROC)(GLuint shader);
typedef GLboolean (__stdcall *PFNGLISSTATENVPROC)(GLuint state);
typedef GLboolean (__stdcall *PFNGLISSYNCPROC)(GLsync sync);
typedef GLboolean (__stdcall *PFNGLISTEXTUREPROC)(GLuint texture);
typedef GLboolean (__stdcall *PFNGLISTEXTUREEXTPROC)(GLuint texture);
typedef GLboolean (__stdcall *PFNGLISTEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
typedef GLboolean (__stdcall *PFNGLISTEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
typedef GLboolean (__stdcall *PFNGLISTRANSFORMFEEDBACKPROC)(GLuint id);
typedef GLboolean (__stdcall *PFNGLISTRANSFORMFEEDBACKNVPROC)(GLuint id);
typedef GLboolean (__stdcall *PFNGLISVARIANTENABLEDEXTPROC)(GLuint id, GLenum cap);
typedef GLboolean (__stdcall *PFNGLISVERTEXARRAYPROC)(GLuint array);
typedef GLboolean (__stdcall *PFNGLISVERTEXARRAYAPPLEPROC)(GLuint array);
typedef GLboolean (__stdcall *PFNGLISVERTEXATTRIBENABLEDAPPLEPROC)(GLuint index, GLenum pname);
typedef void (__stdcall *PFNGLLGPUCOPYIMAGESUBDATANVXPROC)(GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall *PFNGLLGPUINTERLOCKNVXPROC)(void);
typedef void (__stdcall *PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC)(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (__stdcall *PFNGLLABELOBJECTEXTPROC)(GLenum type, GLuint object, GLsizei length, const GLchar * label);
typedef void (__stdcall *PFNGLLIGHTENVISGIXPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLLIGHTMODELXOESPROC)(GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLLIGHTMODELXVOESPROC)(GLenum pname, const GLfixed * param);
typedef void (__stdcall *PFNGLLIGHTXOESPROC)(GLenum light, GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLLIGHTXVOESPROC)(GLenum light, GLenum pname, const GLfixed * params);
typedef void (__stdcall *PFNGLLINEWIDTHPROC)(GLfloat width);
typedef void (__stdcall *PFNGLLINEWIDTHXOESPROC)(GLfixed width);
typedef void (__stdcall *PFNGLLINKPROGRAMPROC)(GLuint program);
typedef void (__stdcall *PFNGLLINKPROGRAMARBPROC)(GLhandleARB programObj);
typedef void (__stdcall *PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC)(GLuint list, GLuint segment, const void ** indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count);
typedef void (__stdcall *PFNGLLISTPARAMETERFSGIXPROC)(GLuint list, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLLISTPARAMETERFVSGIXPROC)(GLuint list, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLLISTPARAMETERISGIXPROC)(GLuint list, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLLISTPARAMETERIVSGIXPROC)(GLuint list, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC)(GLbitfield mask);
typedef void (__stdcall *PFNGLLOADMATRIXXOESPROC)(const GLfixed * m);
typedef void (__stdcall *PFNGLLOADPROGRAMNVPROC)(GLenum target, GLuint id, GLsizei len, const GLubyte * program);
typedef void (__stdcall *PFNGLLOADTRANSPOSEMATRIXDARBPROC)(const GLdouble * m);
typedef void (__stdcall *PFNGLLOADTRANSPOSEMATRIXFARBPROC)(const GLfloat * m);
typedef void (__stdcall *PFNGLLOADTRANSPOSEMATRIXXOESPROC)(const GLfixed * m);
typedef void (__stdcall *PFNGLLOCKARRAYSEXTPROC)(GLint first, GLsizei count);
typedef void (__stdcall *PFNGLLOGICOPPROC)(GLenum opcode);
typedef void (__stdcall *PFNGLMAKEBUFFERNONRESIDENTNVPROC)(GLenum target);
typedef void (__stdcall *PFNGLMAKEBUFFERRESIDENTNVPROC)(GLenum target, GLenum access);
typedef void (__stdcall *PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC)(GLuint64 handle);
typedef void (__stdcall *PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC)(GLuint64 handle);
typedef void (__stdcall *PFNGLMAKEIMAGEHANDLERESIDENTARBPROC)(GLuint64 handle, GLenum access);
typedef void (__stdcall *PFNGLMAKEIMAGEHANDLERESIDENTNVPROC)(GLuint64 handle, GLenum access);
typedef void (__stdcall *PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC)(GLuint buffer);
typedef void (__stdcall *PFNGLMAKENAMEDBUFFERRESIDENTNVPROC)(GLuint buffer, GLenum access);
typedef void (__stdcall *PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC)(GLuint64 handle);
typedef void (__stdcall *PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC)(GLuint64 handle);
typedef void (__stdcall *PFNGLMAKETEXTUREHANDLERESIDENTARBPROC)(GLuint64 handle);
typedef void (__stdcall *PFNGLMAKETEXTUREHANDLERESIDENTNVPROC)(GLuint64 handle);
typedef void (__stdcall *PFNGLMAP1XOESPROC)(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points);
typedef void (__stdcall *PFNGLMAP2XOESPROC)(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points);
typedef void * (__stdcall *PFNGLMAPBUFFERPROC)(GLenum target, GLenum access);
typedef void * (__stdcall *PFNGLMAPBUFFERARBPROC)(GLenum target, GLenum access);
typedef void * (__stdcall *PFNGLMAPBUFFERRANGEPROC)(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall *PFNGLMAPCONTROLPOINTSNVPROC)(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void * points);
typedef void (__stdcall *PFNGLMAPGRID1XOESPROC)(GLint n, GLfixed u1, GLfixed u2);
typedef void (__stdcall *PFNGLMAPGRID2XOESPROC)(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2);
typedef void * (__stdcall *PFNGLMAPNAMEDBUFFERPROC)(GLuint buffer, GLenum access);
typedef void * (__stdcall *PFNGLMAPNAMEDBUFFEREXTPROC)(GLuint buffer, GLenum access);
typedef void * (__stdcall *PFNGLMAPNAMEDBUFFERRANGEPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void * (__stdcall *PFNGLMAPNAMEDBUFFERRANGEEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void * (__stdcall *PFNGLMAPOBJECTBUFFERATIPROC)(GLuint buffer);
typedef void (__stdcall *PFNGLMAPPARAMETERFVNVPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLMAPPARAMETERIVNVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void * (__stdcall *PFNGLMAPTEXTURE2DINTELPROC)(GLuint texture, GLint level, GLbitfield access, GLint * stride, GLenum * layout);
typedef void (__stdcall *PFNGLMAPVERTEXATTRIB1DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points);
typedef void (__stdcall *PFNGLMAPVERTEXATTRIB1FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points);
typedef void (__stdcall *PFNGLMAPVERTEXATTRIB2DAPPLEPROC)(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points);
typedef void (__stdcall *PFNGLMAPVERTEXATTRIB2FAPPLEPROC)(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points);
typedef void (__stdcall *PFNGLMATERIALXOESPROC)(GLenum face, GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLMATERIALXVOESPROC)(GLenum face, GLenum pname, const GLfixed * param);
typedef void (__stdcall *PFNGLMATRIXFRUSTUMEXTPROC)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef void (__stdcall *PFNGLMATRIXINDEXPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLMATRIXINDEXUBVARBPROC)(GLint size, const GLubyte * indices);
typedef void (__stdcall *PFNGLMATRIXINDEXUIVARBPROC)(GLint size, const GLuint * indices);
typedef void (__stdcall *PFNGLMATRIXINDEXUSVARBPROC)(GLint size, const GLushort * indices);
typedef void (__stdcall *PFNGLMATRIXLOAD3X2FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXLOAD3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXLOADIDENTITYEXTPROC)(GLenum mode);
typedef void (__stdcall *PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXLOADTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (__stdcall *PFNGLMATRIXLOADTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXLOADDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (__stdcall *PFNGLMATRIXLOADFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXMULT3X2FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXMULT3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC)(GLenum matrixMode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXMULTTRANSPOSEDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (__stdcall *PFNGLMATRIXMULTTRANSPOSEFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXMULTDEXTPROC)(GLenum mode, const GLdouble * m);
typedef void (__stdcall *PFNGLMATRIXMULTFEXTPROC)(GLenum mode, const GLfloat * m);
typedef void (__stdcall *PFNGLMATRIXORTHOEXTPROC)(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef void (__stdcall *PFNGLMATRIXPOPEXTPROC)(GLenum mode);
typedef void (__stdcall *PFNGLMATRIXPUSHEXTPROC)(GLenum mode);
typedef void (__stdcall *PFNGLMATRIXROTATEDEXTPROC)(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLMATRIXROTATEFEXTPROC)(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLMATRIXSCALEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLMATRIXSCALEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLMATRIXTRANSLATEDEXTPROC)(GLenum mode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLMATRIXTRANSLATEFEXTPROC)(GLenum mode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLMAXSHADERCOMPILERTHREADSARBPROC)(GLuint count);
typedef void (__stdcall *PFNGLMAXSHADERCOMPILERTHREADSKHRPROC)(GLuint count);
typedef void (__stdcall *PFNGLMEMORYBARRIERPROC)(GLbitfield barriers);
typedef void (__stdcall *PFNGLMEMORYBARRIERBYREGIONPROC)(GLbitfield barriers);
typedef void (__stdcall *PFNGLMEMORYBARRIEREXTPROC)(GLbitfield barriers);
typedef void (__stdcall *PFNGLMEMORYOBJECTPARAMETERIVEXTPROC)(GLuint memoryObject, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLMINSAMPLESHADINGARBPROC)(GLfloat value);
typedef void (__stdcall *PFNGLMINMAXEXTPROC)(GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall *PFNGLMULTMATRIXXOESPROC)(const GLfixed * m);
typedef void (__stdcall *PFNGLMULTTRANSPOSEMATRIXDARBPROC)(const GLdouble * m);
typedef void (__stdcall *PFNGLMULTTRANSPOSEMATRIXFARBPROC)(const GLfloat * m);
typedef void (__stdcall *PFNGLMULTTRANSPOSEMATRIXXOESPROC)(const GLfixed * m);
typedef void (__stdcall *PFNGLMULTIDRAWARRAYSPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
typedef void (__stdcall *PFNGLMULTIDRAWARRAYSEXTPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);
typedef void (__stdcall *PFNGLMULTIDRAWARRAYSINDIRECTPROC)(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC)(GLenum mode, const void * indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC)(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall *PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC)(GLenum mode, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall *PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC)(GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC)(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSEXTPROC)(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSINDIRECTPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC)(GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall *PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC)(GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC)(GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC)(GLintptr indirect, GLsizei drawcount, GLsizei stride);
typedef void (__stdcall *PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC)(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount);
typedef void (__stdcall *PFNGLMULTIMODEDRAWARRAYSIBMPROC)(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride);
typedef void (__stdcall *PFNGLMULTIMODEDRAWELEMENTSIBMPROC)(const GLenum * mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount, GLint modestride);
typedef void (__stdcall *PFNGLMULTITEXBUFFEREXTPROC)(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall *PFNGLMULTITEXCOORD1BOESPROC)(GLenum texture, GLbyte s);
typedef void (__stdcall *PFNGLMULTITEXCOORD1BVOESPROC)(GLenum texture, const GLbyte * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORD1DARBPROC)(GLenum target, GLdouble s);
typedef void (__stdcall *PFNGLMULTITEXCOORD1DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD1FARBPROC)(GLenum target, GLfloat s);
typedef void (__stdcall *PFNGLMULTITEXCOORD1FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD1HNVPROC)(GLenum target, GLhalfNV s);
typedef void (__stdcall *PFNGLMULTITEXCOORD1HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD1IARBPROC)(GLenum target, GLint s);
typedef void (__stdcall *PFNGLMULTITEXCOORD1IVARBPROC)(GLenum target, const GLint * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD1SARBPROC)(GLenum target, GLshort s);
typedef void (__stdcall *PFNGLMULTITEXCOORD1SVARBPROC)(GLenum target, const GLshort * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD1XOESPROC)(GLenum texture, GLfixed s);
typedef void (__stdcall *PFNGLMULTITEXCOORD1XVOESPROC)(GLenum texture, const GLfixed * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORD2BOESPROC)(GLenum texture, GLbyte s, GLbyte t);
typedef void (__stdcall *PFNGLMULTITEXCOORD2BVOESPROC)(GLenum texture, const GLbyte * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORD2DARBPROC)(GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall *PFNGLMULTITEXCOORD2DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD2FARBPROC)(GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall *PFNGLMULTITEXCOORD2FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD2HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t);
typedef void (__stdcall *PFNGLMULTITEXCOORD2HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD2IARBPROC)(GLenum target, GLint s, GLint t);
typedef void (__stdcall *PFNGLMULTITEXCOORD2IVARBPROC)(GLenum target, const GLint * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD2SARBPROC)(GLenum target, GLshort s, GLshort t);
typedef void (__stdcall *PFNGLMULTITEXCOORD2SVARBPROC)(GLenum target, const GLshort * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD2XOESPROC)(GLenum texture, GLfixed s, GLfixed t);
typedef void (__stdcall *PFNGLMULTITEXCOORD2XVOESPROC)(GLenum texture, const GLfixed * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORD3BOESPROC)(GLenum texture, GLbyte s, GLbyte t, GLbyte r);
typedef void (__stdcall *PFNGLMULTITEXCOORD3BVOESPROC)(GLenum texture, const GLbyte * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORD3DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall *PFNGLMULTITEXCOORD3DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD3FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall *PFNGLMULTITEXCOORD3FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD3HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void (__stdcall *PFNGLMULTITEXCOORD3HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD3IARBPROC)(GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall *PFNGLMULTITEXCOORD3IVARBPROC)(GLenum target, const GLint * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD3SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall *PFNGLMULTITEXCOORD3SVARBPROC)(GLenum target, const GLshort * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD3XOESPROC)(GLenum texture, GLfixed s, GLfixed t, GLfixed r);
typedef void (__stdcall *PFNGLMULTITEXCOORD3XVOESPROC)(GLenum texture, const GLfixed * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORD4BOESPROC)(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q);
typedef void (__stdcall *PFNGLMULTITEXCOORD4BVOESPROC)(GLenum texture, const GLbyte * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORD4DARBPROC)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall *PFNGLMULTITEXCOORD4DVARBPROC)(GLenum target, const GLdouble * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD4FARBPROC)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall *PFNGLMULTITEXCOORD4FVARBPROC)(GLenum target, const GLfloat * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD4HNVPROC)(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void (__stdcall *PFNGLMULTITEXCOORD4HVNVPROC)(GLenum target, const GLhalfNV * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD4IARBPROC)(GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall *PFNGLMULTITEXCOORD4IVARBPROC)(GLenum target, const GLint * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD4SARBPROC)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall *PFNGLMULTITEXCOORD4SVARBPROC)(GLenum target, const GLshort * v);
typedef void (__stdcall *PFNGLMULTITEXCOORD4XOESPROC)(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void (__stdcall *PFNGLMULTITEXCOORD4XVOESPROC)(GLenum texture, const GLfixed * coords);
typedef void (__stdcall *PFNGLMULTITEXCOORDPOINTEREXTPROC)(GLenum texunit, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLMULTITEXENVFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLMULTITEXENVFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLMULTITEXENVIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLMULTITEXENVIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLMULTITEXGENDEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void (__stdcall *PFNGLMULTITEXGENDVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params);
typedef void (__stdcall *PFNGLMULTITEXGENFEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLMULTITEXGENFVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLMULTITEXGENIEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLMULTITEXGENIVEXTPROC)(GLenum texunit, GLenum coord, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLMULTITEXIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLMULTITEXIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLMULTITEXIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLMULTITEXPARAMETERIIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLMULTITEXPARAMETERIUIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLuint * params);
typedef void (__stdcall *PFNGLMULTITEXPARAMETERFEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLMULTITEXPARAMETERFVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLMULTITEXPARAMETERIEXTPROC)(GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLMULTITEXPARAMETERIVEXTPROC)(GLenum texunit, GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLMULTITEXRENDERBUFFEREXTPROC)(GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void (__stdcall *PFNGLMULTITEXSUBIMAGE1DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLMULTITEXSUBIMAGE2DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLMULTITEXSUBIMAGE3DEXTPROC)(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLMULTICASTBARRIERNVPROC)(void);
typedef void (__stdcall *PFNGLMULTICASTBLITFRAMEBUFFERNVPROC)(GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (__stdcall *PFNGLMULTICASTBUFFERSUBDATANVPROC)(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (__stdcall *PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC)(GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall *PFNGLMULTICASTCOPYIMAGESUBDATANVPROC)(GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (__stdcall *PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLint64 * params);
typedef void (__stdcall *PFNGLMULTICASTGETQUERYOBJECTIVNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLint * params);
typedef void (__stdcall *PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLuint64 * params);
typedef void (__stdcall *PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC)(GLuint gpu, GLuint id, GLenum pname, GLuint * params);
typedef void (__stdcall *PFNGLMULTICASTSCISSORARRAYVNVXPROC)(GLuint gpu, GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall *PFNGLMULTICASTVIEWPORTARRAYVNVXPROC)(GLuint gpu, GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC)(GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);
typedef void (__stdcall *PFNGLMULTICASTWAITSYNCNVPROC)(GLuint signalGpu, GLbitfield waitGpuMask);
typedef void (__stdcall *PFNGLNAMEDBUFFERATTACHMEMORYNVPROC)(GLuint buffer, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLNAMEDBUFFERDATAPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);
typedef void (__stdcall *PFNGLNAMEDBUFFERDATAEXTPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage);
typedef void (__stdcall *PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
typedef void (__stdcall *PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit);
typedef void (__stdcall *PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit);
typedef void (__stdcall *PFNGLNAMEDBUFFERSTORAGEPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (__stdcall *PFNGLNAMEDBUFFERSTORAGEEXTPROC)(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags);
typedef void (__stdcall *PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void (__stdcall *PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC)(GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLNAMEDBUFFERSUBDATAPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (__stdcall *PFNGLNAMEDBUFFERSUBDATAEXTPROC)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data);
typedef void (__stdcall *PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)(GLuint framebuffer, GLenum buf);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)(GLuint framebuffer, GLsizei n, const GLenum * bufs);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)(GLuint framebuffer, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC)(GLuint framebuffer, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)(GLuint framebuffer, GLenum src);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC)(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC)(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC)(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat * values);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC)(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall *PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC)(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLdouble * params);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC)(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLfloat * params);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC)(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLint * params);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC)(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, const GLuint * params);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params);
typedef void (__stdcall *PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC)(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params);
typedef void (__stdcall *PFNGLNAMEDPROGRAMSTRINGEXTPROC)(GLuint program, GLenum target, GLenum format, GLsizei len, const void * string);
typedef void (__stdcall *PFNGLNAMEDRENDERBUFFERSTORAGEPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC)(GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC)(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLNAMEDSTRINGARBPROC)(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string);
typedef GLuint (__stdcall *PFNGLNEWOBJECTBUFFERATIPROC)(GLsizei size, const void * pointer, GLenum usage);
typedef void (__stdcall *PFNGLNORMAL3FVERTEX3FSUNPROC)(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLNORMAL3FVERTEX3FVSUNPROC)(const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLNORMAL3HNVPROC)(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
typedef void (__stdcall *PFNGLNORMAL3HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLNORMAL3XOESPROC)(GLfixed nx, GLfixed ny, GLfixed nz);
typedef void (__stdcall *PFNGLNORMAL3XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLNORMALFORMATNVPROC)(GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLNORMALPOINTEREXTPROC)(GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (__stdcall *PFNGLNORMALPOINTERLISTIBMPROC)(GLenum type, GLint stride, const void ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLNORMALPOINTERVINTELPROC)(GLenum type, const void ** pointer);
typedef void (__stdcall *PFNGLNORMALSTREAM3BATIPROC)(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
typedef void (__stdcall *PFNGLNORMALSTREAM3BVATIPROC)(GLenum stream, const GLbyte * coords);
typedef void (__stdcall *PFNGLNORMALSTREAM3DATIPROC)(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
typedef void (__stdcall *PFNGLNORMALSTREAM3DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (__stdcall *PFNGLNORMALSTREAM3FATIPROC)(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
typedef void (__stdcall *PFNGLNORMALSTREAM3FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (__stdcall *PFNGLNORMALSTREAM3IATIPROC)(GLenum stream, GLint nx, GLint ny, GLint nz);
typedef void (__stdcall *PFNGLNORMALSTREAM3IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (__stdcall *PFNGLNORMALSTREAM3SATIPROC)(GLenum stream, GLshort nx, GLshort ny, GLshort nz);
typedef void (__stdcall *PFNGLNORMALSTREAM3SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (__stdcall *PFNGLOBJECTLABELPROC)(GLenum identifier, GLuint name, GLsizei length, const GLchar * label);
typedef void (__stdcall *PFNGLOBJECTPTRLABELPROC)(const void * ptr, GLsizei length, const GLchar * label);
typedef GLenum (__stdcall *PFNGLOBJECTPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
typedef GLenum (__stdcall *PFNGLOBJECTUNPURGEABLEAPPLEPROC)(GLenum objectType, GLuint name, GLenum option);
typedef void (__stdcall *PFNGLORTHOFOESPROC)(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void (__stdcall *PFNGLORTHOXOESPROC)(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f);
typedef void (__stdcall *PFNGLPNTRIANGLESFATIPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPNTRIANGLESIATIPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLPASSTEXCOORDATIPROC)(GLuint dst, GLuint coord, GLenum swizzle);
typedef void (__stdcall *PFNGLPASSTHROUGHXOESPROC)(GLfixed token);
typedef void (__stdcall *PFNGLPATCHPARAMETERFVPROC)(GLenum pname, const GLfloat * values);
typedef void (__stdcall *PFNGLPATCHPARAMETERIPROC)(GLenum pname, GLint value);
typedef void (__stdcall *PFNGLPATHCOMMANDSNVPROC)(GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (__stdcall *PFNGLPATHCOORDSNVPROC)(GLuint path, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (__stdcall *PFNGLPATHCOVERDEPTHFUNCNVPROC)(GLenum func);
typedef void (__stdcall *PFNGLPATHDASHARRAYNVPROC)(GLuint path, GLsizei dashCount, const GLfloat * dashArray);
typedef GLenum (__stdcall *PFNGLPATHGLYPHINDEXARRAYNVPROC)(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (__stdcall *PFNGLPATHGLYPHINDEXRANGENVPROC)(GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint * baseAndCount);
typedef void (__stdcall *PFNGLPATHGLYPHRANGENVPROC)(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall *PFNGLPATHGLYPHSNVPROC)(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (__stdcall *PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC)(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall *PFNGLPATHPARAMETERFNVPROC)(GLuint path, GLenum pname, GLfloat value);
typedef void (__stdcall *PFNGLPATHPARAMETERFVNVPROC)(GLuint path, GLenum pname, const GLfloat * value);
typedef void (__stdcall *PFNGLPATHPARAMETERINVPROC)(GLuint path, GLenum pname, GLint value);
typedef void (__stdcall *PFNGLPATHPARAMETERIVNVPROC)(GLuint path, GLenum pname, const GLint * value);
typedef void (__stdcall *PFNGLPATHSTENCILDEPTHOFFSETNVPROC)(GLfloat factor, GLfloat units);
typedef void (__stdcall *PFNGLPATHSTENCILFUNCNVPROC)(GLenum func, GLint ref, GLuint mask);
typedef void (__stdcall *PFNGLPATHSTRINGNVPROC)(GLuint path, GLenum format, GLsizei length, const void * pathString);
typedef void (__stdcall *PFNGLPATHSUBCOMMANDSNVPROC)(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (__stdcall *PFNGLPATHSUBCOORDSNVPROC)(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void * coords);
typedef void (__stdcall *PFNGLPAUSETRANSFORMFEEDBACKPROC)(void);
typedef void (__stdcall *PFNGLPAUSETRANSFORMFEEDBACKNVPROC)(void);
typedef void (__stdcall *PFNGLPIXELDATARANGENVPROC)(GLenum target, GLsizei length, const void * pointer);
typedef void (__stdcall *PFNGLPIXELMAPXPROC)(GLenum map, GLint size, const GLfixed * values);
typedef void (__stdcall *PFNGLPIXELSTOREFPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPIXELSTOREIPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLPIXELSTOREXPROC)(GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLPIXELTEXGENPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPIXELTEXGENPARAMETERFVSGISPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLPIXELTEXGENPARAMETERISGISPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLPIXELTEXGENPARAMETERIVSGISPROC)(GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLPIXELTEXGENSGIXPROC)(GLenum mode);
typedef void (__stdcall *PFNGLPIXELTRANSFERXOESPROC)(GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLPIXELTRANSFORMPARAMETERFEXTPROC)(GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLPIXELTRANSFORMPARAMETERIEXTPROC)(GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLPIXELZOOMXOESPROC)(GLfixed xfactor, GLfixed yfactor);
typedef GLboolean (__stdcall *PFNGLPOINTALONGPATHNVPROC)(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY);
typedef void (__stdcall *PFNGLPOINTPARAMETERFPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPOINTPARAMETERFARBPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPOINTPARAMETERFEXTPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPOINTPARAMETERFSGISPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLPOINTPARAMETERFVPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLPOINTPARAMETERFVEXTPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLPOINTPARAMETERFVSGISPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLPOINTPARAMETERIPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLPOINTPARAMETERINVPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLPOINTPARAMETERIVPROC)(GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLPOINTPARAMETERIVNVPROC)(GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLPOINTPARAMETERXVOESPROC)(GLenum pname, const GLfixed * params);
typedef void (__stdcall *PFNGLPOINTSIZEPROC)(GLfloat size);
typedef void (__stdcall *PFNGLPOINTSIZEXOESPROC)(GLfixed size);
typedef GLint (__stdcall *PFNGLPOLLASYNCSGIXPROC)(GLuint * markerp);
typedef GLint (__stdcall *PFNGLPOLLINSTRUMENTSSGIXPROC)(GLint * marker_p);
typedef void (__stdcall *PFNGLPOLYGONMODEPROC)(GLenum face, GLenum mode);
typedef void (__stdcall *PFNGLPOLYGONOFFSETPROC)(GLfloat factor, GLfloat units);
typedef void (__stdcall *PFNGLPOLYGONOFFSETCLAMPPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
typedef void (__stdcall *PFNGLPOLYGONOFFSETCLAMPEXTPROC)(GLfloat factor, GLfloat units, GLfloat clamp);
typedef void (__stdcall *PFNGLPOLYGONOFFSETEXTPROC)(GLfloat factor, GLfloat bias);
typedef void (__stdcall *PFNGLPOLYGONOFFSETXOESPROC)(GLfixed factor, GLfixed units);
typedef void (__stdcall *PFNGLPOPDEBUGGROUPPROC)(void);
typedef void (__stdcall *PFNGLPOPGROUPMARKEREXTPROC)(void);
typedef void (__stdcall *PFNGLPRESENTFRAMEDUALFILLNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void (__stdcall *PFNGLPRESENTFRAMEKEYEDNVPROC)(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
typedef void (__stdcall *PFNGLPRIMITIVEBOUNDINGBOXARBPROC)(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
typedef void (__stdcall *PFNGLPRIMITIVERESTARTINDEXPROC)(GLuint index);
typedef void (__stdcall *PFNGLPRIMITIVERESTARTINDEXNVPROC)(GLuint index);
typedef void (__stdcall *PFNGLPRIMITIVERESTARTNVPROC)(void);
typedef void (__stdcall *PFNGLPRIORITIZETEXTURESEXTPROC)(GLsizei n, const GLuint * textures, const GLclampf * priorities);
typedef void (__stdcall *PFNGLPRIORITIZETEXTURESXOESPROC)(GLsizei n, const GLuint * textures, const GLfixed * priorities);
typedef void (__stdcall *PFNGLPROGRAMBINARYPROC)(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length);
typedef void (__stdcall *PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params);
typedef void (__stdcall *PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params);
typedef void (__stdcall *PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC)(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble * params);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat * params);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint * params);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint * params);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint * params);
typedef void (__stdcall *PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint * params);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETER4DARBPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETER4DVARBPROC)(GLenum target, GLuint index, const GLdouble * params);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETER4FARBPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)(GLenum target, GLuint index, const GLfloat * params);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETERI4INVPROC)(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC)(GLenum target, GLuint index, const GLint * params);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETERI4UINVPROC)(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC)(GLenum target, GLuint index, const GLuint * params);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLint * params);
typedef void (__stdcall *PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLuint * params);
typedef void (__stdcall *PFNGLPROGRAMNAMEDPARAMETER4DNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v);
typedef void (__stdcall *PFNGLPROGRAMNAMEDPARAMETER4FNVPROC)(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC)(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v);
typedef void (__stdcall *PFNGLPROGRAMPARAMETER4DNVPROC)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLPROGRAMPARAMETER4DVNVPROC)(GLenum target, GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLPROGRAMPARAMETER4FNVPROC)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLPROGRAMPARAMETER4FVNVPROC)(GLenum target, GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLPROGRAMPARAMETERIPROC)(GLuint program, GLenum pname, GLint value);
typedef void (__stdcall *PFNGLPROGRAMPARAMETERIARBPROC)(GLuint program, GLenum pname, GLint value);
typedef void (__stdcall *PFNGLPROGRAMPARAMETERIEXTPROC)(GLuint program, GLenum pname, GLint value);
typedef void (__stdcall *PFNGLPROGRAMPARAMETERS4DVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLdouble * v);
typedef void (__stdcall *PFNGLPROGRAMPARAMETERS4FVNVPROC)(GLenum target, GLuint index, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC)(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat * coeffs);
typedef void (__stdcall *PFNGLPROGRAMSTRINGARBPROC)(GLenum target, GLenum format, GLsizei len, const void * string);
typedef void (__stdcall *PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC)(GLenum target, GLsizei count, const GLuint * params);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1DPROC)(GLuint program, GLint location, GLdouble v0);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1DEXTPROC)(GLuint program, GLint location, GLdouble x);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1FPROC)(GLuint program, GLint location, GLfloat v0);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1FEXTPROC)(GLuint program, GLint location, GLfloat v0);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1IPROC)(GLuint program, GLint location, GLint v0);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1I64ARBPROC)(GLuint program, GLint location, GLint64 x);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1I64NVPROC)(GLuint program, GLint location, GLint64EXT x);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1IEXTPROC)(GLuint program, GLint location, GLint v0);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UIPROC)(GLuint program, GLint location, GLuint v0);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UI64ARBPROC)(GLuint program, GLint location, GLuint64 x);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UIEXTPROC)(GLuint program, GLint location, GLuint v0);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM1UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2IPROC)(GLuint program, GLint location, GLint v0, GLint v1);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM2UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM3UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4DPROC)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4DEXTPROC)(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4DVPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4DVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4FPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4FEXTPROC)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4FVPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4FVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4IPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4I64ARBPROC)(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4I64NVPROC)(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4I64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4I64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4IEXTPROC)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4IVPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4IVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UIPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UI64ARBPROC)(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UI64NVPROC)(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UIEXTPROC)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UIVPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORM4UIVEXTPROC)(GLuint program, GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC)(GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC)(GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * values);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64 * values);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMUI64NVPROC)(GLuint program, GLint location, GLuint64EXT value);
typedef void (__stdcall *PFNGLPROGRAMUNIFORMUI64VNVPROC)(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLPROGRAMVERTEXLIMITNVPROC)(GLenum target, GLint limit);
typedef void (__stdcall *PFNGLPROVOKINGVERTEXPROC)(GLenum mode);
typedef void (__stdcall *PFNGLPROVOKINGVERTEXEXTPROC)(GLenum mode);
typedef void (__stdcall *PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC)(GLbitfield mask);
typedef void (__stdcall *PFNGLPUSHDEBUGGROUPPROC)(GLenum source, GLuint id, GLsizei length, const GLchar * message);
typedef void (__stdcall *PFNGLPUSHGROUPMARKEREXTPROC)(GLsizei length, const GLchar * marker);
typedef void (__stdcall *PFNGLQUERYCOUNTERPROC)(GLuint id, GLenum target);
typedef GLbitfield (__stdcall *PFNGLQUERYMATRIXXOESPROC)(GLfixed * mantissa, GLint * exponent);
typedef void (__stdcall *PFNGLQUERYOBJECTPARAMETERUIAMDPROC)(GLenum target, GLuint id, GLenum pname, GLuint param);
typedef GLint (__stdcall *PFNGLQUERYRESOURCENVPROC)(GLenum queryType, GLint tagId, GLuint count, GLint * buffer);
typedef void (__stdcall *PFNGLQUERYRESOURCETAGNVPROC)(GLint tagId, const GLchar * tagString);
typedef void (__stdcall *PFNGLRASTERPOS2XOESPROC)(GLfixed x, GLfixed y);
typedef void (__stdcall *PFNGLRASTERPOS2XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLRASTERPOS3XOESPROC)(GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall *PFNGLRASTERPOS3XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLRASTERPOS4XOESPROC)(GLfixed x, GLfixed y, GLfixed z, GLfixed w);
typedef void (__stdcall *PFNGLRASTERPOS4XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLRASTERSAMPLESEXTPROC)(GLuint samples, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLREADBUFFERPROC)(GLenum src);
typedef void (__stdcall *PFNGLREADINSTRUMENTSSGIXPROC)(GLint marker);
typedef void (__stdcall *PFNGLREADPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels);
typedef void (__stdcall *PFNGLREADNPIXELSPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
typedef void (__stdcall *PFNGLREADNPIXELSARBPROC)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data);
typedef void (__stdcall *PFNGLRECTXOESPROC)(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2);
typedef void (__stdcall *PFNGLRECTXVOESPROC)(const GLfixed * v1, const GLfixed * v2);
typedef void (__stdcall *PFNGLREFERENCEPLANESGIXPROC)(const GLdouble * equation);
typedef GLboolean (__stdcall *PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC)(GLuint memory, GLuint64 key);
typedef void (__stdcall *PFNGLRELEASESHADERCOMPILERPROC)(void);
typedef void (__stdcall *PFNGLRENDERGPUMASKNVPROC)(GLbitfield mask);
typedef void (__stdcall *PFNGLRENDERBUFFERSTORAGEPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLRENDERBUFFERSTORAGEEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC)(GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLREPLACEMENTCODEPOINTERSUNPROC)(GLenum type, GLsizei stride, const void ** pointer);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUBSUNPROC)(GLubyte code);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUBVSUNPROC)(const GLubyte * code);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC)(const GLuint * rc, const GLfloat * c, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC)(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC)(const GLuint * rc, const GLubyte * c, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC)(const GLuint * rc, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUISUNPROC)(GLuint code);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC)(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC)(const GLuint * rc, const GLfloat * tc, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC)(GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC)(const GLuint * rc, const GLfloat * v);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUIVSUNPROC)(const GLuint * code);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUSSUNPROC)(GLushort code);
typedef void (__stdcall *PFNGLREPLACEMENTCODEUSVSUNPROC)(const GLushort * code);
typedef void (__stdcall *PFNGLREQUESTRESIDENTPROGRAMSNVPROC)(GLsizei n, const GLuint * programs);
typedef void (__stdcall *PFNGLRESETHISTOGRAMEXTPROC)(GLenum target);
typedef void (__stdcall *PFNGLRESETMEMORYOBJECTPARAMETERNVPROC)(GLuint memory, GLenum pname);
typedef void (__stdcall *PFNGLRESETMINMAXEXTPROC)(GLenum target);
typedef void (__stdcall *PFNGLRESIZEBUFFERSMESAPROC)(void);
typedef void (__stdcall *PFNGLRESOLVEDEPTHVALUESNVPROC)(void);
typedef void (__stdcall *PFNGLRESUMETRANSFORMFEEDBACKPROC)(void);
typedef void (__stdcall *PFNGLRESUMETRANSFORMFEEDBACKNVPROC)(void);
typedef void (__stdcall *PFNGLROTATEXOESPROC)(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall *PFNGLSAMPLECOVERAGEPROC)(GLfloat value, GLboolean invert);
typedef void (__stdcall *PFNGLSAMPLECOVERAGEARBPROC)(GLfloat value, GLboolean invert);
typedef void (__stdcall *PFNGLSAMPLEMAPATIPROC)(GLuint dst, GLuint interp, GLenum swizzle);
typedef void (__stdcall *PFNGLSAMPLEMASKEXTPROC)(GLclampf value, GLboolean invert);
typedef void (__stdcall *PFNGLSAMPLEMASKINDEXEDNVPROC)(GLuint index, GLbitfield mask);
typedef void (__stdcall *PFNGLSAMPLEMASKSGISPROC)(GLclampf value, GLboolean invert);
typedef void (__stdcall *PFNGLSAMPLEMASKIPROC)(GLuint maskNumber, GLbitfield mask);
typedef void (__stdcall *PFNGLSAMPLEPATTERNEXTPROC)(GLenum pattern);
typedef void (__stdcall *PFNGLSAMPLEPATTERNSGISPROC)(GLenum pattern);
typedef void (__stdcall *PFNGLSAMPLERPARAMETERIIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (__stdcall *PFNGLSAMPLERPARAMETERIUIVPROC)(GLuint sampler, GLenum pname, const GLuint * param);
typedef void (__stdcall *PFNGLSAMPLERPARAMETERFPROC)(GLuint sampler, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLSAMPLERPARAMETERFVPROC)(GLuint sampler, GLenum pname, const GLfloat * param);
typedef void (__stdcall *PFNGLSAMPLERPARAMETERIPROC)(GLuint sampler, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLSAMPLERPARAMETERIVPROC)(GLuint sampler, GLenum pname, const GLint * param);
typedef void (__stdcall *PFNGLSCALEXOESPROC)(GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall *PFNGLSCISSORPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLSCISSORARRAYVPROC)(GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall *PFNGLSCISSOREXCLUSIVEARRAYVNVPROC)(GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall *PFNGLSCISSOREXCLUSIVENVPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLSCISSORINDEXEDPROC)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLSCISSORINDEXEDVPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3BEXTPROC)(GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3BVEXTPROC)(const GLbyte * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3DEXTPROC)(GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3DVEXTPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3FEXTPROC)(GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3FVEXTPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3HNVPROC)(GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3IEXTPROC)(GLint red, GLint green, GLint blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3IVEXTPROC)(const GLint * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3SEXTPROC)(GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3SVEXTPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3UBEXTPROC)(GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3UBVEXTPROC)(const GLubyte * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3UIEXTPROC)(GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3UIVEXTPROC)(const GLuint * v);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3USEXTPROC)(GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall *PFNGLSECONDARYCOLOR3USVEXTPROC)(const GLushort * v);
typedef void (__stdcall *PFNGLSECONDARYCOLORFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLSECONDARYCOLORPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLSECONDARYCOLORPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLSELECTPERFMONITORCOUNTERSAMDPROC)(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList);
typedef void (__stdcall *PFNGLSEMAPHOREPARAMETERIVNVPROC)(GLuint semaphore, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLSEMAPHOREPARAMETERUI64VEXTPROC)(GLuint semaphore, GLenum pname, const GLuint64 * params);
typedef void (__stdcall *PFNGLSEPARABLEFILTER2DEXTPROC)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column);
typedef void (__stdcall *PFNGLSETFENCEAPPLEPROC)(GLuint fence);
typedef void (__stdcall *PFNGLSETFENCENVPROC)(GLuint fence, GLenum condition);
typedef void (__stdcall *PFNGLSETFRAGMENTSHADERCONSTANTATIPROC)(GLuint dst, const GLfloat * value);
typedef void (__stdcall *PFNGLSETINVARIANTEXTPROC)(GLuint id, GLenum type, const void * addr);
typedef void (__stdcall *PFNGLSETLOCALCONSTANTEXTPROC)(GLuint id, GLenum type, const void * addr);
typedef void (__stdcall *PFNGLSETMULTISAMPLEFVAMDPROC)(GLenum pname, GLuint index, const GLfloat * val);
typedef void (__stdcall *PFNGLSHADERBINARYPROC)(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length);
typedef void (__stdcall *PFNGLSHADEROP1EXTPROC)(GLenum op, GLuint res, GLuint arg1);
typedef void (__stdcall *PFNGLSHADEROP2EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void (__stdcall *PFNGLSHADEROP3EXTPROC)(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void (__stdcall *PFNGLSHADERSOURCEPROC)(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length);
typedef void (__stdcall *PFNGLSHADERSOURCEARBPROC)(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint * length);
typedef void (__stdcall *PFNGLSHADERSTORAGEBLOCKBINDINGPROC)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
typedef void (__stdcall *PFNGLSHADINGRATEIMAGEBARRIERNVPROC)(GLboolean synchronize);
typedef void (__stdcall *PFNGLSHADINGRATEIMAGEPALETTENVPROC)(GLuint viewport, GLuint first, GLsizei count, const GLenum * rates);
typedef void (__stdcall *PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC)(GLenum rate, GLuint samples, const GLint * locations);
typedef void (__stdcall *PFNGLSHADINGRATESAMPLEORDERNVPROC)(GLenum order);
typedef void (__stdcall *PFNGLSHARPENTEXFUNCSGISPROC)(GLenum target, GLsizei n, const GLfloat * points);
typedef void (__stdcall *PFNGLSIGNALSEMAPHOREEXTPROC)(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * dstLayouts);
typedef void (__stdcall *PFNGLSIGNALSEMAPHOREUI64NVXPROC)(GLuint signalGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);
typedef void (__stdcall *PFNGLSIGNALVKFENCENVPROC)(GLuint64 vkFence);
typedef void (__stdcall *PFNGLSIGNALVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
typedef void (__stdcall *PFNGLSPECIALIZESHADERARBPROC)(GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue);
typedef void (__stdcall *PFNGLSPRITEPARAMETERFSGIXPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLSPRITEPARAMETERFVSGIXPROC)(GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLSPRITEPARAMETERISGIXPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLSPRITEPARAMETERIVSGIXPROC)(GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLSTARTINSTRUMENTSSGIXPROC)(void);
typedef void (__stdcall *PFNGLSTATECAPTURENVPROC)(GLuint state, GLenum mode);
typedef void (__stdcall *PFNGLSTENCILCLEARTAGEXTPROC)(GLsizei stencilTagBits, GLuint stencilClearTag);
typedef void (__stdcall *PFNGLSTENCILFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues);
typedef void (__stdcall *PFNGLSTENCILFILLPATHNVPROC)(GLuint path, GLenum fillMode, GLuint mask);
typedef void (__stdcall *PFNGLSTENCILFUNCPROC)(GLenum func, GLint ref, GLuint mask);
typedef void (__stdcall *PFNGLSTENCILFUNCSEPARATEPROC)(GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (__stdcall *PFNGLSTENCILFUNCSEPARATEATIPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall *PFNGLSTENCILMASKPROC)(GLuint mask);
typedef void (__stdcall *PFNGLSTENCILMASKSEPARATEPROC)(GLenum face, GLuint mask);
typedef void (__stdcall *PFNGLSTENCILOPPROC)(GLenum fail, GLenum zfail, GLenum zpass);
typedef void (__stdcall *PFNGLSTENCILOPSEPARATEPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (__stdcall *PFNGLSTENCILOPSEPARATEATIPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (__stdcall *PFNGLSTENCILOPVALUEAMDPROC)(GLenum face, GLuint value);
typedef void (__stdcall *PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues);
typedef void (__stdcall *PFNGLSTENCILSTROKEPATHNVPROC)(GLuint path, GLint reference, GLuint mask);
typedef void (__stdcall *PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (__stdcall *PFNGLSTENCILTHENCOVERFILLPATHNVPROC)(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
typedef void (__stdcall *PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC)(GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues);
typedef void (__stdcall *PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC)(GLuint path, GLint reference, GLuint mask, GLenum coverMode);
typedef void (__stdcall *PFNGLSTOPINSTRUMENTSSGIXPROC)(GLint marker);
typedef void (__stdcall *PFNGLSTRINGMARKERGREMEDYPROC)(GLsizei len, const void * string);
typedef void (__stdcall *PFNGLSUBPIXELPRECISIONBIASNVPROC)(GLuint xbits, GLuint ybits);
typedef void (__stdcall *PFNGLSWIZZLEEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void (__stdcall *PFNGLSYNCTEXTUREINTELPROC)(GLuint texture);
typedef void (__stdcall *PFNGLTAGSAMPLEBUFFERSGIXPROC)(void);
typedef void (__stdcall *PFNGLTANGENT3BEXTPROC)(GLbyte tx, GLbyte ty, GLbyte tz);
typedef void (__stdcall *PFNGLTANGENT3BVEXTPROC)(const GLbyte * v);
typedef void (__stdcall *PFNGLTANGENT3DEXTPROC)(GLdouble tx, GLdouble ty, GLdouble tz);
typedef void (__stdcall *PFNGLTANGENT3DVEXTPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLTANGENT3FEXTPROC)(GLfloat tx, GLfloat ty, GLfloat tz);
typedef void (__stdcall *PFNGLTANGENT3FVEXTPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLTANGENT3IEXTPROC)(GLint tx, GLint ty, GLint tz);
typedef void (__stdcall *PFNGLTANGENT3IVEXTPROC)(const GLint * v);
typedef void (__stdcall *PFNGLTANGENT3SEXTPROC)(GLshort tx, GLshort ty, GLshort tz);
typedef void (__stdcall *PFNGLTANGENT3SVEXTPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLTANGENTPOINTEREXTPROC)(GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLTBUFFERMASK3DFXPROC)(GLuint mask);
typedef void (__stdcall *PFNGLTESSELLATIONFACTORAMDPROC)(GLfloat factor);
typedef void (__stdcall *PFNGLTESSELLATIONMODEAMDPROC)(GLenum mode);
typedef GLboolean (__stdcall *PFNGLTESTFENCEAPPLEPROC)(GLuint fence);
typedef GLboolean (__stdcall *PFNGLTESTFENCENVPROC)(GLuint fence);
typedef GLboolean (__stdcall *PFNGLTESTOBJECTAPPLEPROC)(GLenum object, GLuint name);
typedef void (__stdcall *PFNGLTEXATTACHMEMORYNVPROC)(GLenum target, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXBUFFERPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall *PFNGLTEXBUFFERARBPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall *PFNGLTEXBUFFEREXTPROC)(GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall *PFNGLTEXBUFFERRANGEPROC)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLTEXBUMPPARAMETERFVATIPROC)(GLenum pname, const GLfloat * param);
typedef void (__stdcall *PFNGLTEXBUMPPARAMETERIVATIPROC)(GLenum pname, const GLint * param);
typedef void (__stdcall *PFNGLTEXCOORD1BOESPROC)(GLbyte s);
typedef void (__stdcall *PFNGLTEXCOORD1BVOESPROC)(const GLbyte * coords);
typedef void (__stdcall *PFNGLTEXCOORD1HNVPROC)(GLhalfNV s);
typedef void (__stdcall *PFNGLTEXCOORD1HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLTEXCOORD1XOESPROC)(GLfixed s);
typedef void (__stdcall *PFNGLTEXCOORD1XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLTEXCOORD2BOESPROC)(GLbyte s, GLbyte t);
typedef void (__stdcall *PFNGLTEXCOORD2BVOESPROC)(const GLbyte * coords);
typedef void (__stdcall *PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC)(const GLfloat * tc, const GLfloat * c, const GLfloat * v);
typedef void (__stdcall *PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC)(const GLfloat * tc, const GLubyte * c, const GLfloat * v);
typedef void (__stdcall *PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC)(const GLfloat * tc, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLTEXCOORD2FVERTEX3FSUNPROC)(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLTEXCOORD2FVERTEX3FVSUNPROC)(const GLfloat * tc, const GLfloat * v);
typedef void (__stdcall *PFNGLTEXCOORD2HNVPROC)(GLhalfNV s, GLhalfNV t);
typedef void (__stdcall *PFNGLTEXCOORD2HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLTEXCOORD2XOESPROC)(GLfixed s, GLfixed t);
typedef void (__stdcall *PFNGLTEXCOORD2XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLTEXCOORD3BOESPROC)(GLbyte s, GLbyte t, GLbyte r);
typedef void (__stdcall *PFNGLTEXCOORD3BVOESPROC)(const GLbyte * coords);
typedef void (__stdcall *PFNGLTEXCOORD3HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void (__stdcall *PFNGLTEXCOORD3HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLTEXCOORD3XOESPROC)(GLfixed s, GLfixed t, GLfixed r);
typedef void (__stdcall *PFNGLTEXCOORD3XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLTEXCOORD4BOESPROC)(GLbyte s, GLbyte t, GLbyte r, GLbyte q);
typedef void (__stdcall *PFNGLTEXCOORD4BVOESPROC)(const GLbyte * coords);
typedef void (__stdcall *PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC)(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v);
typedef void (__stdcall *PFNGLTEXCOORD4FVERTEX4FSUNPROC)(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLTEXCOORD4FVERTEX4FVSUNPROC)(const GLfloat * tc, const GLfloat * v);
typedef void (__stdcall *PFNGLTEXCOORD4HNVPROC)(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void (__stdcall *PFNGLTEXCOORD4HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLTEXCOORD4XOESPROC)(GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void (__stdcall *PFNGLTEXCOORD4XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLTEXCOORDFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLTEXCOORDPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (__stdcall *PFNGLTEXCOORDPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLTEXCOORDPOINTERVINTELPROC)(GLint size, GLenum type, const void ** pointer);
typedef void (__stdcall *PFNGLTEXENVXOESPROC)(GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLTEXENVXVOESPROC)(GLenum target, GLenum pname, const GLfixed * params);
typedef void (__stdcall *PFNGLTEXFILTERFUNCSGISPROC)(GLenum target, GLenum filter, GLsizei n, const GLfloat * weights);
typedef void (__stdcall *PFNGLTEXGENXOESPROC)(GLenum coord, GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLTEXGENXVOESPROC)(GLenum coord, GLenum pname, const GLfixed * params);
typedef void (__stdcall *PFNGLTEXIMAGE1DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXIMAGE2DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXIMAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall *PFNGLTEXIMAGE3DPROC)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXIMAGE3DEXTPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXIMAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall *PFNGLTEXIMAGE4DSGISPROC)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXPAGECOMMITMENTARBPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (__stdcall *PFNGLTEXPAGECOMMITMENTMEMNVPROC)(GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
typedef void (__stdcall *PFNGLTEXPARAMETERIIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLTEXPARAMETERIIVEXTPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLTEXPARAMETERIUIVPROC)(GLenum target, GLenum pname, const GLuint * params);
typedef void (__stdcall *PFNGLTEXPARAMETERIUIVEXTPROC)(GLenum target, GLenum pname, const GLuint * params);
typedef void (__stdcall *PFNGLTEXPARAMETERFPROC)(GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLTEXPARAMETERFVPROC)(GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLTEXPARAMETERIPROC)(GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLTEXPARAMETERIVPROC)(GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLTEXPARAMETERXOESPROC)(GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall *PFNGLTEXPARAMETERXVOESPROC)(GLenum target, GLenum pname, const GLfixed * params);
typedef void (__stdcall *PFNGLTEXRENDERBUFFERNVPROC)(GLenum target, GLuint renderbuffer);
typedef void (__stdcall *PFNGLTEXSTORAGE1DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall *PFNGLTEXSTORAGE1DEXTPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall *PFNGLTEXSTORAGE2DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLTEXSTORAGE2DEXTPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLTEXSTORAGE2DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXSTORAGE3DPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall *PFNGLTEXSTORAGE3DEXTPROC)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall *PFNGLTEXSTORAGE3DMULTISAMPLEPROC)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXSTORAGEMEM1DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXSTORAGEMEM2DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXSTORAGEMEM3DEXTPROC)(GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC)(GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXSTORAGESPARSEAMDPROC)(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (__stdcall *PFNGLTEXSUBIMAGE1DPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXSUBIMAGE1DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXSUBIMAGE2DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXSUBIMAGE2DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXSUBIMAGE3DPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXSUBIMAGE3DEXTPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXSUBIMAGE4DSGISPROC)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTUREATTACHMEMORYNVPROC)(GLuint texture, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXTUREBARRIERPROC)(void);
typedef void (__stdcall *PFNGLTEXTUREBARRIERNVPROC)(void);
typedef void (__stdcall *PFNGLTEXTUREBUFFERPROC)(GLuint texture, GLenum internalformat, GLuint buffer);
typedef void (__stdcall *PFNGLTEXTUREBUFFEREXTPROC)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall *PFNGLTEXTUREBUFFERRANGEPROC)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLTEXTUREBUFFERRANGEEXTPROC)(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLTEXTURECOLORMASKSGISPROC)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (__stdcall *PFNGLTEXTUREIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTUREIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall *PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall *PFNGLTEXTUREIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC)(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall *PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC)(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall *PFNGLTEXTURELIGHTEXTPROC)(GLenum pname);
typedef void (__stdcall *PFNGLTEXTUREMATERIALEXTPROC)(GLenum face, GLenum mode);
typedef void (__stdcall *PFNGLTEXTURENORMALEXTPROC)(GLenum mode);
typedef void (__stdcall *PFNGLTEXTUREPAGECOMMITMENTEXTPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (__stdcall *PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC)(GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIIVPROC)(GLuint texture, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIUIVPROC)(GLuint texture, GLenum pname, const GLuint * params);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIUIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLuint * params);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERFPROC)(GLuint texture, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERFEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERFVPROC)(GLuint texture, GLenum pname, const GLfloat * param);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERFVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIPROC)(GLuint texture, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIEXTPROC)(GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIVPROC)(GLuint texture, GLenum pname, const GLint * param);
typedef void (__stdcall *PFNGLTEXTUREPARAMETERIVEXTPROC)(GLuint texture, GLenum target, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLTEXTURERANGEAPPLEPROC)(GLenum target, GLsizei length, const void * pointer);
typedef void (__stdcall *PFNGLTEXTURERENDERBUFFEREXTPROC)(GLuint texture, GLenum target, GLuint renderbuffer);
typedef void (__stdcall *PFNGLTEXTURESTORAGE1DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall *PFNGLTEXTURESTORAGE1DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall *PFNGLTEXTURESTORAGE2DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLTEXTURESTORAGE2DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXTURESTORAGE3DPROC)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall *PFNGLTEXTURESTORAGE3DEXTPROC)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall *PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC)(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall *PFNGLTEXTURESTORAGEMEM1DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXTURESTORAGEMEM2DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC)(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXTURESTORAGEMEM3DEXTPROC)(GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC)(GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall *PFNGLTEXTURESTORAGESPARSEAMDPROC)(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (__stdcall *PFNGLTEXTURESUBIMAGE1DPROC)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTURESUBIMAGE1DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTURESUBIMAGE2DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTURESUBIMAGE2DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTURESUBIMAGE3DPROC)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTURESUBIMAGE3DEXTPROC)(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels);
typedef void (__stdcall *PFNGLTEXTUREVIEWPROC)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
typedef void (__stdcall *PFNGLTRACKMATRIXNVPROC)(GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (__stdcall *PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC)(GLsizei count, const GLint * attribs, GLenum bufferMode);
typedef void (__stdcall *PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)(GLuint xfb, GLuint index, GLuint buffer);
typedef void (__stdcall *PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall *PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC)(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode);
typedef void (__stdcall *PFNGLTRANSFORMFEEDBACKVARYINGSPROC)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (__stdcall *PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC)(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (__stdcall *PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC)(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode);
typedef void (__stdcall *PFNGLTRANSFORMPATHNVPROC)(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues);
typedef void (__stdcall *PFNGLTRANSLATEXOESPROC)(GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall *PFNGLUNIFORM1DPROC)(GLint location, GLdouble x);
typedef void (__stdcall *PFNGLUNIFORM1DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORM1FPROC)(GLint location, GLfloat v0);
typedef void (__stdcall *PFNGLUNIFORM1FARBPROC)(GLint location, GLfloat v0);
typedef void (__stdcall *PFNGLUNIFORM1FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM1FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM1IPROC)(GLint location, GLint v0);
typedef void (__stdcall *PFNGLUNIFORM1I64ARBPROC)(GLint location, GLint64 x);
typedef void (__stdcall *PFNGLUNIFORM1I64NVPROC)(GLint location, GLint64EXT x);
typedef void (__stdcall *PFNGLUNIFORM1I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLUNIFORM1I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM1IARBPROC)(GLint location, GLint v0);
typedef void (__stdcall *PFNGLUNIFORM1IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM1IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM1UIPROC)(GLint location, GLuint v0);
typedef void (__stdcall *PFNGLUNIFORM1UI64ARBPROC)(GLint location, GLuint64 x);
typedef void (__stdcall *PFNGLUNIFORM1UI64NVPROC)(GLint location, GLuint64EXT x);
typedef void (__stdcall *PFNGLUNIFORM1UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLUNIFORM1UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM1UIEXTPROC)(GLint location, GLuint v0);
typedef void (__stdcall *PFNGLUNIFORM1UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORM1UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORM2DPROC)(GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLUNIFORM2DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORM2FPROC)(GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall *PFNGLUNIFORM2FARBPROC)(GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall *PFNGLUNIFORM2FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM2FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM2IPROC)(GLint location, GLint v0, GLint v1);
typedef void (__stdcall *PFNGLUNIFORM2I64ARBPROC)(GLint location, GLint64 x, GLint64 y);
typedef void (__stdcall *PFNGLUNIFORM2I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall *PFNGLUNIFORM2I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLUNIFORM2I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM2IARBPROC)(GLint location, GLint v0, GLint v1);
typedef void (__stdcall *PFNGLUNIFORM2IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM2IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM2UIPROC)(GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall *PFNGLUNIFORM2UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y);
typedef void (__stdcall *PFNGLUNIFORM2UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall *PFNGLUNIFORM2UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLUNIFORM2UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM2UIEXTPROC)(GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall *PFNGLUNIFORM2UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORM2UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORM3DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLUNIFORM3DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORM3FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall *PFNGLUNIFORM3FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall *PFNGLUNIFORM3FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM3FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM3IPROC)(GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall *PFNGLUNIFORM3I64ARBPROC)(GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (__stdcall *PFNGLUNIFORM3I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall *PFNGLUNIFORM3I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLUNIFORM3I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM3IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall *PFNGLUNIFORM3IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM3IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM3UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall *PFNGLUNIFORM3UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (__stdcall *PFNGLUNIFORM3UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall *PFNGLUNIFORM3UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLUNIFORM3UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM3UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall *PFNGLUNIFORM3UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORM3UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORM4DPROC)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLUNIFORM4DVPROC)(GLint location, GLsizei count, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORM4FPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall *PFNGLUNIFORM4FARBPROC)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall *PFNGLUNIFORM4FVPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM4FVARBPROC)(GLint location, GLsizei count, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORM4IPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall *PFNGLUNIFORM4I64ARBPROC)(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (__stdcall *PFNGLUNIFORM4I64NVPROC)(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall *PFNGLUNIFORM4I64VARBPROC)(GLint location, GLsizei count, const GLint64 * value);
typedef void (__stdcall *PFNGLUNIFORM4I64VNVPROC)(GLint location, GLsizei count, const GLint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM4IARBPROC)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall *PFNGLUNIFORM4IVPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM4IVARBPROC)(GLint location, GLsizei count, const GLint * value);
typedef void (__stdcall *PFNGLUNIFORM4UIPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall *PFNGLUNIFORM4UI64ARBPROC)(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (__stdcall *PFNGLUNIFORM4UI64NVPROC)(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall *PFNGLUNIFORM4UI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLUNIFORM4UI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLUNIFORM4UIEXTPROC)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall *PFNGLUNIFORM4UIVPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORM4UIVEXTPROC)(GLint location, GLsizei count, const GLuint * value);
typedef void (__stdcall *PFNGLUNIFORMBLOCKBINDINGPROC)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
typedef void (__stdcall *PFNGLUNIFORMBUFFEREXTPROC)(GLuint program, GLint location, GLuint buffer);
typedef void (__stdcall *PFNGLUNIFORMHANDLEUI64ARBPROC)(GLint location, GLuint64 value);
typedef void (__stdcall *PFNGLUNIFORMHANDLEUI64NVPROC)(GLint location, GLuint64 value);
typedef void (__stdcall *PFNGLUNIFORMHANDLEUI64VARBPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLUNIFORMHANDLEUI64VNVPROC)(GLint location, GLsizei count, const GLuint64 * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX2FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX2X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX2X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX2X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX2X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX3FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX3X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX3X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX3X4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX3X4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX4DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX4FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX4FVARBPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX4X2DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX4X2FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX4X3DVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value);
typedef void (__stdcall *PFNGLUNIFORMMATRIX4X3FVPROC)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value);
typedef void (__stdcall *PFNGLUNIFORMSUBROUTINESUIVPROC)(GLenum shadertype, GLsizei count, const GLuint * indices);
typedef void (__stdcall *PFNGLUNIFORMUI64NVPROC)(GLint location, GLuint64EXT value);
typedef void (__stdcall *PFNGLUNIFORMUI64VNVPROC)(GLint location, GLsizei count, const GLuint64EXT * value);
typedef void (__stdcall *PFNGLUNLOCKARRAYSEXTPROC)(void);
typedef GLboolean (__stdcall *PFNGLUNMAPBUFFERPROC)(GLenum target);
typedef GLboolean (__stdcall *PFNGLUNMAPBUFFERARBPROC)(GLenum target);
typedef GLboolean (__stdcall *PFNGLUNMAPNAMEDBUFFERPROC)(GLuint buffer);
typedef GLboolean (__stdcall *PFNGLUNMAPNAMEDBUFFEREXTPROC)(GLuint buffer);
typedef void (__stdcall *PFNGLUNMAPOBJECTBUFFERATIPROC)(GLuint buffer);
typedef void (__stdcall *PFNGLUNMAPTEXTURE2DINTELPROC)(GLuint texture, GLint level);
typedef void (__stdcall *PFNGLUPDATEOBJECTBUFFERATIPROC)(GLuint buffer, GLuint offset, GLsizei size, const void * pointer, GLenum preserve);
typedef void (__stdcall *PFNGLUPLOADGPUMASKNVXPROC)(GLbitfield mask);
typedef void (__stdcall *PFNGLUSEPROGRAMPROC)(GLuint program);
typedef void (__stdcall *PFNGLUSEPROGRAMOBJECTARBPROC)(GLhandleARB programObj);
typedef void (__stdcall *PFNGLUSEPROGRAMSTAGESPROC)(GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (__stdcall *PFNGLUSESHADERPROGRAMEXTPROC)(GLenum type, GLuint program);
typedef void (__stdcall *PFNGLVDPAUFININVPROC)(void);
typedef void (__stdcall *PFNGLVDPAUGETSURFACEIVNVPROC)(GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei * length, GLint * values);
typedef void (__stdcall *PFNGLVDPAUINITNVPROC)(const void * vdpDevice, const void * getProcAddress);
typedef GLboolean (__stdcall *PFNGLVDPAUISSURFACENVPROC)(GLvdpauSurfaceNV surface);
typedef void (__stdcall *PFNGLVDPAUMAPSURFACESNVPROC)(GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces);
typedef GLvdpauSurfaceNV (__stdcall *PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC)(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);
typedef GLvdpauSurfaceNV (__stdcall *PFNGLVDPAUREGISTERVIDEOSURFACENVPROC)(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames);
typedef GLvdpauSurfaceNV (__stdcall *PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC)(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames, GLboolean isFrameStructure);
typedef void (__stdcall *PFNGLVDPAUSURFACEACCESSNVPROC)(GLvdpauSurfaceNV surface, GLenum access);
typedef void (__stdcall *PFNGLVDPAUUNMAPSURFACESNVPROC)(GLsizei numSurface, const GLvdpauSurfaceNV * surfaces);
typedef void (__stdcall *PFNGLVDPAUUNREGISTERSURFACENVPROC)(GLvdpauSurfaceNV surface);
typedef void (__stdcall *PFNGLVALIDATEPROGRAMPROC)(GLuint program);
typedef void (__stdcall *PFNGLVALIDATEPROGRAMARBPROC)(GLhandleARB programObj);
typedef void (__stdcall *PFNGLVALIDATEPROGRAMPIPELINEPROC)(GLuint pipeline);
typedef void (__stdcall *PFNGLVARIANTARRAYOBJECTATIPROC)(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (__stdcall *PFNGLVARIANTPOINTEREXTPROC)(GLuint id, GLenum type, GLuint stride, const void * addr);
typedef void (__stdcall *PFNGLVARIANTBVEXTPROC)(GLuint id, const GLbyte * addr);
typedef void (__stdcall *PFNGLVARIANTDVEXTPROC)(GLuint id, const GLdouble * addr);
typedef void (__stdcall *PFNGLVARIANTFVEXTPROC)(GLuint id, const GLfloat * addr);
typedef void (__stdcall *PFNGLVARIANTIVEXTPROC)(GLuint id, const GLint * addr);
typedef void (__stdcall *PFNGLVARIANTSVEXTPROC)(GLuint id, const GLshort * addr);
typedef void (__stdcall *PFNGLVARIANTUBVEXTPROC)(GLuint id, const GLubyte * addr);
typedef void (__stdcall *PFNGLVARIANTUIVEXTPROC)(GLuint id, const GLuint * addr);
typedef void (__stdcall *PFNGLVARIANTUSVEXTPROC)(GLuint id, const GLushort * addr);
typedef void (__stdcall *PFNGLVERTEX2BOESPROC)(GLbyte x, GLbyte y);
typedef void (__stdcall *PFNGLVERTEX2BVOESPROC)(const GLbyte * coords);
typedef void (__stdcall *PFNGLVERTEX2HNVPROC)(GLhalfNV x, GLhalfNV y);
typedef void (__stdcall *PFNGLVERTEX2HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEX2XOESPROC)(GLfixed x);
typedef void (__stdcall *PFNGLVERTEX2XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLVERTEX3BOESPROC)(GLbyte x, GLbyte y, GLbyte z);
typedef void (__stdcall *PFNGLVERTEX3BVOESPROC)(const GLbyte * coords);
typedef void (__stdcall *PFNGLVERTEX3HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void (__stdcall *PFNGLVERTEX3HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEX3XOESPROC)(GLfixed x, GLfixed y);
typedef void (__stdcall *PFNGLVERTEX3XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLVERTEX4BOESPROC)(GLbyte x, GLbyte y, GLbyte z, GLbyte w);
typedef void (__stdcall *PFNGLVERTEX4BVOESPROC)(const GLbyte * coords);
typedef void (__stdcall *PFNGLVERTEX4HNVPROC)(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void (__stdcall *PFNGLVERTEX4HVNVPROC)(const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEX4XOESPROC)(GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall *PFNGLVERTEX4XVOESPROC)(const GLfixed * coords);
typedef void (__stdcall *PFNGLVERTEXARRAYATTRIBBINDINGPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall *PFNGLVERTEXARRAYATTRIBFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXARRAYATTRIBIFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXARRAYATTRIBLFORMATPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall *PFNGLVERTEXARRAYBINDINGDIVISORPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall *PFNGLVERTEXARRAYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYELEMENTBUFFERPROC)(GLuint vaobj, GLuint buffer);
typedef void (__stdcall *PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYINDEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYNORMALOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYPARAMETERIAPPLEPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLVERTEXARRAYRANGEAPPLEPROC)(GLsizei length, void * pointer);
typedef void (__stdcall *PFNGLVERTEXARRAYRANGENVPROC)(GLsizei length, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC)(GLuint vaobj, GLuint index, GLuint divisor);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXBUFFERPROC)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXBUFFERSPROC)(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides);
typedef void (__stdcall *PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC)(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall *PFNGLVERTEXATTRIB1DPROC)(GLuint index, GLdouble x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1DARBPROC)(GLuint index, GLdouble x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1DNVPROC)(GLuint index, GLdouble x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1FPROC)(GLuint index, GLfloat x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1FARBPROC)(GLuint index, GLfloat x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1FNVPROC)(GLuint index, GLfloat x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1FVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1HNVPROC)(GLuint index, GLhalfNV x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1SPROC)(GLuint index, GLshort x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1SARBPROC)(GLuint index, GLshort x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1SNVPROC)(GLuint index, GLshort x);
typedef void (__stdcall *PFNGLVERTEXATTRIB1SVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1SVARBPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB1SVNVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2DARBPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2DNVPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2FPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2FARBPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2FNVPROC)(GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2FVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2SPROC)(GLuint index, GLshort x, GLshort y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2SARBPROC)(GLuint index, GLshort x, GLshort y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2SNVPROC)(GLuint index, GLshort x, GLshort y);
typedef void (__stdcall *PFNGLVERTEXATTRIB2SVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2SVARBPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB2SVNVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3FVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3SPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall *PFNGLVERTEXATTRIB3SVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3SVARBPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB3SVNVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NBVPROC)(GLuint index, const GLbyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NBVARBPROC)(GLuint index, const GLbyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NIVPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NIVARBPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NSVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NSVARBPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUBARBPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUBVPROC)(GLuint index, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUBVARBPROC)(GLuint index, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUIVPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUIVARBPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUSVPROC)(GLuint index, const GLushort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4NUSVARBPROC)(GLuint index, const GLushort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4BVPROC)(GLuint index, const GLbyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4BVARBPROC)(GLuint index, const GLbyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4DARBPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4DNVPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4DVARBPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4DVNVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4FPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4FARBPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4FNVPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4FVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4FVARBPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4FVNVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4HNVPROC)(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4HVNVPROC)(GLuint index, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4IVPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4IVARBPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4SPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4SARBPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4SNVPROC)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4SVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4SVARBPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4SVNVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4UBNVPROC)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall *PFNGLVERTEXATTRIB4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4UBVARBPROC)(GLuint index, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4UBVNVPROC)(GLuint index, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4UIVPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4UIVARBPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4USVPROC)(GLuint index, const GLushort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIB4USVARBPROC)(GLuint index, const GLushort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBARRAYOBJECTATIPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (__stdcall *PFNGLVERTEXATTRIBBINDINGPROC)(GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall *PFNGLVERTEXATTRIBDIVISORPROC)(GLuint index, GLuint divisor);
typedef void (__stdcall *PFNGLVERTEXATTRIBDIVISORARBPROC)(GLuint index, GLuint divisor);
typedef void (__stdcall *PFNGLVERTEXATTRIBFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXATTRIBFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1IPROC)(GLuint index, GLint x);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1IEXTPROC)(GLuint index, GLint x);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1IVPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1IVEXTPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1UIPROC)(GLuint index, GLuint x);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1UIEXTPROC)(GLuint index, GLuint x);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1UIVPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI1UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2IPROC)(GLuint index, GLint x, GLint y);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2IEXTPROC)(GLuint index, GLint x, GLint y);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2IVPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2IVEXTPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2UIPROC)(GLuint index, GLuint x, GLuint y);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2UIEXTPROC)(GLuint index, GLuint x, GLuint y);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2UIVPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI2UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3IPROC)(GLuint index, GLint x, GLint y, GLint z);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3IEXTPROC)(GLuint index, GLint x, GLint y, GLint z);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3IVPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3IVEXTPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3UIVPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI3UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4BVPROC)(GLuint index, const GLbyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4BVEXTPROC)(GLuint index, const GLbyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4IPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4IEXTPROC)(GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4IVPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4IVEXTPROC)(GLuint index, const GLint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4SVPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4SVEXTPROC)(GLuint index, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4UBVPROC)(GLuint index, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4UBVEXTPROC)(GLuint index, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4UIPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4UIEXTPROC)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4UIVPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4UIVEXTPROC)(GLuint index, const GLuint * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4USVPROC)(GLuint index, const GLushort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBI4USVEXTPROC)(GLuint index, const GLushort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBIFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXATTRIBIFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLVERTEXATTRIBIPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXATTRIBIPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1DPROC)(GLuint index, GLdouble x);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1DEXTPROC)(GLuint index, GLdouble x);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1I64NVPROC)(GLuint index, GLint64EXT x);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1UI64ARBPROC)(GLuint index, GLuint64EXT x);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1UI64NVPROC)(GLuint index, GLuint64EXT x);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1UI64VARBPROC)(GLuint index, const GLuint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL1UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2DPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2DEXTPROC)(GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall *PFNGLVERTEXATTRIBL2UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall *PFNGLVERTEXATTRIBL3UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4DPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4DEXTPROC)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4DVPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4DVEXTPROC)(GLuint index, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4I64NVPROC)(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4I64VNVPROC)(GLuint index, const GLint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4UI64NVPROC)(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall *PFNGLVERTEXATTRIBL4UI64VNVPROC)(GLuint index, const GLuint64EXT * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBLFORMATPROC)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall *PFNGLVERTEXATTRIBLFORMATNVPROC)(GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLVERTEXATTRIBLPOINTERPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXATTRIBLPOINTEREXTPROC)(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXATTRIBP1UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall *PFNGLVERTEXATTRIBP1UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (__stdcall *PFNGLVERTEXATTRIBP2UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall *PFNGLVERTEXATTRIBP2UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (__stdcall *PFNGLVERTEXATTRIBP3UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall *PFNGLVERTEXATTRIBP3UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (__stdcall *PFNGLVERTEXATTRIBP4UIPROC)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall *PFNGLVERTEXATTRIBP4UIVPROC)(GLuint index, GLenum type, GLboolean normalized, const GLuint * value);
typedef void (__stdcall *PFNGLVERTEXATTRIBPARAMETERIAMDPROC)(GLuint index, GLenum pname, GLint param);
typedef void (__stdcall *PFNGLVERTEXATTRIBPOINTERPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXATTRIBPOINTERARBPROC)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXATTRIBPOINTERNVPROC)(GLuint index, GLint fsize, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXATTRIBS1DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS1FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS1HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS1SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS2DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS2FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS2HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS2SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS3DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS3FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS3HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS3SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS4DVNVPROC)(GLuint index, GLsizei count, const GLdouble * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS4FVNVPROC)(GLuint index, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS4HVNVPROC)(GLuint index, GLsizei n, const GLhalfNV * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS4SVNVPROC)(GLuint index, GLsizei count, const GLshort * v);
typedef void (__stdcall *PFNGLVERTEXATTRIBS4UBVNVPROC)(GLuint index, GLsizei count, const GLubyte * v);
typedef void (__stdcall *PFNGLVERTEXBINDINGDIVISORPROC)(GLuint bindingindex, GLuint divisor);
typedef void (__stdcall *PFNGLVERTEXBLENDARBPROC)(GLint count);
typedef void (__stdcall *PFNGLVERTEXBLENDENVFATIPROC)(GLenum pname, GLfloat param);
typedef void (__stdcall *PFNGLVERTEXBLENDENVIATIPROC)(GLenum pname, GLint param);
typedef void (__stdcall *PFNGLVERTEXFORMATNVPROC)(GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall *PFNGLVERTEXPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXPOINTERLISTIBMPROC)(GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride);
typedef void (__stdcall *PFNGLVERTEXPOINTERVINTELPROC)(GLint size, GLenum type, const void ** pointer);
typedef void (__stdcall *PFNGLVERTEXSTREAM1DATIPROC)(GLenum stream, GLdouble x);
typedef void (__stdcall *PFNGLVERTEXSTREAM1DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM1FATIPROC)(GLenum stream, GLfloat x);
typedef void (__stdcall *PFNGLVERTEXSTREAM1FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM1IATIPROC)(GLenum stream, GLint x);
typedef void (__stdcall *PFNGLVERTEXSTREAM1IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM1SATIPROC)(GLenum stream, GLshort x);
typedef void (__stdcall *PFNGLVERTEXSTREAM1SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM2DATIPROC)(GLenum stream, GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLVERTEXSTREAM2DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM2FATIPROC)(GLenum stream, GLfloat x, GLfloat y);
typedef void (__stdcall *PFNGLVERTEXSTREAM2FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM2IATIPROC)(GLenum stream, GLint x, GLint y);
typedef void (__stdcall *PFNGLVERTEXSTREAM2IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM2SATIPROC)(GLenum stream, GLshort x, GLshort y);
typedef void (__stdcall *PFNGLVERTEXSTREAM2SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM3DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLVERTEXSTREAM3DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM3FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLVERTEXSTREAM3FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM3IATIPROC)(GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall *PFNGLVERTEXSTREAM3IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM3SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall *PFNGLVERTEXSTREAM3SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM4DATIPROC)(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLVERTEXSTREAM4DVATIPROC)(GLenum stream, const GLdouble * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM4FATIPROC)(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLVERTEXSTREAM4FVATIPROC)(GLenum stream, const GLfloat * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM4IATIPROC)(GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall *PFNGLVERTEXSTREAM4IVATIPROC)(GLenum stream, const GLint * coords);
typedef void (__stdcall *PFNGLVERTEXSTREAM4SATIPROC)(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall *PFNGLVERTEXSTREAM4SVATIPROC)(GLenum stream, const GLshort * coords);
typedef void (__stdcall *PFNGLVERTEXWEIGHTPOINTEREXTPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLVERTEXWEIGHTFEXTPROC)(GLfloat weight);
typedef void (__stdcall *PFNGLVERTEXWEIGHTFVEXTPROC)(const GLfloat * weight);
typedef void (__stdcall *PFNGLVERTEXWEIGHTHNVPROC)(GLhalfNV weight);
typedef void (__stdcall *PFNGLVERTEXWEIGHTHVNVPROC)(const GLhalfNV * weight);
typedef GLenum (__stdcall *PFNGLVIDEOCAPTURENVPROC)(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time);
typedef void (__stdcall *PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params);
typedef void (__stdcall *PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params);
typedef void (__stdcall *PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC)(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params);
typedef void (__stdcall *PFNGLVIEWPORTPROC)(GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall *PFNGLVIEWPORTARRAYVPROC)(GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall *PFNGLVIEWPORTINDEXEDFPROC)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (__stdcall *PFNGLVIEWPORTINDEXEDFVPROC)(GLuint index, const GLfloat * v);
typedef void (__stdcall *PFNGLVIEWPORTPOSITIONWSCALENVPROC)(GLuint index, GLfloat xcoeff, GLfloat ycoeff);
typedef void (__stdcall *PFNGLVIEWPORTSWIZZLENVPROC)(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
typedef void (__stdcall *PFNGLWAITSEMAPHOREEXTPROC)(GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * srcLayouts);
typedef void (__stdcall *PFNGLWAITSEMAPHOREUI64NVXPROC)(GLuint waitGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray);
typedef void (__stdcall *PFNGLWAITSYNCPROC)(GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (__stdcall *PFNGLWAITVKSEMAPHORENVPROC)(GLuint64 vkSemaphore);
typedef void (__stdcall *PFNGLWEIGHTPATHSNVPROC)(GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights);
typedef void (__stdcall *PFNGLWEIGHTPOINTERARBPROC)(GLint size, GLenum type, GLsizei stride, const void * pointer);
typedef void (__stdcall *PFNGLWEIGHTBVARBPROC)(GLint size, const GLbyte * weights);
typedef void (__stdcall *PFNGLWEIGHTDVARBPROC)(GLint size, const GLdouble * weights);
typedef void (__stdcall *PFNGLWEIGHTFVARBPROC)(GLint size, const GLfloat * weights);
typedef void (__stdcall *PFNGLWEIGHTIVARBPROC)(GLint size, const GLint * weights);
typedef void (__stdcall *PFNGLWEIGHTSVARBPROC)(GLint size, const GLshort * weights);
typedef void (__stdcall *PFNGLWEIGHTUBVARBPROC)(GLint size, const GLubyte * weights);
typedef void (__stdcall *PFNGLWEIGHTUIVARBPROC)(GLint size, const GLuint * weights);
typedef void (__stdcall *PFNGLWEIGHTUSVARBPROC)(GLint size, const GLushort * weights);
typedef void (__stdcall *PFNGLWINDOWPOS2DARBPROC)(GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLWINDOWPOS2DMESAPROC)(GLdouble x, GLdouble y);
typedef void (__stdcall *PFNGLWINDOWPOS2DVARBPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLWINDOWPOS2DVMESAPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLWINDOWPOS2FARBPROC)(GLfloat x, GLfloat y);
typedef void (__stdcall *PFNGLWINDOWPOS2FMESAPROC)(GLfloat x, GLfloat y);
typedef void (__stdcall *PFNGLWINDOWPOS2FVARBPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLWINDOWPOS2FVMESAPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLWINDOWPOS2IARBPROC)(GLint x, GLint y);
typedef void (__stdcall *PFNGLWINDOWPOS2IMESAPROC)(GLint x, GLint y);
typedef void (__stdcall *PFNGLWINDOWPOS2IVARBPROC)(const GLint * v);
typedef void (__stdcall *PFNGLWINDOWPOS2IVMESAPROC)(const GLint * v);
typedef void (__stdcall *PFNGLWINDOWPOS2SARBPROC)(GLshort x, GLshort y);
typedef void (__stdcall *PFNGLWINDOWPOS2SMESAPROC)(GLshort x, GLshort y);
typedef void (__stdcall *PFNGLWINDOWPOS2SVARBPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLWINDOWPOS2SVMESAPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLWINDOWPOS3DARBPROC)(GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLWINDOWPOS3DMESAPROC)(GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall *PFNGLWINDOWPOS3DVARBPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLWINDOWPOS3DVMESAPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLWINDOWPOS3FARBPROC)(GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLWINDOWPOS3FMESAPROC)(GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall *PFNGLWINDOWPOS3FVARBPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLWINDOWPOS3FVMESAPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLWINDOWPOS3IARBPROC)(GLint x, GLint y, GLint z);
typedef void (__stdcall *PFNGLWINDOWPOS3IMESAPROC)(GLint x, GLint y, GLint z);
typedef void (__stdcall *PFNGLWINDOWPOS3IVARBPROC)(const GLint * v);
typedef void (__stdcall *PFNGLWINDOWPOS3IVMESAPROC)(const GLint * v);
typedef void (__stdcall *PFNGLWINDOWPOS3SARBPROC)(GLshort x, GLshort y, GLshort z);
typedef void (__stdcall *PFNGLWINDOWPOS3SMESAPROC)(GLshort x, GLshort y, GLshort z);
typedef void (__stdcall *PFNGLWINDOWPOS3SVARBPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLWINDOWPOS3SVMESAPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLWINDOWPOS4DMESAPROC)(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall *PFNGLWINDOWPOS4DVMESAPROC)(const GLdouble * v);
typedef void (__stdcall *PFNGLWINDOWPOS4FMESAPROC)(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall *PFNGLWINDOWPOS4FVMESAPROC)(const GLfloat * v);
typedef void (__stdcall *PFNGLWINDOWPOS4IMESAPROC)(GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall *PFNGLWINDOWPOS4IVMESAPROC)(const GLint * v);
typedef void (__stdcall *PFNGLWINDOWPOS4SMESAPROC)(GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall *PFNGLWINDOWPOS4SVMESAPROC)(const GLshort * v);
typedef void (__stdcall *PFNGLWINDOWRECTANGLESEXTPROC)(GLenum mode, GLsizei count, const GLint * box);
typedef void (__stdcall *PFNGLWRITEMASKEXTPROC)(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);

extern PFNGLACCUMXOESPROC glad_glAccumxOES;

extern PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC glad_glAcquireKeyedMutexWin32EXT;

extern PFNGLACTIVEPROGRAMEXTPROC glad_glActiveProgramEXT;

extern PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram;

extern PFNGLACTIVESTENCILFACEEXTPROC glad_glActiveStencilFaceEXT;

extern PFNGLACTIVETEXTUREPROC glad_glActiveTexture;

extern PFNGLACTIVETEXTUREARBPROC glad_glActiveTextureARB;

extern PFNGLACTIVEVARYINGNVPROC glad_glActiveVaryingNV;

extern PFNGLALPHAFRAGMENTOP1ATIPROC glad_glAlphaFragmentOp1ATI;

extern PFNGLALPHAFRAGMENTOP2ATIPROC glad_glAlphaFragmentOp2ATI;

extern PFNGLALPHAFRAGMENTOP3ATIPROC glad_glAlphaFragmentOp3ATI;

extern PFNGLALPHAFUNCXOESPROC glad_glAlphaFuncxOES;

extern PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC glad_glAlphaToCoverageDitherControlNV;

extern PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC glad_glApplyFramebufferAttachmentCMAAINTEL;

extern PFNGLAPPLYTEXTUREEXTPROC glad_glApplyTextureEXT;

extern PFNGLAREPROGRAMSRESIDENTNVPROC glad_glAreProgramsResidentNV;

extern PFNGLARETEXTURESRESIDENTEXTPROC glad_glAreTexturesResidentEXT;

extern PFNGLARRAYELEMENTEXTPROC glad_glArrayElementEXT;

extern PFNGLARRAYOBJECTATIPROC glad_glArrayObjectATI;

extern PFNGLASYNCCOPYBUFFERSUBDATANVXPROC glad_glAsyncCopyBufferSubDataNVX;

extern PFNGLASYNCCOPYIMAGESUBDATANVXPROC glad_glAsyncCopyImageSubDataNVX;

extern PFNGLASYNCMARKERSGIXPROC glad_glAsyncMarkerSGIX;

extern PFNGLATTACHOBJECTARBPROC glad_glAttachObjectARB;

extern PFNGLATTACHSHADERPROC glad_glAttachShader;

extern PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender;

extern PFNGLBEGINCONDITIONALRENDERNVPROC glad_glBeginConditionalRenderNV;

extern PFNGLBEGINCONDITIONALRENDERNVXPROC glad_glBeginConditionalRenderNVX;

extern PFNGLBEGINFRAGMENTSHADERATIPROC glad_glBeginFragmentShaderATI;

extern PFNGLBEGINOCCLUSIONQUERYNVPROC glad_glBeginOcclusionQueryNV;

extern PFNGLBEGINPERFMONITORAMDPROC glad_glBeginPerfMonitorAMD;

extern PFNGLBEGINPERFQUERYINTELPROC glad_glBeginPerfQueryINTEL;

extern PFNGLBEGINQUERYPROC glad_glBeginQuery;

extern PFNGLBEGINQUERYARBPROC glad_glBeginQueryARB;

extern PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed;

extern PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback;

extern PFNGLBEGINTRANSFORMFEEDBACKEXTPROC glad_glBeginTransformFeedbackEXT;

extern PFNGLBEGINTRANSFORMFEEDBACKNVPROC glad_glBeginTransformFeedbackNV;

extern PFNGLBEGINVERTEXSHADEREXTPROC glad_glBeginVertexShaderEXT;

extern PFNGLBEGINVIDEOCAPTURENVPROC glad_glBeginVideoCaptureNV;

extern PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation;

extern PFNGLBINDATTRIBLOCATIONARBPROC glad_glBindAttribLocationARB;

extern PFNGLBINDBUFFERPROC glad_glBindBuffer;

extern PFNGLBINDBUFFERARBPROC glad_glBindBufferARB;

extern PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase;

extern PFNGLBINDBUFFERBASEEXTPROC glad_glBindBufferBaseEXT;

extern PFNGLBINDBUFFERBASENVPROC glad_glBindBufferBaseNV;

extern PFNGLBINDBUFFEROFFSETEXTPROC glad_glBindBufferOffsetEXT;

extern PFNGLBINDBUFFEROFFSETNVPROC glad_glBindBufferOffsetNV;

extern PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange;

extern PFNGLBINDBUFFERRANGEEXTPROC glad_glBindBufferRangeEXT;

extern PFNGLBINDBUFFERRANGENVPROC glad_glBindBufferRangeNV;

extern PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase;

extern PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange;

extern PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation;

extern PFNGLBINDFRAGDATALOCATIONEXTPROC glad_glBindFragDataLocationEXT;

extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed;

extern PFNGLBINDFRAGMENTSHADERATIPROC glad_glBindFragmentShaderATI;

extern PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer;

extern PFNGLBINDFRAMEBUFFEREXTPROC glad_glBindFramebufferEXT;

extern PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture;

extern PFNGLBINDIMAGETEXTUREEXTPROC glad_glBindImageTextureEXT;

extern PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures;

extern PFNGLBINDLIGHTPARAMETEREXTPROC glad_glBindLightParameterEXT;

extern PFNGLBINDMATERIALPARAMETEREXTPROC glad_glBindMaterialParameterEXT;

extern PFNGLBINDMULTITEXTUREEXTPROC glad_glBindMultiTextureEXT;

extern PFNGLBINDPARAMETEREXTPROC glad_glBindParameterEXT;

extern PFNGLBINDPROGRAMARBPROC glad_glBindProgramARB;

extern PFNGLBINDPROGRAMNVPROC glad_glBindProgramNV;

extern PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline;

extern PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer;

extern PFNGLBINDRENDERBUFFEREXTPROC glad_glBindRenderbufferEXT;

extern PFNGLBINDSAMPLERPROC glad_glBindSampler;

extern PFNGLBINDSAMPLERSPROC glad_glBindSamplers;

extern PFNGLBINDSHADINGRATEIMAGENVPROC glad_glBindShadingRateImageNV;

extern PFNGLBINDTEXGENPARAMETEREXTPROC glad_glBindTexGenParameterEXT;

extern PFNGLBINDTEXTUREPROC glad_glBindTexture;

extern PFNGLBINDTEXTUREEXTPROC glad_glBindTextureEXT;

extern PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit;

extern PFNGLBINDTEXTUREUNITPARAMETEREXTPROC glad_glBindTextureUnitParameterEXT;

extern PFNGLBINDTEXTURESPROC glad_glBindTextures;

extern PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback;

extern PFNGLBINDTRANSFORMFEEDBACKNVPROC glad_glBindTransformFeedbackNV;

extern PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray;

extern PFNGLBINDVERTEXARRAYAPPLEPROC glad_glBindVertexArrayAPPLE;

extern PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer;

extern PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers;

extern PFNGLBINDVERTEXSHADEREXTPROC glad_glBindVertexShaderEXT;

extern PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC glad_glBindVideoCaptureStreamBufferNV;

extern PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC glad_glBindVideoCaptureStreamTextureNV;

extern PFNGLBINORMAL3BEXTPROC glad_glBinormal3bEXT;

extern PFNGLBINORMAL3BVEXTPROC glad_glBinormal3bvEXT;

extern PFNGLBINORMAL3DEXTPROC glad_glBinormal3dEXT;

extern PFNGLBINORMAL3DVEXTPROC glad_glBinormal3dvEXT;

extern PFNGLBINORMAL3FEXTPROC glad_glBinormal3fEXT;

extern PFNGLBINORMAL3FVEXTPROC glad_glBinormal3fvEXT;

extern PFNGLBINORMAL3IEXTPROC glad_glBinormal3iEXT;

extern PFNGLBINORMAL3IVEXTPROC glad_glBinormal3ivEXT;

extern PFNGLBINORMAL3SEXTPROC glad_glBinormal3sEXT;

extern PFNGLBINORMAL3SVEXTPROC glad_glBinormal3svEXT;

extern PFNGLBINORMALPOINTEREXTPROC glad_glBinormalPointerEXT;

extern PFNGLBITMAPXOESPROC glad_glBitmapxOES;

extern PFNGLBLENDBARRIERKHRPROC glad_glBlendBarrierKHR;

extern PFNGLBLENDBARRIERNVPROC glad_glBlendBarrierNV;

extern PFNGLBLENDCOLORPROC glad_glBlendColor;

extern PFNGLBLENDCOLOREXTPROC glad_glBlendColorEXT;

extern PFNGLBLENDCOLORXOESPROC glad_glBlendColorxOES;

extern PFNGLBLENDEQUATIONPROC glad_glBlendEquation;

extern PFNGLBLENDEQUATIONEXTPROC glad_glBlendEquationEXT;

extern PFNGLBLENDEQUATIONINDEXEDAMDPROC glad_glBlendEquationIndexedAMD;

extern PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate;

extern PFNGLBLENDEQUATIONSEPARATEEXTPROC glad_glBlendEquationSeparateEXT;

extern PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC glad_glBlendEquationSeparateIndexedAMD;

extern PFNGLBLENDEQUATIONSEPARATEIARBPROC glad_glBlendEquationSeparateiARB;

extern PFNGLBLENDEQUATIONIARBPROC glad_glBlendEquationiARB;

extern PFNGLBLENDFUNCPROC glad_glBlendFunc;

extern PFNGLBLENDFUNCINDEXEDAMDPROC glad_glBlendFuncIndexedAMD;

extern PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate;

extern PFNGLBLENDFUNCSEPARATEEXTPROC glad_glBlendFuncSeparateEXT;

extern PFNGLBLENDFUNCSEPARATEINGRPROC glad_glBlendFuncSeparateINGR;

extern PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC glad_glBlendFuncSeparateIndexedAMD;

extern PFNGLBLENDFUNCSEPARATEIARBPROC glad_glBlendFuncSeparateiARB;

extern PFNGLBLENDFUNCIARBPROC glad_glBlendFunciARB;

extern PFNGLBLENDPARAMETERINVPROC glad_glBlendParameteriNV;

extern PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer;

extern PFNGLBLITFRAMEBUFFEREXTPROC glad_glBlitFramebufferEXT;

extern PFNGLBLITFRAMEBUFFERLAYEREXTPROC glad_glBlitFramebufferLayerEXT;

extern PFNGLBLITFRAMEBUFFERLAYERSEXTPROC glad_glBlitFramebufferLayersEXT;

extern PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer;

extern PFNGLBUFFERADDRESSRANGENVPROC glad_glBufferAddressRangeNV;

extern PFNGLBUFFERATTACHMEMORYNVPROC glad_glBufferAttachMemoryNV;

extern PFNGLBUFFERDATAPROC glad_glBufferData;

extern PFNGLBUFFERDATAARBPROC glad_glBufferDataARB;

extern PFNGLBUFFERPAGECOMMITMENTARBPROC glad_glBufferPageCommitmentARB;

extern PFNGLBUFFERPAGECOMMITMENTMEMNVPROC glad_glBufferPageCommitmentMemNV;

extern PFNGLBUFFERPARAMETERIAPPLEPROC glad_glBufferParameteriAPPLE;

extern PFNGLBUFFERSTORAGEPROC glad_glBufferStorage;

extern PFNGLBUFFERSTORAGEEXTERNALEXTPROC glad_glBufferStorageExternalEXT;

extern PFNGLBUFFERSTORAGEMEMEXTPROC glad_glBufferStorageMemEXT;

extern PFNGLBUFFERSUBDATAPROC glad_glBufferSubData;

extern PFNGLBUFFERSUBDATAARBPROC glad_glBufferSubDataARB;

extern PFNGLCALLCOMMANDLISTNVPROC glad_glCallCommandListNV;

extern PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus;

extern PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC glad_glCheckFramebufferStatusEXT;

extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus;

extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC glad_glCheckNamedFramebufferStatusEXT;

extern PFNGLCLAMPCOLORPROC glad_glClampColor;

extern PFNGLCLAMPCOLORARBPROC glad_glClampColorARB;

extern PFNGLCLEARPROC glad_glClear;

extern PFNGLCLEARACCUMXOESPROC glad_glClearAccumxOES;

extern PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData;

extern PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData;

extern PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi;

extern PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv;

extern PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv;

extern PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv;

extern PFNGLCLEARCOLORPROC glad_glClearColor;

extern PFNGLCLEARCOLORIIEXTPROC glad_glClearColorIiEXT;

extern PFNGLCLEARCOLORIUIEXTPROC glad_glClearColorIuiEXT;

extern PFNGLCLEARCOLORXOESPROC glad_glClearColorxOES;

extern PFNGLCLEARDEPTHPROC glad_glClearDepth;

extern PFNGLCLEARDEPTHDNVPROC glad_glClearDepthdNV;

extern PFNGLCLEARDEPTHFPROC glad_glClearDepthf;

extern PFNGLCLEARDEPTHFOESPROC glad_glClearDepthfOES;

extern PFNGLCLEARDEPTHXOESPROC glad_glClearDepthxOES;

extern PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData;

extern PFNGLCLEARNAMEDBUFFERDATAEXTPROC glad_glClearNamedBufferDataEXT;

extern PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData;

extern PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC glad_glClearNamedBufferSubDataEXT;

extern PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi;

extern PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv;

extern PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv;

extern PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv;

extern PFNGLCLEARSTENCILPROC glad_glClearStencil;

extern PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage;

extern PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage;

extern PFNGLCLIENTACTIVETEXTUREARBPROC glad_glClientActiveTextureARB;

extern PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC glad_glClientActiveVertexStreamATI;

extern PFNGLCLIENTATTRIBDEFAULTEXTPROC glad_glClientAttribDefaultEXT;

extern PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC glad_glClientWaitSemaphoreui64NVX;

extern PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync;

extern PFNGLCLIPCONTROLPROC glad_glClipControl;

extern PFNGLCLIPPLANEFOESPROC glad_glClipPlanefOES;

extern PFNGLCLIPPLANEXOESPROC glad_glClipPlanexOES;

extern PFNGLCOLOR3FVERTEX3FSUNPROC glad_glColor3fVertex3fSUN;

extern PFNGLCOLOR3FVERTEX3FVSUNPROC glad_glColor3fVertex3fvSUN;

extern PFNGLCOLOR3HNVPROC glad_glColor3hNV;

extern PFNGLCOLOR3HVNVPROC glad_glColor3hvNV;

extern PFNGLCOLOR3XOESPROC glad_glColor3xOES;

extern PFNGLCOLOR3XVOESPROC glad_glColor3xvOES;

extern PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glColor4fNormal3fVertex3fSUN;

extern PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glColor4fNormal3fVertex3fvSUN;

extern PFNGLCOLOR4HNVPROC glad_glColor4hNV;

extern PFNGLCOLOR4HVNVPROC glad_glColor4hvNV;

extern PFNGLCOLOR4UBVERTEX2FSUNPROC glad_glColor4ubVertex2fSUN;

extern PFNGLCOLOR4UBVERTEX2FVSUNPROC glad_glColor4ubVertex2fvSUN;

extern PFNGLCOLOR4UBVERTEX3FSUNPROC glad_glColor4ubVertex3fSUN;

extern PFNGLCOLOR4UBVERTEX3FVSUNPROC glad_glColor4ubVertex3fvSUN;

extern PFNGLCOLOR4XOESPROC glad_glColor4xOES;

extern PFNGLCOLOR4XVOESPROC glad_glColor4xvOES;

extern PFNGLCOLORFORMATNVPROC glad_glColorFormatNV;

extern PFNGLCOLORFRAGMENTOP1ATIPROC glad_glColorFragmentOp1ATI;

extern PFNGLCOLORFRAGMENTOP2ATIPROC glad_glColorFragmentOp2ATI;

extern PFNGLCOLORFRAGMENTOP3ATIPROC glad_glColorFragmentOp3ATI;

extern PFNGLCOLORMASKPROC glad_glColorMask;

extern PFNGLCOLORMASKINDEXEDEXTPROC glad_glColorMaskIndexedEXT;

extern PFNGLCOLORMASKIPROC glad_glColorMaski;

extern PFNGLCOLORPOINTEREXTPROC glad_glColorPointerEXT;

extern PFNGLCOLORPOINTERLISTIBMPROC glad_glColorPointerListIBM;

extern PFNGLCOLORPOINTERVINTELPROC glad_glColorPointervINTEL;

extern PFNGLCOLORSUBTABLEEXTPROC glad_glColorSubTableEXT;

extern PFNGLCOLORTABLEEXTPROC glad_glColorTableEXT;

extern PFNGLCOLORTABLEPARAMETERFVSGIPROC glad_glColorTableParameterfvSGI;

extern PFNGLCOLORTABLEPARAMETERIVSGIPROC glad_glColorTableParameterivSGI;

extern PFNGLCOLORTABLESGIPROC glad_glColorTableSGI;

extern PFNGLCOMBINERINPUTNVPROC glad_glCombinerInputNV;

extern PFNGLCOMBINEROUTPUTNVPROC glad_glCombinerOutputNV;

extern PFNGLCOMBINERPARAMETERFNVPROC glad_glCombinerParameterfNV;

extern PFNGLCOMBINERPARAMETERFVNVPROC glad_glCombinerParameterfvNV;

extern PFNGLCOMBINERPARAMETERINVPROC glad_glCombinerParameteriNV;

extern PFNGLCOMBINERPARAMETERIVNVPROC glad_glCombinerParameterivNV;

extern PFNGLCOMBINERSTAGEPARAMETERFVNVPROC glad_glCombinerStageParameterfvNV;

extern PFNGLCOMMANDLISTSEGMENTSNVPROC glad_glCommandListSegmentsNV;

extern PFNGLCOMPILECOMMANDLISTNVPROC glad_glCompileCommandListNV;

extern PFNGLCOMPILESHADERPROC glad_glCompileShader;

extern PFNGLCOMPILESHADERARBPROC glad_glCompileShaderARB;

extern PFNGLCOMPILESHADERINCLUDEARBPROC glad_glCompileShaderIncludeARB;

extern PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC glad_glCompressedMultiTexImage1DEXT;

extern PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC glad_glCompressedMultiTexImage2DEXT;

extern PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC glad_glCompressedMultiTexImage3DEXT;

extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC glad_glCompressedMultiTexSubImage1DEXT;

extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC glad_glCompressedMultiTexSubImage2DEXT;

extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC glad_glCompressedMultiTexSubImage3DEXT;

extern PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D;

extern PFNGLCOMPRESSEDTEXIMAGE1DARBPROC glad_glCompressedTexImage1DARB;

extern PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D;

extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC glad_glCompressedTexImage2DARB;

extern PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D;

extern PFNGLCOMPRESSEDTEXIMAGE3DARBPROC glad_glCompressedTexImage3DARB;

extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D;

extern PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC glad_glCompressedTexSubImage1DARB;

extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D;

extern PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC glad_glCompressedTexSubImage2DARB;

extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D;

extern PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC glad_glCompressedTexSubImage3DARB;

extern PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC glad_glCompressedTextureImage1DEXT;

extern PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC glad_glCompressedTextureImage2DEXT;

extern PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC glad_glCompressedTextureImage3DEXT;

extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D;

extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC glad_glCompressedTextureSubImage1DEXT;

extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D;

extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC glad_glCompressedTextureSubImage2DEXT;

extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D;

extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC glad_glCompressedTextureSubImage3DEXT;

extern PFNGLCONSERVATIVERASTERPARAMETERFNVPROC glad_glConservativeRasterParameterfNV;

extern PFNGLCONSERVATIVERASTERPARAMETERINVPROC glad_glConservativeRasterParameteriNV;

extern PFNGLCONVOLUTIONFILTER1DEXTPROC glad_glConvolutionFilter1DEXT;

extern PFNGLCONVOLUTIONFILTER2DEXTPROC glad_glConvolutionFilter2DEXT;

extern PFNGLCONVOLUTIONPARAMETERFEXTPROC glad_glConvolutionParameterfEXT;

extern PFNGLCONVOLUTIONPARAMETERFVEXTPROC glad_glConvolutionParameterfvEXT;

extern PFNGLCONVOLUTIONPARAMETERIEXTPROC glad_glConvolutionParameteriEXT;

extern PFNGLCONVOLUTIONPARAMETERIVEXTPROC glad_glConvolutionParameterivEXT;

extern PFNGLCONVOLUTIONPARAMETERXOESPROC glad_glConvolutionParameterxOES;

extern PFNGLCONVOLUTIONPARAMETERXVOESPROC glad_glConvolutionParameterxvOES;

extern PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData;

extern PFNGLCOPYCOLORSUBTABLEEXTPROC glad_glCopyColorSubTableEXT;

extern PFNGLCOPYCOLORTABLESGIPROC glad_glCopyColorTableSGI;

extern PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC glad_glCopyConvolutionFilter1DEXT;

extern PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC glad_glCopyConvolutionFilter2DEXT;

extern PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData;

extern PFNGLCOPYIMAGESUBDATANVPROC glad_glCopyImageSubDataNV;

extern PFNGLCOPYMULTITEXIMAGE1DEXTPROC glad_glCopyMultiTexImage1DEXT;

extern PFNGLCOPYMULTITEXIMAGE2DEXTPROC glad_glCopyMultiTexImage2DEXT;

extern PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC glad_glCopyMultiTexSubImage1DEXT;

extern PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC glad_glCopyMultiTexSubImage2DEXT;

extern PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC glad_glCopyMultiTexSubImage3DEXT;

extern PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData;

extern PFNGLCOPYPATHNVPROC glad_glCopyPathNV;

extern PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D;

extern PFNGLCOPYTEXIMAGE1DEXTPROC glad_glCopyTexImage1DEXT;

extern PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D;

extern PFNGLCOPYTEXIMAGE2DEXTPROC glad_glCopyTexImage2DEXT;

extern PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D;

extern PFNGLCOPYTEXSUBIMAGE1DEXTPROC glad_glCopyTexSubImage1DEXT;

extern PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D;

extern PFNGLCOPYTEXSUBIMAGE2DEXTPROC glad_glCopyTexSubImage2DEXT;

extern PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D;

extern PFNGLCOPYTEXSUBIMAGE3DEXTPROC glad_glCopyTexSubImage3DEXT;

extern PFNGLCOPYTEXTUREIMAGE1DEXTPROC glad_glCopyTextureImage1DEXT;

extern PFNGLCOPYTEXTUREIMAGE2DEXTPROC glad_glCopyTextureImage2DEXT;

extern PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D;

extern PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC glad_glCopyTextureSubImage1DEXT;

extern PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D;

extern PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC glad_glCopyTextureSubImage2DEXT;

extern PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D;

extern PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC glad_glCopyTextureSubImage3DEXT;

extern PFNGLCOVERFILLPATHINSTANCEDNVPROC glad_glCoverFillPathInstancedNV;

extern PFNGLCOVERFILLPATHNVPROC glad_glCoverFillPathNV;

extern PFNGLCOVERSTROKEPATHINSTANCEDNVPROC glad_glCoverStrokePathInstancedNV;

extern PFNGLCOVERSTROKEPATHNVPROC glad_glCoverStrokePathNV;

extern PFNGLCOVERAGEMODULATIONNVPROC glad_glCoverageModulationNV;

extern PFNGLCOVERAGEMODULATIONTABLENVPROC glad_glCoverageModulationTableNV;

extern PFNGLCREATEBUFFERSPROC glad_glCreateBuffers;

extern PFNGLCREATECOMMANDLISTSNVPROC glad_glCreateCommandListsNV;

extern PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers;

extern PFNGLCREATEMEMORYOBJECTSEXTPROC glad_glCreateMemoryObjectsEXT;

extern PFNGLCREATEPERFQUERYINTELPROC glad_glCreatePerfQueryINTEL;

extern PFNGLCREATEPROGRAMPROC glad_glCreateProgram;

extern PFNGLCREATEPROGRAMOBJECTARBPROC glad_glCreateProgramObjectARB;

extern PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines;

extern PFNGLCREATEPROGRESSFENCENVXPROC glad_glCreateProgressFenceNVX;

extern PFNGLCREATEQUERIESPROC glad_glCreateQueries;

extern PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers;

extern PFNGLCREATESAMPLERSPROC glad_glCreateSamplers;

extern PFNGLCREATESEMAPHORESNVPROC glad_glCreateSemaphoresNV;

extern PFNGLCREATESHADERPROC glad_glCreateShader;

extern PFNGLCREATESHADEROBJECTARBPROC glad_glCreateShaderObjectARB;

extern PFNGLCREATESHADERPROGRAMEXTPROC glad_glCreateShaderProgramEXT;

extern PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv;

extern PFNGLCREATESTATESNVPROC glad_glCreateStatesNV;

extern PFNGLCREATESYNCFROMCLEVENTARBPROC glad_glCreateSyncFromCLeventARB;

extern PFNGLCREATETEXTURESPROC glad_glCreateTextures;

extern PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks;

extern PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays;

extern PFNGLCULLFACEPROC glad_glCullFace;

extern PFNGLCULLPARAMETERDVEXTPROC glad_glCullParameterdvEXT;

extern PFNGLCULLPARAMETERFVEXTPROC glad_glCullParameterfvEXT;

extern PFNGLCURRENTPALETTEMATRIXARBPROC glad_glCurrentPaletteMatrixARB;

extern PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback;

extern PFNGLDEBUGMESSAGECALLBACKAMDPROC glad_glDebugMessageCallbackAMD;

extern PFNGLDEBUGMESSAGECALLBACKARBPROC glad_glDebugMessageCallbackARB;

extern PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl;

extern PFNGLDEBUGMESSAGECONTROLARBPROC glad_glDebugMessageControlARB;

extern PFNGLDEBUGMESSAGEENABLEAMDPROC glad_glDebugMessageEnableAMD;

extern PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert;

extern PFNGLDEBUGMESSAGEINSERTAMDPROC glad_glDebugMessageInsertAMD;

extern PFNGLDEBUGMESSAGEINSERTARBPROC glad_glDebugMessageInsertARB;

extern PFNGLDEFORMSGIXPROC glad_glDeformSGIX;

extern PFNGLDEFORMATIONMAP3DSGIXPROC glad_glDeformationMap3dSGIX;

extern PFNGLDEFORMATIONMAP3FSGIXPROC glad_glDeformationMap3fSGIX;

extern PFNGLDELETEASYNCMARKERSSGIXPROC glad_glDeleteAsyncMarkersSGIX;

extern PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers;

extern PFNGLDELETEBUFFERSARBPROC glad_glDeleteBuffersARB;

extern PFNGLDELETECOMMANDLISTSNVPROC glad_glDeleteCommandListsNV;

extern PFNGLDELETEFENCESAPPLEPROC glad_glDeleteFencesAPPLE;

extern PFNGLDELETEFENCESNVPROC glad_glDeleteFencesNV;

extern PFNGLDELETEFRAGMENTSHADERATIPROC glad_glDeleteFragmentShaderATI;

extern PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers;

extern PFNGLDELETEFRAMEBUFFERSEXTPROC glad_glDeleteFramebuffersEXT;

extern PFNGLDELETEMEMORYOBJECTSEXTPROC glad_glDeleteMemoryObjectsEXT;

extern PFNGLDELETENAMEDSTRINGARBPROC glad_glDeleteNamedStringARB;

extern PFNGLDELETENAMESAMDPROC glad_glDeleteNamesAMD;

extern PFNGLDELETEOBJECTARBPROC glad_glDeleteObjectARB;

extern PFNGLDELETEOCCLUSIONQUERIESNVPROC glad_glDeleteOcclusionQueriesNV;

extern PFNGLDELETEPATHSNVPROC glad_glDeletePathsNV;

extern PFNGLDELETEPERFMONITORSAMDPROC glad_glDeletePerfMonitorsAMD;

extern PFNGLDELETEPERFQUERYINTELPROC glad_glDeletePerfQueryINTEL;

extern PFNGLDELETEPROGRAMPROC glad_glDeleteProgram;

extern PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines;

extern PFNGLDELETEPROGRAMSARBPROC glad_glDeleteProgramsARB;

extern PFNGLDELETEPROGRAMSNVPROC glad_glDeleteProgramsNV;

extern PFNGLDELETEQUERIESPROC glad_glDeleteQueries;

extern PFNGLDELETEQUERIESARBPROC glad_glDeleteQueriesARB;

extern PFNGLDELETEQUERYRESOURCETAGNVPROC glad_glDeleteQueryResourceTagNV;

extern PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers;

extern PFNGLDELETERENDERBUFFERSEXTPROC glad_glDeleteRenderbuffersEXT;

extern PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers;

extern PFNGLDELETESEMAPHORESEXTPROC glad_glDeleteSemaphoresEXT;

extern PFNGLDELETESHADERPROC glad_glDeleteShader;

extern PFNGLDELETESTATESNVPROC glad_glDeleteStatesNV;

extern PFNGLDELETESYNCPROC glad_glDeleteSync;

extern PFNGLDELETETEXTURESPROC glad_glDeleteTextures;

extern PFNGLDELETETEXTURESEXTPROC glad_glDeleteTexturesEXT;

extern PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks;

extern PFNGLDELETETRANSFORMFEEDBACKSNVPROC glad_glDeleteTransformFeedbacksNV;

extern PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays;

extern PFNGLDELETEVERTEXARRAYSAPPLEPROC glad_glDeleteVertexArraysAPPLE;

extern PFNGLDELETEVERTEXSHADEREXTPROC glad_glDeleteVertexShaderEXT;

extern PFNGLDEPTHBOUNDSEXTPROC glad_glDepthBoundsEXT;

extern PFNGLDEPTHBOUNDSDNVPROC glad_glDepthBoundsdNV;

extern PFNGLDEPTHFUNCPROC glad_glDepthFunc;

extern PFNGLDEPTHMASKPROC glad_glDepthMask;

extern PFNGLDEPTHRANGEPROC glad_glDepthRange;

extern PFNGLDEPTHRANGEARRAYDVNVPROC glad_glDepthRangeArraydvNV;

extern PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv;

extern PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed;

extern PFNGLDEPTHRANGEINDEXEDDNVPROC glad_glDepthRangeIndexeddNV;

extern PFNGLDEPTHRANGEDNVPROC glad_glDepthRangedNV;

extern PFNGLDEPTHRANGEFPROC glad_glDepthRangef;

extern PFNGLDEPTHRANGEFOESPROC glad_glDepthRangefOES;

extern PFNGLDEPTHRANGEXOESPROC glad_glDepthRangexOES;

extern PFNGLDETACHOBJECTARBPROC glad_glDetachObjectARB;

extern PFNGLDETACHSHADERPROC glad_glDetachShader;

extern PFNGLDETAILTEXFUNCSGISPROC glad_glDetailTexFuncSGIS;

extern PFNGLDISABLEPROC glad_glDisable;

extern PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC glad_glDisableClientStateIndexedEXT;

extern PFNGLDISABLECLIENTSTATEIEXTPROC glad_glDisableClientStateiEXT;

extern PFNGLDISABLEINDEXEDEXTPROC glad_glDisableIndexedEXT;

extern PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC glad_glDisableVariantClientStateEXT;

extern PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib;

extern PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC glad_glDisableVertexArrayAttribEXT;

extern PFNGLDISABLEVERTEXARRAYEXTPROC glad_glDisableVertexArrayEXT;

extern PFNGLDISABLEVERTEXATTRIBAPPLEPROC glad_glDisableVertexAttribAPPLE;

extern PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray;

extern PFNGLDISABLEVERTEXATTRIBARRAYARBPROC glad_glDisableVertexAttribArrayARB;

extern PFNGLDISABLEIPROC glad_glDisablei;

extern PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute;

extern PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC glad_glDispatchComputeGroupSizeARB;

extern PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect;

extern PFNGLDRAWARRAYSPROC glad_glDrawArrays;

extern PFNGLDRAWARRAYSEXTPROC glad_glDrawArraysEXT;

extern PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect;

extern PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced;

extern PFNGLDRAWARRAYSINSTANCEDARBPROC glad_glDrawArraysInstancedARB;

extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance;

extern PFNGLDRAWARRAYSINSTANCEDEXTPROC glad_glDrawArraysInstancedEXT;

extern PFNGLDRAWBUFFERPROC glad_glDrawBuffer;

extern PFNGLDRAWBUFFERSPROC glad_glDrawBuffers;

extern PFNGLDRAWBUFFERSARBPROC glad_glDrawBuffersARB;

extern PFNGLDRAWBUFFERSATIPROC glad_glDrawBuffersATI;

extern PFNGLDRAWCOMMANDSADDRESSNVPROC glad_glDrawCommandsAddressNV;

extern PFNGLDRAWCOMMANDSNVPROC glad_glDrawCommandsNV;

extern PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC glad_glDrawCommandsStatesAddressNV;

extern PFNGLDRAWCOMMANDSSTATESNVPROC glad_glDrawCommandsStatesNV;

extern PFNGLDRAWELEMENTARRAYAPPLEPROC glad_glDrawElementArrayAPPLE;

extern PFNGLDRAWELEMENTARRAYATIPROC glad_glDrawElementArrayATI;

extern PFNGLDRAWELEMENTSPROC glad_glDrawElements;

extern PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex;

extern PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect;

extern PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced;

extern PFNGLDRAWELEMENTSINSTANCEDARBPROC glad_glDrawElementsInstancedARB;

extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance;

extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex;

extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance;

extern PFNGLDRAWELEMENTSINSTANCEDEXTPROC glad_glDrawElementsInstancedEXT;

extern PFNGLDRAWMESHARRAYSSUNPROC glad_glDrawMeshArraysSUN;

extern PFNGLDRAWMESHTASKSINDIRECTNVPROC glad_glDrawMeshTasksIndirectNV;

extern PFNGLDRAWMESHTASKSNVPROC glad_glDrawMeshTasksNV;

extern PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC glad_glDrawRangeElementArrayAPPLE;

extern PFNGLDRAWRANGEELEMENTARRAYATIPROC glad_glDrawRangeElementArrayATI;

extern PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements;

extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex;

extern PFNGLDRAWRANGEELEMENTSEXTPROC glad_glDrawRangeElementsEXT;

extern PFNGLDRAWTEXTURENVPROC glad_glDrawTextureNV;

extern PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback;

extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced;

extern PFNGLDRAWTRANSFORMFEEDBACKNVPROC glad_glDrawTransformFeedbackNV;

extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream;

extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced;

extern PFNGLDRAWVKIMAGENVPROC glad_glDrawVkImageNV;

extern PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC glad_glEGLImageTargetTexStorageEXT;

extern PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC glad_glEGLImageTargetTextureStorageEXT;

extern PFNGLEDGEFLAGFORMATNVPROC glad_glEdgeFlagFormatNV;

extern PFNGLEDGEFLAGPOINTEREXTPROC glad_glEdgeFlagPointerEXT;

extern PFNGLEDGEFLAGPOINTERLISTIBMPROC glad_glEdgeFlagPointerListIBM;

extern PFNGLELEMENTPOINTERAPPLEPROC glad_glElementPointerAPPLE;

extern PFNGLELEMENTPOINTERATIPROC glad_glElementPointerATI;

extern PFNGLENABLEPROC glad_glEnable;

extern PFNGLENABLECLIENTSTATEINDEXEDEXTPROC glad_glEnableClientStateIndexedEXT;

extern PFNGLENABLECLIENTSTATEIEXTPROC glad_glEnableClientStateiEXT;

extern PFNGLENABLEINDEXEDEXTPROC glad_glEnableIndexedEXT;

extern PFNGLENABLEVARIANTCLIENTSTATEEXTPROC glad_glEnableVariantClientStateEXT;

extern PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib;

extern PFNGLENABLEVERTEXARRAYATTRIBEXTPROC glad_glEnableVertexArrayAttribEXT;

extern PFNGLENABLEVERTEXARRAYEXTPROC glad_glEnableVertexArrayEXT;

extern PFNGLENABLEVERTEXATTRIBAPPLEPROC glad_glEnableVertexAttribAPPLE;

extern PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray;

extern PFNGLENABLEVERTEXATTRIBARRAYARBPROC glad_glEnableVertexAttribArrayARB;

extern PFNGLENABLEIPROC glad_glEnablei;

extern PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender;

extern PFNGLENDCONDITIONALRENDERNVPROC glad_glEndConditionalRenderNV;

extern PFNGLENDCONDITIONALRENDERNVXPROC glad_glEndConditionalRenderNVX;

extern PFNGLENDFRAGMENTSHADERATIPROC glad_glEndFragmentShaderATI;

extern PFNGLENDOCCLUSIONQUERYNVPROC glad_glEndOcclusionQueryNV;

extern PFNGLENDPERFMONITORAMDPROC glad_glEndPerfMonitorAMD;

extern PFNGLENDPERFQUERYINTELPROC glad_glEndPerfQueryINTEL;

extern PFNGLENDQUERYPROC glad_glEndQuery;

extern PFNGLENDQUERYARBPROC glad_glEndQueryARB;

extern PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed;

extern PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback;

extern PFNGLENDTRANSFORMFEEDBACKEXTPROC glad_glEndTransformFeedbackEXT;

extern PFNGLENDTRANSFORMFEEDBACKNVPROC glad_glEndTransformFeedbackNV;

extern PFNGLENDVERTEXSHADEREXTPROC glad_glEndVertexShaderEXT;

extern PFNGLENDVIDEOCAPTURENVPROC glad_glEndVideoCaptureNV;

extern PFNGLEVALCOORD1XOESPROC glad_glEvalCoord1xOES;

extern PFNGLEVALCOORD1XVOESPROC glad_glEvalCoord1xvOES;

extern PFNGLEVALCOORD2XOESPROC glad_glEvalCoord2xOES;

extern PFNGLEVALCOORD2XVOESPROC glad_glEvalCoord2xvOES;

extern PFNGLEVALMAPSNVPROC glad_glEvalMapsNV;

extern PFNGLEVALUATEDEPTHVALUESARBPROC glad_glEvaluateDepthValuesARB;

extern PFNGLEXECUTEPROGRAMNVPROC glad_glExecuteProgramNV;

extern PFNGLEXTRACTCOMPONENTEXTPROC glad_glExtractComponentEXT;

extern PFNGLFEEDBACKBUFFERXOESPROC glad_glFeedbackBufferxOES;

extern PFNGLFENCESYNCPROC glad_glFenceSync;

extern PFNGLFINALCOMBINERINPUTNVPROC glad_glFinalCombinerInputNV;

extern PFNGLFINISHPROC glad_glFinish;

extern PFNGLFINISHASYNCSGIXPROC glad_glFinishAsyncSGIX;

extern PFNGLFINISHFENCEAPPLEPROC glad_glFinishFenceAPPLE;

extern PFNGLFINISHFENCENVPROC glad_glFinishFenceNV;

extern PFNGLFINISHOBJECTAPPLEPROC glad_glFinishObjectAPPLE;

extern PFNGLFINISHTEXTURESUNXPROC glad_glFinishTextureSUNX;

extern PFNGLFLUSHPROC glad_glFlush;

extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange;

extern PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC glad_glFlushMappedBufferRangeAPPLE;

extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange;

extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC glad_glFlushMappedNamedBufferRangeEXT;

extern PFNGLFLUSHPIXELDATARANGENVPROC glad_glFlushPixelDataRangeNV;

extern PFNGLFLUSHRASTERSGIXPROC glad_glFlushRasterSGIX;

extern PFNGLFLUSHSTATICDATAIBMPROC glad_glFlushStaticDataIBM;

extern PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC glad_glFlushVertexArrayRangeAPPLE;

extern PFNGLFLUSHVERTEXARRAYRANGENVPROC glad_glFlushVertexArrayRangeNV;

extern PFNGLFOGCOORDFORMATNVPROC glad_glFogCoordFormatNV;

extern PFNGLFOGCOORDPOINTEREXTPROC glad_glFogCoordPointerEXT;

extern PFNGLFOGCOORDPOINTERLISTIBMPROC glad_glFogCoordPointerListIBM;

extern PFNGLFOGCOORDDEXTPROC glad_glFogCoorddEXT;

extern PFNGLFOGCOORDDVEXTPROC glad_glFogCoorddvEXT;

extern PFNGLFOGCOORDFEXTPROC glad_glFogCoordfEXT;

extern PFNGLFOGCOORDFVEXTPROC glad_glFogCoordfvEXT;

extern PFNGLFOGCOORDHNVPROC glad_glFogCoordhNV;

extern PFNGLFOGCOORDHVNVPROC glad_glFogCoordhvNV;

extern PFNGLFOGFUNCSGISPROC glad_glFogFuncSGIS;

extern PFNGLFOGXOESPROC glad_glFogxOES;

extern PFNGLFOGXVOESPROC glad_glFogxvOES;

extern PFNGLFRAGMENTCOLORMATERIALSGIXPROC glad_glFragmentColorMaterialSGIX;

extern PFNGLFRAGMENTCOVERAGECOLORNVPROC glad_glFragmentCoverageColorNV;

extern PFNGLFRAGMENTLIGHTMODELFSGIXPROC glad_glFragmentLightModelfSGIX;

extern PFNGLFRAGMENTLIGHTMODELFVSGIXPROC glad_glFragmentLightModelfvSGIX;

extern PFNGLFRAGMENTLIGHTMODELISGIXPROC glad_glFragmentLightModeliSGIX;

extern PFNGLFRAGMENTLIGHTMODELIVSGIXPROC glad_glFragmentLightModelivSGIX;

extern PFNGLFRAGMENTLIGHTFSGIXPROC glad_glFragmentLightfSGIX;

extern PFNGLFRAGMENTLIGHTFVSGIXPROC glad_glFragmentLightfvSGIX;

extern PFNGLFRAGMENTLIGHTISGIXPROC glad_glFragmentLightiSGIX;

extern PFNGLFRAGMENTLIGHTIVSGIXPROC glad_glFragmentLightivSGIX;

extern PFNGLFRAGMENTMATERIALFSGIXPROC glad_glFragmentMaterialfSGIX;

extern PFNGLFRAGMENTMATERIALFVSGIXPROC glad_glFragmentMaterialfvSGIX;

extern PFNGLFRAGMENTMATERIALISGIXPROC glad_glFragmentMaterialiSGIX;

extern PFNGLFRAGMENTMATERIALIVSGIXPROC glad_glFragmentMaterialivSGIX;

extern PFNGLFRAMETERMINATORGREMEDYPROC glad_glFrameTerminatorGREMEDY;

extern PFNGLFRAMEZOOMSGIXPROC glad_glFrameZoomSGIX;

extern PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC glad_glFramebufferDrawBufferEXT;

extern PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC glad_glFramebufferDrawBuffersEXT;

extern PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC glad_glFramebufferFetchBarrierEXT;

extern PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri;

extern PFNGLFRAMEBUFFERPARAMETERIMESAPROC glad_glFramebufferParameteriMESA;

extern PFNGLFRAMEBUFFERREADBUFFEREXTPROC glad_glFramebufferReadBufferEXT;

extern PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer;

extern PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC glad_glFramebufferRenderbufferEXT;

extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glFramebufferSampleLocationsfvARB;

extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glFramebufferSampleLocationsfvNV;

extern PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glFramebufferSamplePositionsfvAMD;

extern PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture;

extern PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D;

extern PFNGLFRAMEBUFFERTEXTURE1DEXTPROC glad_glFramebufferTexture1DEXT;

extern PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D;

extern PFNGLFRAMEBUFFERTEXTURE2DEXTPROC glad_glFramebufferTexture2DEXT;

extern PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D;

extern PFNGLFRAMEBUFFERTEXTURE3DEXTPROC glad_glFramebufferTexture3DEXT;

extern PFNGLFRAMEBUFFERTEXTUREARBPROC glad_glFramebufferTextureARB;

extern PFNGLFRAMEBUFFERTEXTUREEXTPROC glad_glFramebufferTextureEXT;

extern PFNGLFRAMEBUFFERTEXTUREFACEARBPROC glad_glFramebufferTextureFaceARB;

extern PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC glad_glFramebufferTextureFaceEXT;

extern PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer;

extern PFNGLFRAMEBUFFERTEXTURELAYERARBPROC glad_glFramebufferTextureLayerARB;

extern PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC glad_glFramebufferTextureLayerEXT;

extern PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC glad_glFramebufferTextureMultiviewOVR;

extern PFNGLFREEOBJECTBUFFERATIPROC glad_glFreeObjectBufferATI;

extern PFNGLFRONTFACEPROC glad_glFrontFace;

extern PFNGLFRUSTUMFOESPROC glad_glFrustumfOES;

extern PFNGLFRUSTUMXOESPROC glad_glFrustumxOES;

extern PFNGLGENASYNCMARKERSSGIXPROC glad_glGenAsyncMarkersSGIX;

extern PFNGLGENBUFFERSPROC glad_glGenBuffers;

extern PFNGLGENBUFFERSARBPROC glad_glGenBuffersARB;

extern PFNGLGENFENCESAPPLEPROC glad_glGenFencesAPPLE;

extern PFNGLGENFENCESNVPROC glad_glGenFencesNV;

extern PFNGLGENFRAGMENTSHADERSATIPROC glad_glGenFragmentShadersATI;

extern PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers;

extern PFNGLGENFRAMEBUFFERSEXTPROC glad_glGenFramebuffersEXT;

extern PFNGLGENNAMESAMDPROC glad_glGenNamesAMD;

extern PFNGLGENOCCLUSIONQUERIESNVPROC glad_glGenOcclusionQueriesNV;

extern PFNGLGENPATHSNVPROC glad_glGenPathsNV;

extern PFNGLGENPERFMONITORSAMDPROC glad_glGenPerfMonitorsAMD;

extern PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines;

extern PFNGLGENPROGRAMSARBPROC glad_glGenProgramsARB;

extern PFNGLGENPROGRAMSNVPROC glad_glGenProgramsNV;

extern PFNGLGENQUERIESPROC glad_glGenQueries;

extern PFNGLGENQUERIESARBPROC glad_glGenQueriesARB;

extern PFNGLGENQUERYRESOURCETAGNVPROC glad_glGenQueryResourceTagNV;

extern PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers;

extern PFNGLGENRENDERBUFFERSEXTPROC glad_glGenRenderbuffersEXT;

extern PFNGLGENSAMPLERSPROC glad_glGenSamplers;

extern PFNGLGENSEMAPHORESEXTPROC glad_glGenSemaphoresEXT;

extern PFNGLGENSYMBOLSEXTPROC glad_glGenSymbolsEXT;

extern PFNGLGENTEXTURESPROC glad_glGenTextures;

extern PFNGLGENTEXTURESEXTPROC glad_glGenTexturesEXT;

extern PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks;

extern PFNGLGENTRANSFORMFEEDBACKSNVPROC glad_glGenTransformFeedbacksNV;

extern PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays;

extern PFNGLGENVERTEXARRAYSAPPLEPROC glad_glGenVertexArraysAPPLE;

extern PFNGLGENVERTEXSHADERSEXTPROC glad_glGenVertexShadersEXT;

extern PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap;

extern PFNGLGENERATEMIPMAPEXTPROC glad_glGenerateMipmapEXT;

extern PFNGLGENERATEMULTITEXMIPMAPEXTPROC glad_glGenerateMultiTexMipmapEXT;

extern PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap;

extern PFNGLGENERATETEXTUREMIPMAPEXTPROC glad_glGenerateTextureMipmapEXT;

extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv;

extern PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib;

extern PFNGLGETACTIVEATTRIBARBPROC glad_glGetActiveAttribARB;

extern PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName;

extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName;

extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv;

extern PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform;

extern PFNGLGETACTIVEUNIFORMARBPROC glad_glGetActiveUniformARB;

extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName;

extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv;

extern PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName;

extern PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv;

extern PFNGLGETACTIVEVARYINGNVPROC glad_glGetActiveVaryingNV;

extern PFNGLGETARRAYOBJECTFVATIPROC glad_glGetArrayObjectfvATI;

extern PFNGLGETARRAYOBJECTIVATIPROC glad_glGetArrayObjectivATI;

extern PFNGLGETATTACHEDOBJECTSARBPROC glad_glGetAttachedObjectsARB;

extern PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders;

extern PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation;

extern PFNGLGETATTRIBLOCATIONARBPROC glad_glGetAttribLocationARB;

extern PFNGLGETBOOLEANINDEXEDVEXTPROC glad_glGetBooleanIndexedvEXT;

extern PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v;

extern PFNGLGETBOOLEANVPROC glad_glGetBooleanv;

extern PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v;

extern PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv;

extern PFNGLGETBUFFERPARAMETERIVARBPROC glad_glGetBufferParameterivARB;

extern PFNGLGETBUFFERPARAMETERUI64VNVPROC glad_glGetBufferParameterui64vNV;

extern PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv;

extern PFNGLGETBUFFERPOINTERVARBPROC glad_glGetBufferPointervARB;

extern PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData;

extern PFNGLGETBUFFERSUBDATAARBPROC glad_glGetBufferSubDataARB;

extern PFNGLGETCLIPPLANEFOESPROC glad_glGetClipPlanefOES;

extern PFNGLGETCLIPPLANEXOESPROC glad_glGetClipPlanexOES;

extern PFNGLGETCOLORTABLEEXTPROC glad_glGetColorTableEXT;

extern PFNGLGETCOLORTABLEPARAMETERFVEXTPROC glad_glGetColorTableParameterfvEXT;

extern PFNGLGETCOLORTABLEPARAMETERFVSGIPROC glad_glGetColorTableParameterfvSGI;

extern PFNGLGETCOLORTABLEPARAMETERIVEXTPROC glad_glGetColorTableParameterivEXT;

extern PFNGLGETCOLORTABLEPARAMETERIVSGIPROC glad_glGetColorTableParameterivSGI;

extern PFNGLGETCOLORTABLESGIPROC glad_glGetColorTableSGI;

extern PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC glad_glGetCombinerInputParameterfvNV;

extern PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC glad_glGetCombinerInputParameterivNV;

extern PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC glad_glGetCombinerOutputParameterfvNV;

extern PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC glad_glGetCombinerOutputParameterivNV;

extern PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC glad_glGetCombinerStageParameterfvNV;

extern PFNGLGETCOMMANDHEADERNVPROC glad_glGetCommandHeaderNV;

extern PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC glad_glGetCompressedMultiTexImageEXT;

extern PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage;

extern PFNGLGETCOMPRESSEDTEXIMAGEARBPROC glad_glGetCompressedTexImageARB;

extern PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage;

extern PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC glad_glGetCompressedTextureImageEXT;

extern PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage;

extern PFNGLGETCONVOLUTIONFILTEREXTPROC glad_glGetConvolutionFilterEXT;

extern PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC glad_glGetConvolutionParameterfvEXT;

extern PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC glad_glGetConvolutionParameterivEXT;

extern PFNGLGETCONVOLUTIONPARAMETERXVOESPROC glad_glGetConvolutionParameterxvOES;

extern PFNGLGETCOVERAGEMODULATIONTABLENVPROC glad_glGetCoverageModulationTableNV;

extern PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog;

extern PFNGLGETDEBUGMESSAGELOGAMDPROC glad_glGetDebugMessageLogAMD;

extern PFNGLGETDEBUGMESSAGELOGARBPROC glad_glGetDebugMessageLogARB;

extern PFNGLGETDETAILTEXFUNCSGISPROC glad_glGetDetailTexFuncSGIS;

extern PFNGLGETDOUBLEINDEXEDVEXTPROC glad_glGetDoubleIndexedvEXT;

extern PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v;

extern PFNGLGETDOUBLEI_VEXTPROC glad_glGetDoublei_vEXT;

extern PFNGLGETDOUBLEVPROC glad_glGetDoublev;

extern PFNGLGETERRORPROC glad_glGetError;

extern PFNGLGETFENCEIVNVPROC glad_glGetFenceivNV;

extern PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC glad_glGetFinalCombinerInputParameterfvNV;

extern PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC glad_glGetFinalCombinerInputParameterivNV;

extern PFNGLGETFIRSTPERFQUERYIDINTELPROC glad_glGetFirstPerfQueryIdINTEL;

extern PFNGLGETFIXEDVOESPROC glad_glGetFixedvOES;

extern PFNGLGETFLOATINDEXEDVEXTPROC glad_glGetFloatIndexedvEXT;

extern PFNGLGETFLOATI_VPROC glad_glGetFloati_v;

extern PFNGLGETFLOATI_VEXTPROC glad_glGetFloati_vEXT;

extern PFNGLGETFLOATVPROC glad_glGetFloatv;

extern PFNGLGETFOGFUNCSGISPROC glad_glGetFogFuncSGIS;

extern PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex;

extern PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation;

extern PFNGLGETFRAGDATALOCATIONEXTPROC glad_glGetFragDataLocationEXT;

extern PFNGLGETFRAGMENTLIGHTFVSGIXPROC glad_glGetFragmentLightfvSGIX;

extern PFNGLGETFRAGMENTLIGHTIVSGIXPROC glad_glGetFragmentLightivSGIX;

extern PFNGLGETFRAGMENTMATERIALFVSGIXPROC glad_glGetFragmentMaterialfvSGIX;

extern PFNGLGETFRAGMENTMATERIALIVSGIXPROC glad_glGetFragmentMaterialivSGIX;

extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv;

extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetFramebufferAttachmentParameterivEXT;

extern PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetFramebufferParameterfvAMD;

extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv;

extern PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetFramebufferParameterivEXT;

extern PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC glad_glGetFramebufferParameterivMESA;

extern PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus;

extern PFNGLGETGRAPHICSRESETSTATUSARBPROC glad_glGetGraphicsResetStatusARB;

extern PFNGLGETHANDLEARBPROC glad_glGetHandleARB;

extern PFNGLGETHISTOGRAMEXTPROC glad_glGetHistogramEXT;

extern PFNGLGETHISTOGRAMPARAMETERFVEXTPROC glad_glGetHistogramParameterfvEXT;

extern PFNGLGETHISTOGRAMPARAMETERIVEXTPROC glad_glGetHistogramParameterivEXT;

extern PFNGLGETHISTOGRAMPARAMETERXVOESPROC glad_glGetHistogramParameterxvOES;

extern PFNGLGETIMAGEHANDLEARBPROC glad_glGetImageHandleARB;

extern PFNGLGETIMAGEHANDLENVPROC glad_glGetImageHandleNV;

extern PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC glad_glGetImageTransformParameterfvHP;

extern PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC glad_glGetImageTransformParameterivHP;

extern PFNGLGETINFOLOGARBPROC glad_glGetInfoLogARB;

extern PFNGLGETINSTRUMENTSSGIXPROC glad_glGetInstrumentsSGIX;

extern PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v;

extern PFNGLGETINTEGER64VPROC glad_glGetInteger64v;

extern PFNGLGETINTEGERINDEXEDVEXTPROC glad_glGetIntegerIndexedvEXT;

extern PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v;

extern PFNGLGETINTEGERUI64I_VNVPROC glad_glGetIntegerui64i_vNV;

extern PFNGLGETINTEGERUI64VNVPROC glad_glGetIntegerui64vNV;

extern PFNGLGETINTEGERVPROC glad_glGetIntegerv;

extern PFNGLGETINTERNALFORMATSAMPLEIVNVPROC glad_glGetInternalformatSampleivNV;

extern PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v;

extern PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ;

extern PFNGLGETINVARIANTBOOLEANVEXTPROC glad_glGetInvariantBooleanvEXT;

extern PFNGLGETINVARIANTFLOATVEXTPROC glad_glGetInvariantFloatvEXT;

extern PFNGLGETINVARIANTINTEGERVEXTPROC glad_glGetInvariantIntegervEXT;

extern PFNGLGETLIGHTXOESPROC glad_glGetLightxOES;

extern PFNGLGETLISTPARAMETERFVSGIXPROC glad_glGetListParameterfvSGIX;

extern PFNGLGETLISTPARAMETERIVSGIXPROC glad_glGetListParameterivSGIX;

extern PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC glad_glGetLocalConstantBooleanvEXT;

extern PFNGLGETLOCALCONSTANTFLOATVEXTPROC glad_glGetLocalConstantFloatvEXT;

extern PFNGLGETLOCALCONSTANTINTEGERVEXTPROC glad_glGetLocalConstantIntegervEXT;

extern PFNGLGETMAPATTRIBPARAMETERFVNVPROC glad_glGetMapAttribParameterfvNV;

extern PFNGLGETMAPATTRIBPARAMETERIVNVPROC glad_glGetMapAttribParameterivNV;

extern PFNGLGETMAPCONTROLPOINTSNVPROC glad_glGetMapControlPointsNV;

extern PFNGLGETMAPPARAMETERFVNVPROC glad_glGetMapParameterfvNV;

extern PFNGLGETMAPPARAMETERIVNVPROC glad_glGetMapParameterivNV;

extern PFNGLGETMAPXVOESPROC glad_glGetMapxvOES;

extern PFNGLGETMATERIALXOESPROC glad_glGetMaterialxOES;

extern PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC glad_glGetMemoryObjectDetachedResourcesuivNV;

extern PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC glad_glGetMemoryObjectParameterivEXT;

extern PFNGLGETMINMAXEXTPROC glad_glGetMinmaxEXT;

extern PFNGLGETMINMAXPARAMETERFVEXTPROC glad_glGetMinmaxParameterfvEXT;

extern PFNGLGETMINMAXPARAMETERIVEXTPROC glad_glGetMinmaxParameterivEXT;

extern PFNGLGETMULTITEXENVFVEXTPROC glad_glGetMultiTexEnvfvEXT;

extern PFNGLGETMULTITEXENVIVEXTPROC glad_glGetMultiTexEnvivEXT;

extern PFNGLGETMULTITEXGENDVEXTPROC glad_glGetMultiTexGendvEXT;

extern PFNGLGETMULTITEXGENFVEXTPROC glad_glGetMultiTexGenfvEXT;

extern PFNGLGETMULTITEXGENIVEXTPROC glad_glGetMultiTexGenivEXT;

extern PFNGLGETMULTITEXIMAGEEXTPROC glad_glGetMultiTexImageEXT;

extern PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC glad_glGetMultiTexLevelParameterfvEXT;

extern PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC glad_glGetMultiTexLevelParameterivEXT;

extern PFNGLGETMULTITEXPARAMETERIIVEXTPROC glad_glGetMultiTexParameterIivEXT;

extern PFNGLGETMULTITEXPARAMETERIUIVEXTPROC glad_glGetMultiTexParameterIuivEXT;

extern PFNGLGETMULTITEXPARAMETERFVEXTPROC glad_glGetMultiTexParameterfvEXT;

extern PFNGLGETMULTITEXPARAMETERIVEXTPROC glad_glGetMultiTexParameterivEXT;

extern PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv;

extern PFNGLGETMULTISAMPLEFVNVPROC glad_glGetMultisamplefvNV;

extern PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v;

extern PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv;

extern PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC glad_glGetNamedBufferParameterivEXT;

extern PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC glad_glGetNamedBufferParameterui64vNV;

extern PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv;

extern PFNGLGETNAMEDBUFFERPOINTERVEXTPROC glad_glGetNamedBufferPointervEXT;

extern PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData;

extern PFNGLGETNAMEDBUFFERSUBDATAEXTPROC glad_glGetNamedBufferSubDataEXT;

extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv;

extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC glad_glGetNamedFramebufferAttachmentParameterivEXT;

extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC glad_glGetNamedFramebufferParameterfvAMD;

extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv;

extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC glad_glGetNamedFramebufferParameterivEXT;

extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC glad_glGetNamedProgramLocalParameterIivEXT;

extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC glad_glGetNamedProgramLocalParameterIuivEXT;

extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC glad_glGetNamedProgramLocalParameterdvEXT;

extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC glad_glGetNamedProgramLocalParameterfvEXT;

extern PFNGLGETNAMEDPROGRAMSTRINGEXTPROC glad_glGetNamedProgramStringEXT;

extern PFNGLGETNAMEDPROGRAMIVEXTPROC glad_glGetNamedProgramivEXT;

extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv;

extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC glad_glGetNamedRenderbufferParameterivEXT;

extern PFNGLGETNAMEDSTRINGARBPROC glad_glGetNamedStringARB;

extern PFNGLGETNAMEDSTRINGIVARBPROC glad_glGetNamedStringivARB;

extern PFNGLGETNEXTPERFQUERYIDINTELPROC glad_glGetNextPerfQueryIdINTEL;

extern PFNGLGETOBJECTBUFFERFVATIPROC glad_glGetObjectBufferfvATI;

extern PFNGLGETOBJECTBUFFERIVATIPROC glad_glGetObjectBufferivATI;

extern PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel;

extern PFNGLGETOBJECTLABELEXTPROC glad_glGetObjectLabelEXT;

extern PFNGLGETOBJECTPARAMETERFVARBPROC glad_glGetObjectParameterfvARB;

extern PFNGLGETOBJECTPARAMETERIVAPPLEPROC glad_glGetObjectParameterivAPPLE;

extern PFNGLGETOBJECTPARAMETERIVARBPROC glad_glGetObjectParameterivARB;

extern PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel;

extern PFNGLGETOCCLUSIONQUERYIVNVPROC glad_glGetOcclusionQueryivNV;

extern PFNGLGETOCCLUSIONQUERYUIVNVPROC glad_glGetOcclusionQueryuivNV;

extern PFNGLGETPATHCOMMANDSNVPROC glad_glGetPathCommandsNV;

extern PFNGLGETPATHCOORDSNVPROC glad_glGetPathCoordsNV;

extern PFNGLGETPATHDASHARRAYNVPROC glad_glGetPathDashArrayNV;

extern PFNGLGETPATHLENGTHNVPROC glad_glGetPathLengthNV;

extern PFNGLGETPATHMETRICRANGENVPROC glad_glGetPathMetricRangeNV;

extern PFNGLGETPATHMETRICSNVPROC glad_glGetPathMetricsNV;

extern PFNGLGETPATHPARAMETERFVNVPROC glad_glGetPathParameterfvNV;

extern PFNGLGETPATHPARAMETERIVNVPROC glad_glGetPathParameterivNV;

extern PFNGLGETPATHSPACINGNVPROC glad_glGetPathSpacingNV;

extern PFNGLGETPERFCOUNTERINFOINTELPROC glad_glGetPerfCounterInfoINTEL;

extern PFNGLGETPERFMONITORCOUNTERDATAAMDPROC glad_glGetPerfMonitorCounterDataAMD;

extern PFNGLGETPERFMONITORCOUNTERINFOAMDPROC glad_glGetPerfMonitorCounterInfoAMD;

extern PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC glad_glGetPerfMonitorCounterStringAMD;

extern PFNGLGETPERFMONITORCOUNTERSAMDPROC glad_glGetPerfMonitorCountersAMD;

extern PFNGLGETPERFMONITORGROUPSTRINGAMDPROC glad_glGetPerfMonitorGroupStringAMD;

extern PFNGLGETPERFMONITORGROUPSAMDPROC glad_glGetPerfMonitorGroupsAMD;

extern PFNGLGETPERFQUERYDATAINTELPROC glad_glGetPerfQueryDataINTEL;

extern PFNGLGETPERFQUERYIDBYNAMEINTELPROC glad_glGetPerfQueryIdByNameINTEL;

extern PFNGLGETPERFQUERYINFOINTELPROC glad_glGetPerfQueryInfoINTEL;

extern PFNGLGETPIXELMAPXVPROC glad_glGetPixelMapxv;

extern PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC glad_glGetPixelTexGenParameterfvSGIS;

extern PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC glad_glGetPixelTexGenParameterivSGIS;

extern PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC glad_glGetPixelTransformParameterfvEXT;

extern PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC glad_glGetPixelTransformParameterivEXT;

extern PFNGLGETPOINTERINDEXEDVEXTPROC glad_glGetPointerIndexedvEXT;

extern PFNGLGETPOINTERI_VEXTPROC glad_glGetPointeri_vEXT;

extern PFNGLGETPOINTERVPROC glad_glGetPointerv;

extern PFNGLGETPOINTERVEXTPROC glad_glGetPointervEXT;

extern PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary;

extern PFNGLGETPROGRAMENVPARAMETERIIVNVPROC glad_glGetProgramEnvParameterIivNV;

extern PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC glad_glGetProgramEnvParameterIuivNV;

extern PFNGLGETPROGRAMENVPARAMETERDVARBPROC glad_glGetProgramEnvParameterdvARB;

extern PFNGLGETPROGRAMENVPARAMETERFVARBPROC glad_glGetProgramEnvParameterfvARB;

extern PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog;

extern PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv;

extern PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC glad_glGetProgramLocalParameterIivNV;

extern PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC glad_glGetProgramLocalParameterIuivNV;

extern PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC glad_glGetProgramLocalParameterdvARB;

extern PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC glad_glGetProgramLocalParameterfvARB;

extern PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC glad_glGetProgramNamedParameterdvNV;

extern PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC glad_glGetProgramNamedParameterfvNV;

extern PFNGLGETPROGRAMPARAMETERDVNVPROC glad_glGetProgramParameterdvNV;

extern PFNGLGETPROGRAMPARAMETERFVNVPROC glad_glGetProgramParameterfvNV;

extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog;

extern PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv;

extern PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex;

extern PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation;

extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex;

extern PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName;

extern PFNGLGETPROGRAMRESOURCEFVNVPROC glad_glGetProgramResourcefvNV;

extern PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv;

extern PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv;

extern PFNGLGETPROGRAMSTRINGARBPROC glad_glGetProgramStringARB;

extern PFNGLGETPROGRAMSTRINGNVPROC glad_glGetProgramStringNV;

extern PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC glad_glGetProgramSubroutineParameteruivNV;

extern PFNGLGETPROGRAMIVPROC glad_glGetProgramiv;

extern PFNGLGETPROGRAMIVARBPROC glad_glGetProgramivARB;

extern PFNGLGETPROGRAMIVNVPROC glad_glGetProgramivNV;

extern PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v;

extern PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv;

extern PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v;

extern PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv;

extern PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv;

extern PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v;

extern PFNGLGETQUERYOBJECTI64VEXTPROC glad_glGetQueryObjecti64vEXT;

extern PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv;

extern PFNGLGETQUERYOBJECTIVARBPROC glad_glGetQueryObjectivARB;

extern PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v;

extern PFNGLGETQUERYOBJECTUI64VEXTPROC glad_glGetQueryObjectui64vEXT;

extern PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv;

extern PFNGLGETQUERYOBJECTUIVARBPROC glad_glGetQueryObjectuivARB;

extern PFNGLGETQUERYIVPROC glad_glGetQueryiv;

extern PFNGLGETQUERYIVARBPROC glad_glGetQueryivARB;

extern PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv;

extern PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC glad_glGetRenderbufferParameterivEXT;

extern PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv;

extern PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv;

extern PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv;

extern PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv;

extern PFNGLGETSEMAPHOREPARAMETERIVNVPROC glad_glGetSemaphoreParameterivNV;

extern PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC glad_glGetSemaphoreParameterui64vEXT;

extern PFNGLGETSEPARABLEFILTEREXTPROC glad_glGetSeparableFilterEXT;

extern PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog;

extern PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat;

extern PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource;

extern PFNGLGETSHADERSOURCEARBPROC glad_glGetShaderSourceARB;

extern PFNGLGETSHADERIVPROC glad_glGetShaderiv;

extern PFNGLGETSHADINGRATEIMAGEPALETTENVPROC glad_glGetShadingRateImagePaletteNV;

extern PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC glad_glGetShadingRateSampleLocationivNV;

extern PFNGLGETSHARPENTEXFUNCSGISPROC glad_glGetSharpenTexFuncSGIS;

extern PFNGLGETSTAGEINDEXNVPROC glad_glGetStageIndexNV;

extern PFNGLGETSTRINGPROC glad_glGetString;

extern PFNGLGETSTRINGIPROC glad_glGetStringi;

extern PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex;

extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation;

extern PFNGLGETSYNCIVPROC glad_glGetSynciv;

extern PFNGLGETTEXBUMPPARAMETERFVATIPROC glad_glGetTexBumpParameterfvATI;

extern PFNGLGETTEXBUMPPARAMETERIVATIPROC glad_glGetTexBumpParameterivATI;

extern PFNGLGETTEXENVXVOESPROC glad_glGetTexEnvxvOES;

extern PFNGLGETTEXFILTERFUNCSGISPROC glad_glGetTexFilterFuncSGIS;

extern PFNGLGETTEXGENXVOESPROC glad_glGetTexGenxvOES;

extern PFNGLGETTEXIMAGEPROC glad_glGetTexImage;

extern PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv;

extern PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv;

extern PFNGLGETTEXLEVELPARAMETERXVOESPROC glad_glGetTexLevelParameterxvOES;

extern PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv;

extern PFNGLGETTEXPARAMETERIIVEXTPROC glad_glGetTexParameterIivEXT;

extern PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv;

extern PFNGLGETTEXPARAMETERIUIVEXTPROC glad_glGetTexParameterIuivEXT;

extern PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC glad_glGetTexParameterPointervAPPLE;

extern PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv;

extern PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv;

extern PFNGLGETTEXPARAMETERXVOESPROC glad_glGetTexParameterxvOES;

extern PFNGLGETTEXTUREHANDLEARBPROC glad_glGetTextureHandleARB;

extern PFNGLGETTEXTUREHANDLENVPROC glad_glGetTextureHandleNV;

extern PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage;

extern PFNGLGETTEXTUREIMAGEEXTPROC glad_glGetTextureImageEXT;

extern PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv;

extern PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC glad_glGetTextureLevelParameterfvEXT;

extern PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv;

extern PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC glad_glGetTextureLevelParameterivEXT;

extern PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv;

extern PFNGLGETTEXTUREPARAMETERIIVEXTPROC glad_glGetTextureParameterIivEXT;

extern PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv;

extern PFNGLGETTEXTUREPARAMETERIUIVEXTPROC glad_glGetTextureParameterIuivEXT;

extern PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv;

extern PFNGLGETTEXTUREPARAMETERFVEXTPROC glad_glGetTextureParameterfvEXT;

extern PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv;

extern PFNGLGETTEXTUREPARAMETERIVEXTPROC glad_glGetTextureParameterivEXT;

extern PFNGLGETTEXTURESAMPLERHANDLEARBPROC glad_glGetTextureSamplerHandleARB;

extern PFNGLGETTEXTURESAMPLERHANDLENVPROC glad_glGetTextureSamplerHandleNV;

extern PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage;

extern PFNGLGETTRACKMATRIXIVNVPROC glad_glGetTrackMatrixivNV;

extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying;

extern PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC glad_glGetTransformFeedbackVaryingEXT;

extern PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC glad_glGetTransformFeedbackVaryingNV;

extern PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v;

extern PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v;

extern PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv;

extern PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex;

extern PFNGLGETUNIFORMBUFFERSIZEEXTPROC glad_glGetUniformBufferSizeEXT;

extern PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices;

extern PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation;

extern PFNGLGETUNIFORMLOCATIONARBPROC glad_glGetUniformLocationARB;

extern PFNGLGETUNIFORMOFFSETEXTPROC glad_glGetUniformOffsetEXT;

extern PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv;

extern PFNGLGETUNIFORMDVPROC glad_glGetUniformdv;

extern PFNGLGETUNIFORMFVPROC glad_glGetUniformfv;

extern PFNGLGETUNIFORMFVARBPROC glad_glGetUniformfvARB;

extern PFNGLGETUNIFORMI64VARBPROC glad_glGetUniformi64vARB;

extern PFNGLGETUNIFORMI64VNVPROC glad_glGetUniformi64vNV;

extern PFNGLGETUNIFORMIVPROC glad_glGetUniformiv;

extern PFNGLGETUNIFORMIVARBPROC glad_glGetUniformivARB;

extern PFNGLGETUNIFORMUI64VARBPROC glad_glGetUniformui64vARB;

extern PFNGLGETUNIFORMUI64VNVPROC glad_glGetUniformui64vNV;

extern PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv;

extern PFNGLGETUNIFORMUIVEXTPROC glad_glGetUniformuivEXT;

extern PFNGLGETUNSIGNEDBYTEI_VEXTPROC glad_glGetUnsignedBytei_vEXT;

extern PFNGLGETUNSIGNEDBYTEVEXTPROC glad_glGetUnsignedBytevEXT;

extern PFNGLGETVARIANTARRAYOBJECTFVATIPROC glad_glGetVariantArrayObjectfvATI;

extern PFNGLGETVARIANTARRAYOBJECTIVATIPROC glad_glGetVariantArrayObjectivATI;

extern PFNGLGETVARIANTBOOLEANVEXTPROC glad_glGetVariantBooleanvEXT;

extern PFNGLGETVARIANTFLOATVEXTPROC glad_glGetVariantFloatvEXT;

extern PFNGLGETVARIANTINTEGERVEXTPROC glad_glGetVariantIntegervEXT;

extern PFNGLGETVARIANTPOINTERVEXTPROC glad_glGetVariantPointervEXT;

extern PFNGLGETVARYINGLOCATIONNVPROC glad_glGetVaryingLocationNV;

extern PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv;

extern PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv;

extern PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC glad_glGetVertexArrayIntegeri_vEXT;

extern PFNGLGETVERTEXARRAYINTEGERVEXTPROC glad_glGetVertexArrayIntegervEXT;

extern PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC glad_glGetVertexArrayPointeri_vEXT;

extern PFNGLGETVERTEXARRAYPOINTERVEXTPROC glad_glGetVertexArrayPointervEXT;

extern PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv;

extern PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC glad_glGetVertexAttribArrayObjectfvATI;

extern PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC glad_glGetVertexAttribArrayObjectivATI;

extern PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv;

extern PFNGLGETVERTEXATTRIBIIVEXTPROC glad_glGetVertexAttribIivEXT;

extern PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv;

extern PFNGLGETVERTEXATTRIBIUIVEXTPROC glad_glGetVertexAttribIuivEXT;

extern PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv;

extern PFNGLGETVERTEXATTRIBLDVEXTPROC glad_glGetVertexAttribLdvEXT;

extern PFNGLGETVERTEXATTRIBLI64VNVPROC glad_glGetVertexAttribLi64vNV;

extern PFNGLGETVERTEXATTRIBLUI64VARBPROC glad_glGetVertexAttribLui64vARB;

extern PFNGLGETVERTEXATTRIBLUI64VNVPROC glad_glGetVertexAttribLui64vNV;

extern PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv;

extern PFNGLGETVERTEXATTRIBPOINTERVARBPROC glad_glGetVertexAttribPointervARB;

extern PFNGLGETVERTEXATTRIBPOINTERVNVPROC glad_glGetVertexAttribPointervNV;

extern PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv;

extern PFNGLGETVERTEXATTRIBDVARBPROC glad_glGetVertexAttribdvARB;

extern PFNGLGETVERTEXATTRIBDVNVPROC glad_glGetVertexAttribdvNV;

extern PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv;

extern PFNGLGETVERTEXATTRIBFVARBPROC glad_glGetVertexAttribfvARB;

extern PFNGLGETVERTEXATTRIBFVNVPROC glad_glGetVertexAttribfvNV;

extern PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv;

extern PFNGLGETVERTEXATTRIBIVARBPROC glad_glGetVertexAttribivARB;

extern PFNGLGETVERTEXATTRIBIVNVPROC glad_glGetVertexAttribivNV;

extern PFNGLGETVIDEOCAPTURESTREAMDVNVPROC glad_glGetVideoCaptureStreamdvNV;

extern PFNGLGETVIDEOCAPTURESTREAMFVNVPROC glad_glGetVideoCaptureStreamfvNV;

extern PFNGLGETVIDEOCAPTURESTREAMIVNVPROC glad_glGetVideoCaptureStreamivNV;

extern PFNGLGETVIDEOCAPTUREIVNVPROC glad_glGetVideoCaptureivNV;

extern PFNGLGETVIDEOI64VNVPROC glad_glGetVideoi64vNV;

extern PFNGLGETVIDEOIVNVPROC glad_glGetVideoivNV;

extern PFNGLGETVIDEOUI64VNVPROC glad_glGetVideoui64vNV;

extern PFNGLGETVIDEOUIVNVPROC glad_glGetVideouivNV;

extern PFNGLGETVKPROCADDRNVPROC glad_glGetVkProcAddrNV;

extern PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC glad_glGetnCompressedTexImageARB;

extern PFNGLGETNTEXIMAGEARBPROC glad_glGetnTexImageARB;

extern PFNGLGETNUNIFORMDVARBPROC glad_glGetnUniformdvARB;

extern PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv;

extern PFNGLGETNUNIFORMFVARBPROC glad_glGetnUniformfvARB;

extern PFNGLGETNUNIFORMI64VARBPROC glad_glGetnUniformi64vARB;

extern PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv;

extern PFNGLGETNUNIFORMIVARBPROC glad_glGetnUniformivARB;

extern PFNGLGETNUNIFORMUI64VARBPROC glad_glGetnUniformui64vARB;

extern PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv;

extern PFNGLGETNUNIFORMUIVARBPROC glad_glGetnUniformuivARB;

extern PFNGLGLOBALALPHAFACTORBSUNPROC glad_glGlobalAlphaFactorbSUN;

extern PFNGLGLOBALALPHAFACTORDSUNPROC glad_glGlobalAlphaFactordSUN;

extern PFNGLGLOBALALPHAFACTORFSUNPROC glad_glGlobalAlphaFactorfSUN;

extern PFNGLGLOBALALPHAFACTORISUNPROC glad_glGlobalAlphaFactoriSUN;

extern PFNGLGLOBALALPHAFACTORSSUNPROC glad_glGlobalAlphaFactorsSUN;

extern PFNGLGLOBALALPHAFACTORUBSUNPROC glad_glGlobalAlphaFactorubSUN;

extern PFNGLGLOBALALPHAFACTORUISUNPROC glad_glGlobalAlphaFactoruiSUN;

extern PFNGLGLOBALALPHAFACTORUSSUNPROC glad_glGlobalAlphaFactorusSUN;

extern PFNGLHINTPROC glad_glHint;

extern PFNGLHINTPGIPROC glad_glHintPGI;

extern PFNGLHISTOGRAMEXTPROC glad_glHistogramEXT;

extern PFNGLIGLOOINTERFACESGIXPROC glad_glIglooInterfaceSGIX;

extern PFNGLIMAGETRANSFORMPARAMETERFHPPROC glad_glImageTransformParameterfHP;

extern PFNGLIMAGETRANSFORMPARAMETERFVHPPROC glad_glImageTransformParameterfvHP;

extern PFNGLIMAGETRANSFORMPARAMETERIHPPROC glad_glImageTransformParameteriHP;

extern PFNGLIMAGETRANSFORMPARAMETERIVHPPROC glad_glImageTransformParameterivHP;

extern PFNGLIMPORTMEMORYFDEXTPROC glad_glImportMemoryFdEXT;

extern PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC glad_glImportMemoryWin32HandleEXT;

extern PFNGLIMPORTMEMORYWIN32NAMEEXTPROC glad_glImportMemoryWin32NameEXT;

extern PFNGLIMPORTSEMAPHOREFDEXTPROC glad_glImportSemaphoreFdEXT;

extern PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC glad_glImportSemaphoreWin32HandleEXT;

extern PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC glad_glImportSemaphoreWin32NameEXT;

extern PFNGLIMPORTSYNCEXTPROC glad_glImportSyncEXT;

extern PFNGLINDEXFORMATNVPROC glad_glIndexFormatNV;

extern PFNGLINDEXFUNCEXTPROC glad_glIndexFuncEXT;

extern PFNGLINDEXMATERIALEXTPROC glad_glIndexMaterialEXT;

extern PFNGLINDEXPOINTEREXTPROC glad_glIndexPointerEXT;

extern PFNGLINDEXPOINTERLISTIBMPROC glad_glIndexPointerListIBM;

extern PFNGLINDEXXOESPROC glad_glIndexxOES;

extern PFNGLINDEXXVOESPROC glad_glIndexxvOES;

extern PFNGLINSERTCOMPONENTEXTPROC glad_glInsertComponentEXT;

extern PFNGLINSERTEVENTMARKEREXTPROC glad_glInsertEventMarkerEXT;

extern PFNGLINSTRUMENTSBUFFERSGIXPROC glad_glInstrumentsBufferSGIX;

extern PFNGLINTERPOLATEPATHSNVPROC glad_glInterpolatePathsNV;

extern PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData;

extern PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData;

extern PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer;

extern PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData;

extern PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData;

extern PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer;

extern PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage;

extern PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage;

extern PFNGLISASYNCMARKERSGIXPROC glad_glIsAsyncMarkerSGIX;

extern PFNGLISBUFFERPROC glad_glIsBuffer;

extern PFNGLISBUFFERARBPROC glad_glIsBufferARB;

extern PFNGLISBUFFERRESIDENTNVPROC glad_glIsBufferResidentNV;

extern PFNGLISCOMMANDLISTNVPROC glad_glIsCommandListNV;

extern PFNGLISENABLEDPROC glad_glIsEnabled;

extern PFNGLISENABLEDINDEXEDEXTPROC glad_glIsEnabledIndexedEXT;

extern PFNGLISENABLEDIPROC glad_glIsEnabledi;

extern PFNGLISFENCEAPPLEPROC glad_glIsFenceAPPLE;

extern PFNGLISFENCENVPROC glad_glIsFenceNV;

extern PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer;

extern PFNGLISFRAMEBUFFEREXTPROC glad_glIsFramebufferEXT;

extern PFNGLISIMAGEHANDLERESIDENTARBPROC glad_glIsImageHandleResidentARB;

extern PFNGLISIMAGEHANDLERESIDENTNVPROC glad_glIsImageHandleResidentNV;

extern PFNGLISMEMORYOBJECTEXTPROC glad_glIsMemoryObjectEXT;

extern PFNGLISNAMEAMDPROC glad_glIsNameAMD;

extern PFNGLISNAMEDBUFFERRESIDENTNVPROC glad_glIsNamedBufferResidentNV;

extern PFNGLISNAMEDSTRINGARBPROC glad_glIsNamedStringARB;

extern PFNGLISOBJECTBUFFERATIPROC glad_glIsObjectBufferATI;

extern PFNGLISOCCLUSIONQUERYNVPROC glad_glIsOcclusionQueryNV;

extern PFNGLISPATHNVPROC glad_glIsPathNV;

extern PFNGLISPOINTINFILLPATHNVPROC glad_glIsPointInFillPathNV;

extern PFNGLISPOINTINSTROKEPATHNVPROC glad_glIsPointInStrokePathNV;

extern PFNGLISPROGRAMPROC glad_glIsProgram;

extern PFNGLISPROGRAMARBPROC glad_glIsProgramARB;

extern PFNGLISPROGRAMNVPROC glad_glIsProgramNV;

extern PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline;

extern PFNGLISQUERYPROC glad_glIsQuery;

extern PFNGLISQUERYARBPROC glad_glIsQueryARB;

extern PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer;

extern PFNGLISRENDERBUFFEREXTPROC glad_glIsRenderbufferEXT;

extern PFNGLISSAMPLERPROC glad_glIsSampler;

extern PFNGLISSEMAPHOREEXTPROC glad_glIsSemaphoreEXT;

extern PFNGLISSHADERPROC glad_glIsShader;

extern PFNGLISSTATENVPROC glad_glIsStateNV;

extern PFNGLISSYNCPROC glad_glIsSync;

extern PFNGLISTEXTUREPROC glad_glIsTexture;

extern PFNGLISTEXTUREEXTPROC glad_glIsTextureEXT;

extern PFNGLISTEXTUREHANDLERESIDENTARBPROC glad_glIsTextureHandleResidentARB;

extern PFNGLISTEXTUREHANDLERESIDENTNVPROC glad_glIsTextureHandleResidentNV;

extern PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback;

extern PFNGLISTRANSFORMFEEDBACKNVPROC glad_glIsTransformFeedbackNV;

extern PFNGLISVARIANTENABLEDEXTPROC glad_glIsVariantEnabledEXT;

extern PFNGLISVERTEXARRAYPROC glad_glIsVertexArray;

extern PFNGLISVERTEXARRAYAPPLEPROC glad_glIsVertexArrayAPPLE;

extern PFNGLISVERTEXATTRIBENABLEDAPPLEPROC glad_glIsVertexAttribEnabledAPPLE;

extern PFNGLLGPUCOPYIMAGESUBDATANVXPROC glad_glLGPUCopyImageSubDataNVX;

extern PFNGLLGPUINTERLOCKNVXPROC glad_glLGPUInterlockNVX;

extern PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC glad_glLGPUNamedBufferSubDataNVX;

extern PFNGLLABELOBJECTEXTPROC glad_glLabelObjectEXT;

extern PFNGLLIGHTENVISGIXPROC glad_glLightEnviSGIX;

extern PFNGLLIGHTMODELXOESPROC glad_glLightModelxOES;

extern PFNGLLIGHTMODELXVOESPROC glad_glLightModelxvOES;

extern PFNGLLIGHTXOESPROC glad_glLightxOES;

extern PFNGLLIGHTXVOESPROC glad_glLightxvOES;

extern PFNGLLINEWIDTHPROC glad_glLineWidth;

extern PFNGLLINEWIDTHXOESPROC glad_glLineWidthxOES;

extern PFNGLLINKPROGRAMPROC glad_glLinkProgram;

extern PFNGLLINKPROGRAMARBPROC glad_glLinkProgramARB;

extern PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC glad_glListDrawCommandsStatesClientNV;

extern PFNGLLISTPARAMETERFSGIXPROC glad_glListParameterfSGIX;

extern PFNGLLISTPARAMETERFVSGIXPROC glad_glListParameterfvSGIX;

extern PFNGLLISTPARAMETERISGIXPROC glad_glListParameteriSGIX;

extern PFNGLLISTPARAMETERIVSGIXPROC glad_glListParameterivSGIX;

extern PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC glad_glLoadIdentityDeformationMapSGIX;

extern PFNGLLOADMATRIXXOESPROC glad_glLoadMatrixxOES;

extern PFNGLLOADPROGRAMNVPROC glad_glLoadProgramNV;

extern PFNGLLOADTRANSPOSEMATRIXDARBPROC glad_glLoadTransposeMatrixdARB;

extern PFNGLLOADTRANSPOSEMATRIXFARBPROC glad_glLoadTransposeMatrixfARB;

extern PFNGLLOADTRANSPOSEMATRIXXOESPROC glad_glLoadTransposeMatrixxOES;

extern PFNGLLOCKARRAYSEXTPROC glad_glLockArraysEXT;

extern PFNGLLOGICOPPROC glad_glLogicOp;

extern PFNGLMAKEBUFFERNONRESIDENTNVPROC glad_glMakeBufferNonResidentNV;

extern PFNGLMAKEBUFFERRESIDENTNVPROC glad_glMakeBufferResidentNV;

extern PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC glad_glMakeImageHandleNonResidentARB;

extern PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC glad_glMakeImageHandleNonResidentNV;

extern PFNGLMAKEIMAGEHANDLERESIDENTARBPROC glad_glMakeImageHandleResidentARB;

extern PFNGLMAKEIMAGEHANDLERESIDENTNVPROC glad_glMakeImageHandleResidentNV;

extern PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC glad_glMakeNamedBufferNonResidentNV;

extern PFNGLMAKENAMEDBUFFERRESIDENTNVPROC glad_glMakeNamedBufferResidentNV;

extern PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC glad_glMakeTextureHandleNonResidentARB;

extern PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC glad_glMakeTextureHandleNonResidentNV;

extern PFNGLMAKETEXTUREHANDLERESIDENTARBPROC glad_glMakeTextureHandleResidentARB;

extern PFNGLMAKETEXTUREHANDLERESIDENTNVPROC glad_glMakeTextureHandleResidentNV;

extern PFNGLMAP1XOESPROC glad_glMap1xOES;

extern PFNGLMAP2XOESPROC glad_glMap2xOES;

extern PFNGLMAPBUFFERPROC glad_glMapBuffer;

extern PFNGLMAPBUFFERARBPROC glad_glMapBufferARB;

extern PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange;

extern PFNGLMAPCONTROLPOINTSNVPROC glad_glMapControlPointsNV;

extern PFNGLMAPGRID1XOESPROC glad_glMapGrid1xOES;

extern PFNGLMAPGRID2XOESPROC glad_glMapGrid2xOES;

extern PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer;

extern PFNGLMAPNAMEDBUFFEREXTPROC glad_glMapNamedBufferEXT;

extern PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange;

extern PFNGLMAPNAMEDBUFFERRANGEEXTPROC glad_glMapNamedBufferRangeEXT;

extern PFNGLMAPOBJECTBUFFERATIPROC glad_glMapObjectBufferATI;

extern PFNGLMAPPARAMETERFVNVPROC glad_glMapParameterfvNV;

extern PFNGLMAPPARAMETERIVNVPROC glad_glMapParameterivNV;

extern PFNGLMAPTEXTURE2DINTELPROC glad_glMapTexture2DINTEL;

extern PFNGLMAPVERTEXATTRIB1DAPPLEPROC glad_glMapVertexAttrib1dAPPLE;

extern PFNGLMAPVERTEXATTRIB1FAPPLEPROC glad_glMapVertexAttrib1fAPPLE;

extern PFNGLMAPVERTEXATTRIB2DAPPLEPROC glad_glMapVertexAttrib2dAPPLE;

extern PFNGLMAPVERTEXATTRIB2FAPPLEPROC glad_glMapVertexAttrib2fAPPLE;

extern PFNGLMATERIALXOESPROC glad_glMaterialxOES;

extern PFNGLMATERIALXVOESPROC glad_glMaterialxvOES;

extern PFNGLMATRIXFRUSTUMEXTPROC glad_glMatrixFrustumEXT;

extern PFNGLMATRIXINDEXPOINTERARBPROC glad_glMatrixIndexPointerARB;

extern PFNGLMATRIXINDEXUBVARBPROC glad_glMatrixIndexubvARB;

extern PFNGLMATRIXINDEXUIVARBPROC glad_glMatrixIndexuivARB;

extern PFNGLMATRIXINDEXUSVARBPROC glad_glMatrixIndexusvARB;

extern PFNGLMATRIXLOAD3X2FNVPROC glad_glMatrixLoad3x2fNV;

extern PFNGLMATRIXLOAD3X3FNVPROC glad_glMatrixLoad3x3fNV;

extern PFNGLMATRIXLOADIDENTITYEXTPROC glad_glMatrixLoadIdentityEXT;

extern PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC glad_glMatrixLoadTranspose3x3fNV;

extern PFNGLMATRIXLOADTRANSPOSEDEXTPROC glad_glMatrixLoadTransposedEXT;

extern PFNGLMATRIXLOADTRANSPOSEFEXTPROC glad_glMatrixLoadTransposefEXT;

extern PFNGLMATRIXLOADDEXTPROC glad_glMatrixLoaddEXT;

extern PFNGLMATRIXLOADFEXTPROC glad_glMatrixLoadfEXT;

extern PFNGLMATRIXMULT3X2FNVPROC glad_glMatrixMult3x2fNV;

extern PFNGLMATRIXMULT3X3FNVPROC glad_glMatrixMult3x3fNV;

extern PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC glad_glMatrixMultTranspose3x3fNV;

extern PFNGLMATRIXMULTTRANSPOSEDEXTPROC glad_glMatrixMultTransposedEXT;

extern PFNGLMATRIXMULTTRANSPOSEFEXTPROC glad_glMatrixMultTransposefEXT;

extern PFNGLMATRIXMULTDEXTPROC glad_glMatrixMultdEXT;

extern PFNGLMATRIXMULTFEXTPROC glad_glMatrixMultfEXT;

extern PFNGLMATRIXORTHOEXTPROC glad_glMatrixOrthoEXT;

extern PFNGLMATRIXPOPEXTPROC glad_glMatrixPopEXT;

extern PFNGLMATRIXPUSHEXTPROC glad_glMatrixPushEXT;

extern PFNGLMATRIXROTATEDEXTPROC glad_glMatrixRotatedEXT;

extern PFNGLMATRIXROTATEFEXTPROC glad_glMatrixRotatefEXT;

extern PFNGLMATRIXSCALEDEXTPROC glad_glMatrixScaledEXT;

extern PFNGLMATRIXSCALEFEXTPROC glad_glMatrixScalefEXT;

extern PFNGLMATRIXTRANSLATEDEXTPROC glad_glMatrixTranslatedEXT;

extern PFNGLMATRIXTRANSLATEFEXTPROC glad_glMatrixTranslatefEXT;

extern PFNGLMAXSHADERCOMPILERTHREADSARBPROC glad_glMaxShaderCompilerThreadsARB;

extern PFNGLMAXSHADERCOMPILERTHREADSKHRPROC glad_glMaxShaderCompilerThreadsKHR;

extern PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier;

extern PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion;

extern PFNGLMEMORYBARRIEREXTPROC glad_glMemoryBarrierEXT;

extern PFNGLMEMORYOBJECTPARAMETERIVEXTPROC glad_glMemoryObjectParameterivEXT;

extern PFNGLMINSAMPLESHADINGARBPROC glad_glMinSampleShadingARB;

extern PFNGLMINMAXEXTPROC glad_glMinmaxEXT;

extern PFNGLMULTMATRIXXOESPROC glad_glMultMatrixxOES;

extern PFNGLMULTTRANSPOSEMATRIXDARBPROC glad_glMultTransposeMatrixdARB;

extern PFNGLMULTTRANSPOSEMATRIXFARBPROC glad_glMultTransposeMatrixfARB;

extern PFNGLMULTTRANSPOSEMATRIXXOESPROC glad_glMultTransposeMatrixxOES;

extern PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays;

extern PFNGLMULTIDRAWARRAYSEXTPROC glad_glMultiDrawArraysEXT;

extern PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect;

extern PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC glad_glMultiDrawArraysIndirectAMD;

extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawArraysIndirectBindlessCountNV;

extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC glad_glMultiDrawArraysIndirectBindlessNV;

extern PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC glad_glMultiDrawArraysIndirectCountARB;

extern PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC glad_glMultiDrawElementArrayAPPLE;

extern PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements;

extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex;

extern PFNGLMULTIDRAWELEMENTSEXTPROC glad_glMultiDrawElementsEXT;

extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect;

extern PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC glad_glMultiDrawElementsIndirectAMD;

extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC glad_glMultiDrawElementsIndirectBindlessCountNV;

extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC glad_glMultiDrawElementsIndirectBindlessNV;

extern PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC glad_glMultiDrawElementsIndirectCountARB;

extern PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC glad_glMultiDrawMeshTasksIndirectCountNV;

extern PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC glad_glMultiDrawMeshTasksIndirectNV;

extern PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC glad_glMultiDrawRangeElementArrayAPPLE;

extern PFNGLMULTIMODEDRAWARRAYSIBMPROC glad_glMultiModeDrawArraysIBM;

extern PFNGLMULTIMODEDRAWELEMENTSIBMPROC glad_glMultiModeDrawElementsIBM;

extern PFNGLMULTITEXBUFFEREXTPROC glad_glMultiTexBufferEXT;

extern PFNGLMULTITEXCOORD1BOESPROC glad_glMultiTexCoord1bOES;

extern PFNGLMULTITEXCOORD1BVOESPROC glad_glMultiTexCoord1bvOES;

extern PFNGLMULTITEXCOORD1DARBPROC glad_glMultiTexCoord1dARB;

extern PFNGLMULTITEXCOORD1DVARBPROC glad_glMultiTexCoord1dvARB;

extern PFNGLMULTITEXCOORD1FARBPROC glad_glMultiTexCoord1fARB;

extern PFNGLMULTITEXCOORD1FVARBPROC glad_glMultiTexCoord1fvARB;

extern PFNGLMULTITEXCOORD1HNVPROC glad_glMultiTexCoord1hNV;

extern PFNGLMULTITEXCOORD1HVNVPROC glad_glMultiTexCoord1hvNV;

extern PFNGLMULTITEXCOORD1IARBPROC glad_glMultiTexCoord1iARB;

extern PFNGLMULTITEXCOORD1IVARBPROC glad_glMultiTexCoord1ivARB;

extern PFNGLMULTITEXCOORD1SARBPROC glad_glMultiTexCoord1sARB;

extern PFNGLMULTITEXCOORD1SVARBPROC glad_glMultiTexCoord1svARB;

extern PFNGLMULTITEXCOORD1XOESPROC glad_glMultiTexCoord1xOES;

extern PFNGLMULTITEXCOORD1XVOESPROC glad_glMultiTexCoord1xvOES;

extern PFNGLMULTITEXCOORD2BOESPROC glad_glMultiTexCoord2bOES;

extern PFNGLMULTITEXCOORD2BVOESPROC glad_glMultiTexCoord2bvOES;

extern PFNGLMULTITEXCOORD2DARBPROC glad_glMultiTexCoord2dARB;

extern PFNGLMULTITEXCOORD2DVARBPROC glad_glMultiTexCoord2dvARB;

extern PFNGLMULTITEXCOORD2FARBPROC glad_glMultiTexCoord2fARB;

extern PFNGLMULTITEXCOORD2FVARBPROC glad_glMultiTexCoord2fvARB;

extern PFNGLMULTITEXCOORD2HNVPROC glad_glMultiTexCoord2hNV;

extern PFNGLMULTITEXCOORD2HVNVPROC glad_glMultiTexCoord2hvNV;

extern PFNGLMULTITEXCOORD2IARBPROC glad_glMultiTexCoord2iARB;

extern PFNGLMULTITEXCOORD2IVARBPROC glad_glMultiTexCoord2ivARB;

extern PFNGLMULTITEXCOORD2SARBPROC glad_glMultiTexCoord2sARB;

extern PFNGLMULTITEXCOORD2SVARBPROC glad_glMultiTexCoord2svARB;

extern PFNGLMULTITEXCOORD2XOESPROC glad_glMultiTexCoord2xOES;

extern PFNGLMULTITEXCOORD2XVOESPROC glad_glMultiTexCoord2xvOES;

extern PFNGLMULTITEXCOORD3BOESPROC glad_glMultiTexCoord3bOES;

extern PFNGLMULTITEXCOORD3BVOESPROC glad_glMultiTexCoord3bvOES;

extern PFNGLMULTITEXCOORD3DARBPROC glad_glMultiTexCoord3dARB;

extern PFNGLMULTITEXCOORD3DVARBPROC glad_glMultiTexCoord3dvARB;

extern PFNGLMULTITEXCOORD3FARBPROC glad_glMultiTexCoord3fARB;

extern PFNGLMULTITEXCOORD3FVARBPROC glad_glMultiTexCoord3fvARB;

extern PFNGLMULTITEXCOORD3HNVPROC glad_glMultiTexCoord3hNV;

extern PFNGLMULTITEXCOORD3HVNVPROC glad_glMultiTexCoord3hvNV;

extern PFNGLMULTITEXCOORD3IARBPROC glad_glMultiTexCoord3iARB;

extern PFNGLMULTITEXCOORD3IVARBPROC glad_glMultiTexCoord3ivARB;

extern PFNGLMULTITEXCOORD3SARBPROC glad_glMultiTexCoord3sARB;

extern PFNGLMULTITEXCOORD3SVARBPROC glad_glMultiTexCoord3svARB;

extern PFNGLMULTITEXCOORD3XOESPROC glad_glMultiTexCoord3xOES;

extern PFNGLMULTITEXCOORD3XVOESPROC glad_glMultiTexCoord3xvOES;

extern PFNGLMULTITEXCOORD4BOESPROC glad_glMultiTexCoord4bOES;

extern PFNGLMULTITEXCOORD4BVOESPROC glad_glMultiTexCoord4bvOES;

extern PFNGLMULTITEXCOORD4DARBPROC glad_glMultiTexCoord4dARB;

extern PFNGLMULTITEXCOORD4DVARBPROC glad_glMultiTexCoord4dvARB;

extern PFNGLMULTITEXCOORD4FARBPROC glad_glMultiTexCoord4fARB;

extern PFNGLMULTITEXCOORD4FVARBPROC glad_glMultiTexCoord4fvARB;

extern PFNGLMULTITEXCOORD4HNVPROC glad_glMultiTexCoord4hNV;

extern PFNGLMULTITEXCOORD4HVNVPROC glad_glMultiTexCoord4hvNV;

extern PFNGLMULTITEXCOORD4IARBPROC glad_glMultiTexCoord4iARB;

extern PFNGLMULTITEXCOORD4IVARBPROC glad_glMultiTexCoord4ivARB;

extern PFNGLMULTITEXCOORD4SARBPROC glad_glMultiTexCoord4sARB;

extern PFNGLMULTITEXCOORD4SVARBPROC glad_glMultiTexCoord4svARB;

extern PFNGLMULTITEXCOORD4XOESPROC glad_glMultiTexCoord4xOES;

extern PFNGLMULTITEXCOORD4XVOESPROC glad_glMultiTexCoord4xvOES;

extern PFNGLMULTITEXCOORDPOINTEREXTPROC glad_glMultiTexCoordPointerEXT;

extern PFNGLMULTITEXENVFEXTPROC glad_glMultiTexEnvfEXT;

extern PFNGLMULTITEXENVFVEXTPROC glad_glMultiTexEnvfvEXT;

extern PFNGLMULTITEXENVIEXTPROC glad_glMultiTexEnviEXT;

extern PFNGLMULTITEXENVIVEXTPROC glad_glMultiTexEnvivEXT;

extern PFNGLMULTITEXGENDEXTPROC glad_glMultiTexGendEXT;

extern PFNGLMULTITEXGENDVEXTPROC glad_glMultiTexGendvEXT;

extern PFNGLMULTITEXGENFEXTPROC glad_glMultiTexGenfEXT;

extern PFNGLMULTITEXGENFVEXTPROC glad_glMultiTexGenfvEXT;

extern PFNGLMULTITEXGENIEXTPROC glad_glMultiTexGeniEXT;

extern PFNGLMULTITEXGENIVEXTPROC glad_glMultiTexGenivEXT;

extern PFNGLMULTITEXIMAGE1DEXTPROC glad_glMultiTexImage1DEXT;

extern PFNGLMULTITEXIMAGE2DEXTPROC glad_glMultiTexImage2DEXT;

extern PFNGLMULTITEXIMAGE3DEXTPROC glad_glMultiTexImage3DEXT;

extern PFNGLMULTITEXPARAMETERIIVEXTPROC glad_glMultiTexParameterIivEXT;

extern PFNGLMULTITEXPARAMETERIUIVEXTPROC glad_glMultiTexParameterIuivEXT;

extern PFNGLMULTITEXPARAMETERFEXTPROC glad_glMultiTexParameterfEXT;

extern PFNGLMULTITEXPARAMETERFVEXTPROC glad_glMultiTexParameterfvEXT;

extern PFNGLMULTITEXPARAMETERIEXTPROC glad_glMultiTexParameteriEXT;

extern PFNGLMULTITEXPARAMETERIVEXTPROC glad_glMultiTexParameterivEXT;

extern PFNGLMULTITEXRENDERBUFFEREXTPROC glad_glMultiTexRenderbufferEXT;

extern PFNGLMULTITEXSUBIMAGE1DEXTPROC glad_glMultiTexSubImage1DEXT;

extern PFNGLMULTITEXSUBIMAGE2DEXTPROC glad_glMultiTexSubImage2DEXT;

extern PFNGLMULTITEXSUBIMAGE3DEXTPROC glad_glMultiTexSubImage3DEXT;

extern PFNGLMULTICASTBARRIERNVPROC glad_glMulticastBarrierNV;

extern PFNGLMULTICASTBLITFRAMEBUFFERNVPROC glad_glMulticastBlitFramebufferNV;

extern PFNGLMULTICASTBUFFERSUBDATANVPROC glad_glMulticastBufferSubDataNV;

extern PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC glad_glMulticastCopyBufferSubDataNV;

extern PFNGLMULTICASTCOPYIMAGESUBDATANVPROC glad_glMulticastCopyImageSubDataNV;

extern PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glMulticastFramebufferSampleLocationsfvNV;

extern PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC glad_glMulticastGetQueryObjecti64vNV;

extern PFNGLMULTICASTGETQUERYOBJECTIVNVPROC glad_glMulticastGetQueryObjectivNV;

extern PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC glad_glMulticastGetQueryObjectui64vNV;

extern PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC glad_glMulticastGetQueryObjectuivNV;

extern PFNGLMULTICASTSCISSORARRAYVNVXPROC glad_glMulticastScissorArrayvNVX;

extern PFNGLMULTICASTVIEWPORTARRAYVNVXPROC glad_glMulticastViewportArrayvNVX;

extern PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC glad_glMulticastViewportPositionWScaleNVX;

extern PFNGLMULTICASTWAITSYNCNVPROC glad_glMulticastWaitSyncNV;

extern PFNGLNAMEDBUFFERATTACHMEMORYNVPROC glad_glNamedBufferAttachMemoryNV;

extern PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData;

extern PFNGLNAMEDBUFFERDATAEXTPROC glad_glNamedBufferDataEXT;

extern PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC glad_glNamedBufferPageCommitmentARB;

extern PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC glad_glNamedBufferPageCommitmentEXT;

extern PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC glad_glNamedBufferPageCommitmentMemNV;

extern PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage;

extern PFNGLNAMEDBUFFERSTORAGEEXTPROC glad_glNamedBufferStorageEXT;

extern PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC glad_glNamedBufferStorageExternalEXT;

extern PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC glad_glNamedBufferStorageMemEXT;

extern PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData;

extern PFNGLNAMEDBUFFERSUBDATAEXTPROC glad_glNamedBufferSubDataEXT;

extern PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC glad_glNamedCopyBufferSubDataEXT;

extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer;

extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers;

extern PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri;

extern PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC glad_glNamedFramebufferParameteriEXT;

extern PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer;

extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer;

extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC glad_glNamedFramebufferRenderbufferEXT;

extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC glad_glNamedFramebufferSampleLocationsfvARB;

extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC glad_glNamedFramebufferSampleLocationsfvNV;

extern PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC glad_glNamedFramebufferSamplePositionsfvAMD;

extern PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture;

extern PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC glad_glNamedFramebufferTexture1DEXT;

extern PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC glad_glNamedFramebufferTexture2DEXT;

extern PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC glad_glNamedFramebufferTexture3DEXT;

extern PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC glad_glNamedFramebufferTextureEXT;

extern PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC glad_glNamedFramebufferTextureFaceEXT;

extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer;

extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC glad_glNamedFramebufferTextureLayerEXT;

extern PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC glad_glNamedFramebufferTextureMultiviewOVR;

extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC glad_glNamedProgramLocalParameter4dEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC glad_glNamedProgramLocalParameter4dvEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC glad_glNamedProgramLocalParameter4fEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC glad_glNamedProgramLocalParameter4fvEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC glad_glNamedProgramLocalParameterI4iEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC glad_glNamedProgramLocalParameterI4ivEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC glad_glNamedProgramLocalParameterI4uiEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC glad_glNamedProgramLocalParameterI4uivEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glNamedProgramLocalParameters4fvEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC glad_glNamedProgramLocalParametersI4ivEXT;

extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC glad_glNamedProgramLocalParametersI4uivEXT;

extern PFNGLNAMEDPROGRAMSTRINGEXTPROC glad_glNamedProgramStringEXT;

extern PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage;

extern PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC glad_glNamedRenderbufferStorageEXT;

extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample;

extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC glad_glNamedRenderbufferStorageMultisampleAdvancedAMD;

extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC glad_glNamedRenderbufferStorageMultisampleCoverageEXT;

extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glNamedRenderbufferStorageMultisampleEXT;

extern PFNGLNAMEDSTRINGARBPROC glad_glNamedStringARB;

extern PFNGLNEWOBJECTBUFFERATIPROC glad_glNewObjectBufferATI;

extern PFNGLNORMAL3FVERTEX3FSUNPROC glad_glNormal3fVertex3fSUN;

extern PFNGLNORMAL3FVERTEX3FVSUNPROC glad_glNormal3fVertex3fvSUN;

extern PFNGLNORMAL3HNVPROC glad_glNormal3hNV;

extern PFNGLNORMAL3HVNVPROC glad_glNormal3hvNV;

extern PFNGLNORMAL3XOESPROC glad_glNormal3xOES;

extern PFNGLNORMAL3XVOESPROC glad_glNormal3xvOES;

extern PFNGLNORMALFORMATNVPROC glad_glNormalFormatNV;

extern PFNGLNORMALPOINTEREXTPROC glad_glNormalPointerEXT;

extern PFNGLNORMALPOINTERLISTIBMPROC glad_glNormalPointerListIBM;

extern PFNGLNORMALPOINTERVINTELPROC glad_glNormalPointervINTEL;

extern PFNGLNORMALSTREAM3BATIPROC glad_glNormalStream3bATI;

extern PFNGLNORMALSTREAM3BVATIPROC glad_glNormalStream3bvATI;

extern PFNGLNORMALSTREAM3DATIPROC glad_glNormalStream3dATI;

extern PFNGLNORMALSTREAM3DVATIPROC glad_glNormalStream3dvATI;

extern PFNGLNORMALSTREAM3FATIPROC glad_glNormalStream3fATI;

extern PFNGLNORMALSTREAM3FVATIPROC glad_glNormalStream3fvATI;

extern PFNGLNORMALSTREAM3IATIPROC glad_glNormalStream3iATI;

extern PFNGLNORMALSTREAM3IVATIPROC glad_glNormalStream3ivATI;

extern PFNGLNORMALSTREAM3SATIPROC glad_glNormalStream3sATI;

extern PFNGLNORMALSTREAM3SVATIPROC glad_glNormalStream3svATI;

extern PFNGLOBJECTLABELPROC glad_glObjectLabel;

extern PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel;

extern PFNGLOBJECTPURGEABLEAPPLEPROC glad_glObjectPurgeableAPPLE;

extern PFNGLOBJECTUNPURGEABLEAPPLEPROC glad_glObjectUnpurgeableAPPLE;

extern PFNGLORTHOFOESPROC glad_glOrthofOES;

extern PFNGLORTHOXOESPROC glad_glOrthoxOES;

extern PFNGLPNTRIANGLESFATIPROC glad_glPNTrianglesfATI;

extern PFNGLPNTRIANGLESIATIPROC glad_glPNTrianglesiATI;

extern PFNGLPASSTEXCOORDATIPROC glad_glPassTexCoordATI;

extern PFNGLPASSTHROUGHXOESPROC glad_glPassThroughxOES;

extern PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv;

extern PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri;

extern PFNGLPATHCOMMANDSNVPROC glad_glPathCommandsNV;

extern PFNGLPATHCOORDSNVPROC glad_glPathCoordsNV;

extern PFNGLPATHCOVERDEPTHFUNCNVPROC glad_glPathCoverDepthFuncNV;

extern PFNGLPATHDASHARRAYNVPROC glad_glPathDashArrayNV;

extern PFNGLPATHGLYPHINDEXARRAYNVPROC glad_glPathGlyphIndexArrayNV;

extern PFNGLPATHGLYPHINDEXRANGENVPROC glad_glPathGlyphIndexRangeNV;

extern PFNGLPATHGLYPHRANGENVPROC glad_glPathGlyphRangeNV;

extern PFNGLPATHGLYPHSNVPROC glad_glPathGlyphsNV;

extern PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC glad_glPathMemoryGlyphIndexArrayNV;

extern PFNGLPATHPARAMETERFNVPROC glad_glPathParameterfNV;

extern PFNGLPATHPARAMETERFVNVPROC glad_glPathParameterfvNV;

extern PFNGLPATHPARAMETERINVPROC glad_glPathParameteriNV;

extern PFNGLPATHPARAMETERIVNVPROC glad_glPathParameterivNV;

extern PFNGLPATHSTENCILDEPTHOFFSETNVPROC glad_glPathStencilDepthOffsetNV;

extern PFNGLPATHSTENCILFUNCNVPROC glad_glPathStencilFuncNV;

extern PFNGLPATHSTRINGNVPROC glad_glPathStringNV;

extern PFNGLPATHSUBCOMMANDSNVPROC glad_glPathSubCommandsNV;

extern PFNGLPATHSUBCOORDSNVPROC glad_glPathSubCoordsNV;

extern PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback;

extern PFNGLPAUSETRANSFORMFEEDBACKNVPROC glad_glPauseTransformFeedbackNV;

extern PFNGLPIXELDATARANGENVPROC glad_glPixelDataRangeNV;

extern PFNGLPIXELMAPXPROC glad_glPixelMapx;

extern PFNGLPIXELSTOREFPROC glad_glPixelStoref;

extern PFNGLPIXELSTOREIPROC glad_glPixelStorei;

extern PFNGLPIXELSTOREXPROC glad_glPixelStorex;

extern PFNGLPIXELTEXGENPARAMETERFSGISPROC glad_glPixelTexGenParameterfSGIS;

extern PFNGLPIXELTEXGENPARAMETERFVSGISPROC glad_glPixelTexGenParameterfvSGIS;

extern PFNGLPIXELTEXGENPARAMETERISGISPROC glad_glPixelTexGenParameteriSGIS;

extern PFNGLPIXELTEXGENPARAMETERIVSGISPROC glad_glPixelTexGenParameterivSGIS;

extern PFNGLPIXELTEXGENSGIXPROC glad_glPixelTexGenSGIX;

extern PFNGLPIXELTRANSFERXOESPROC glad_glPixelTransferxOES;

extern PFNGLPIXELTRANSFORMPARAMETERFEXTPROC glad_glPixelTransformParameterfEXT;

extern PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC glad_glPixelTransformParameterfvEXT;

extern PFNGLPIXELTRANSFORMPARAMETERIEXTPROC glad_glPixelTransformParameteriEXT;

extern PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC glad_glPixelTransformParameterivEXT;

extern PFNGLPIXELZOOMXOESPROC glad_glPixelZoomxOES;

extern PFNGLPOINTALONGPATHNVPROC glad_glPointAlongPathNV;

extern PFNGLPOINTPARAMETERFPROC glad_glPointParameterf;

extern PFNGLPOINTPARAMETERFARBPROC glad_glPointParameterfARB;

extern PFNGLPOINTPARAMETERFEXTPROC glad_glPointParameterfEXT;

extern PFNGLPOINTPARAMETERFSGISPROC glad_glPointParameterfSGIS;

extern PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv;

extern PFNGLPOINTPARAMETERFVARBPROC glad_glPointParameterfvARB;

extern PFNGLPOINTPARAMETERFVEXTPROC glad_glPointParameterfvEXT;

extern PFNGLPOINTPARAMETERFVSGISPROC glad_glPointParameterfvSGIS;

extern PFNGLPOINTPARAMETERIPROC glad_glPointParameteri;

extern PFNGLPOINTPARAMETERINVPROC glad_glPointParameteriNV;

extern PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv;

extern PFNGLPOINTPARAMETERIVNVPROC glad_glPointParameterivNV;

extern PFNGLPOINTPARAMETERXVOESPROC glad_glPointParameterxvOES;

extern PFNGLPOINTSIZEPROC glad_glPointSize;

extern PFNGLPOINTSIZEXOESPROC glad_glPointSizexOES;

extern PFNGLPOLLASYNCSGIXPROC glad_glPollAsyncSGIX;

extern PFNGLPOLLINSTRUMENTSSGIXPROC glad_glPollInstrumentsSGIX;

extern PFNGLPOLYGONMODEPROC glad_glPolygonMode;

extern PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset;

extern PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp;

extern PFNGLPOLYGONOFFSETCLAMPEXTPROC glad_glPolygonOffsetClampEXT;

extern PFNGLPOLYGONOFFSETEXTPROC glad_glPolygonOffsetEXT;

extern PFNGLPOLYGONOFFSETXOESPROC glad_glPolygonOffsetxOES;

extern PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup;

extern PFNGLPOPGROUPMARKEREXTPROC glad_glPopGroupMarkerEXT;

extern PFNGLPRESENTFRAMEDUALFILLNVPROC glad_glPresentFrameDualFillNV;

extern PFNGLPRESENTFRAMEKEYEDNVPROC glad_glPresentFrameKeyedNV;

extern PFNGLPRIMITIVEBOUNDINGBOXARBPROC glad_glPrimitiveBoundingBoxARB;

extern PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex;

extern PFNGLPRIMITIVERESTARTINDEXNVPROC glad_glPrimitiveRestartIndexNV;

extern PFNGLPRIMITIVERESTARTNVPROC glad_glPrimitiveRestartNV;

extern PFNGLPRIORITIZETEXTURESEXTPROC glad_glPrioritizeTexturesEXT;

extern PFNGLPRIORITIZETEXTURESXOESPROC glad_glPrioritizeTexturesxOES;

extern PFNGLPROGRAMBINARYPROC glad_glProgramBinary;

extern PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC glad_glProgramBufferParametersIivNV;

extern PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC glad_glProgramBufferParametersIuivNV;

extern PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC glad_glProgramBufferParametersfvNV;

extern PFNGLPROGRAMENVPARAMETER4DARBPROC glad_glProgramEnvParameter4dARB;

extern PFNGLPROGRAMENVPARAMETER4DVARBPROC glad_glProgramEnvParameter4dvARB;

extern PFNGLPROGRAMENVPARAMETER4FARBPROC glad_glProgramEnvParameter4fARB;

extern PFNGLPROGRAMENVPARAMETER4FVARBPROC glad_glProgramEnvParameter4fvARB;

extern PFNGLPROGRAMENVPARAMETERI4INVPROC glad_glProgramEnvParameterI4iNV;

extern PFNGLPROGRAMENVPARAMETERI4IVNVPROC glad_glProgramEnvParameterI4ivNV;

extern PFNGLPROGRAMENVPARAMETERI4UINVPROC glad_glProgramEnvParameterI4uiNV;

extern PFNGLPROGRAMENVPARAMETERI4UIVNVPROC glad_glProgramEnvParameterI4uivNV;

extern PFNGLPROGRAMENVPARAMETERS4FVEXTPROC glad_glProgramEnvParameters4fvEXT;

extern PFNGLPROGRAMENVPARAMETERSI4IVNVPROC glad_glProgramEnvParametersI4ivNV;

extern PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC glad_glProgramEnvParametersI4uivNV;

extern PFNGLPROGRAMLOCALPARAMETER4DARBPROC glad_glProgramLocalParameter4dARB;

extern PFNGLPROGRAMLOCALPARAMETER4DVARBPROC glad_glProgramLocalParameter4dvARB;

extern PFNGLPROGRAMLOCALPARAMETER4FARBPROC glad_glProgramLocalParameter4fARB;

extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC glad_glProgramLocalParameter4fvARB;

extern PFNGLPROGRAMLOCALPARAMETERI4INVPROC glad_glProgramLocalParameterI4iNV;

extern PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC glad_glProgramLocalParameterI4ivNV;

extern PFNGLPROGRAMLOCALPARAMETERI4UINVPROC glad_glProgramLocalParameterI4uiNV;

extern PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC glad_glProgramLocalParameterI4uivNV;

extern PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC glad_glProgramLocalParameters4fvEXT;

extern PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC glad_glProgramLocalParametersI4ivNV;

extern PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC glad_glProgramLocalParametersI4uivNV;

extern PFNGLPROGRAMNAMEDPARAMETER4DNVPROC glad_glProgramNamedParameter4dNV;

extern PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC glad_glProgramNamedParameter4dvNV;

extern PFNGLPROGRAMNAMEDPARAMETER4FNVPROC glad_glProgramNamedParameter4fNV;

extern PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC glad_glProgramNamedParameter4fvNV;

extern PFNGLPROGRAMPARAMETER4DNVPROC glad_glProgramParameter4dNV;

extern PFNGLPROGRAMPARAMETER4DVNVPROC glad_glProgramParameter4dvNV;

extern PFNGLPROGRAMPARAMETER4FNVPROC glad_glProgramParameter4fNV;

extern PFNGLPROGRAMPARAMETER4FVNVPROC glad_glProgramParameter4fvNV;

extern PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri;

extern PFNGLPROGRAMPARAMETERIARBPROC glad_glProgramParameteriARB;

extern PFNGLPROGRAMPARAMETERIEXTPROC glad_glProgramParameteriEXT;

extern PFNGLPROGRAMPARAMETERS4DVNVPROC glad_glProgramParameters4dvNV;

extern PFNGLPROGRAMPARAMETERS4FVNVPROC glad_glProgramParameters4fvNV;

extern PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC glad_glProgramPathFragmentInputGenNV;

extern PFNGLPROGRAMSTRINGARBPROC glad_glProgramStringARB;

extern PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC glad_glProgramSubroutineParametersuivNV;

extern PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d;

extern PFNGLPROGRAMUNIFORM1DEXTPROC glad_glProgramUniform1dEXT;

extern PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv;

extern PFNGLPROGRAMUNIFORM1DVEXTPROC glad_glProgramUniform1dvEXT;

extern PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f;

extern PFNGLPROGRAMUNIFORM1FEXTPROC glad_glProgramUniform1fEXT;

extern PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv;

extern PFNGLPROGRAMUNIFORM1FVEXTPROC glad_glProgramUniform1fvEXT;

extern PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i;

extern PFNGLPROGRAMUNIFORM1I64ARBPROC glad_glProgramUniform1i64ARB;

extern PFNGLPROGRAMUNIFORM1I64NVPROC glad_glProgramUniform1i64NV;

extern PFNGLPROGRAMUNIFORM1I64VARBPROC glad_glProgramUniform1i64vARB;

extern PFNGLPROGRAMUNIFORM1I64VNVPROC glad_glProgramUniform1i64vNV;

extern PFNGLPROGRAMUNIFORM1IEXTPROC glad_glProgramUniform1iEXT;

extern PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv;

extern PFNGLPROGRAMUNIFORM1IVEXTPROC glad_glProgramUniform1ivEXT;

extern PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui;

extern PFNGLPROGRAMUNIFORM1UI64ARBPROC glad_glProgramUniform1ui64ARB;

extern PFNGLPROGRAMUNIFORM1UI64NVPROC glad_glProgramUniform1ui64NV;

extern PFNGLPROGRAMUNIFORM1UI64VARBPROC glad_glProgramUniform1ui64vARB;

extern PFNGLPROGRAMUNIFORM1UI64VNVPROC glad_glProgramUniform1ui64vNV;

extern PFNGLPROGRAMUNIFORM1UIEXTPROC glad_glProgramUniform1uiEXT;

extern PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv;

extern PFNGLPROGRAMUNIFORM1UIVEXTPROC glad_glProgramUniform1uivEXT;

extern PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d;

extern PFNGLPROGRAMUNIFORM2DEXTPROC glad_glProgramUniform2dEXT;

extern PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv;

extern PFNGLPROGRAMUNIFORM2DVEXTPROC glad_glProgramUniform2dvEXT;

extern PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f;

extern PFNGLPROGRAMUNIFORM2FEXTPROC glad_glProgramUniform2fEXT;

extern PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv;

extern PFNGLPROGRAMUNIFORM2FVEXTPROC glad_glProgramUniform2fvEXT;

extern PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i;

extern PFNGLPROGRAMUNIFORM2I64ARBPROC glad_glProgramUniform2i64ARB;

extern PFNGLPROGRAMUNIFORM2I64NVPROC glad_glProgramUniform2i64NV;

extern PFNGLPROGRAMUNIFORM2I64VARBPROC glad_glProgramUniform2i64vARB;

extern PFNGLPROGRAMUNIFORM2I64VNVPROC glad_glProgramUniform2i64vNV;

extern PFNGLPROGRAMUNIFORM2IEXTPROC glad_glProgramUniform2iEXT;

extern PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv;

extern PFNGLPROGRAMUNIFORM2IVEXTPROC glad_glProgramUniform2ivEXT;

extern PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui;

extern PFNGLPROGRAMUNIFORM2UI64ARBPROC glad_glProgramUniform2ui64ARB;

extern PFNGLPROGRAMUNIFORM2UI64NVPROC glad_glProgramUniform2ui64NV;

extern PFNGLPROGRAMUNIFORM2UI64VARBPROC glad_glProgramUniform2ui64vARB;

extern PFNGLPROGRAMUNIFORM2UI64VNVPROC glad_glProgramUniform2ui64vNV;

extern PFNGLPROGRAMUNIFORM2UIEXTPROC glad_glProgramUniform2uiEXT;

extern PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv;

extern PFNGLPROGRAMUNIFORM2UIVEXTPROC glad_glProgramUniform2uivEXT;

extern PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d;

extern PFNGLPROGRAMUNIFORM3DEXTPROC glad_glProgramUniform3dEXT;

extern PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv;

extern PFNGLPROGRAMUNIFORM3DVEXTPROC glad_glProgramUniform3dvEXT;

extern PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f;

extern PFNGLPROGRAMUNIFORM3FEXTPROC glad_glProgramUniform3fEXT;

extern PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv;

extern PFNGLPROGRAMUNIFORM3FVEXTPROC glad_glProgramUniform3fvEXT;

extern PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i;

extern PFNGLPROGRAMUNIFORM3I64ARBPROC glad_glProgramUniform3i64ARB;

extern PFNGLPROGRAMUNIFORM3I64NVPROC glad_glProgramUniform3i64NV;

extern PFNGLPROGRAMUNIFORM3I64VARBPROC glad_glProgramUniform3i64vARB;

extern PFNGLPROGRAMUNIFORM3I64VNVPROC glad_glProgramUniform3i64vNV;

extern PFNGLPROGRAMUNIFORM3IEXTPROC glad_glProgramUniform3iEXT;

extern PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv;

extern PFNGLPROGRAMUNIFORM3IVEXTPROC glad_glProgramUniform3ivEXT;

extern PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui;

extern PFNGLPROGRAMUNIFORM3UI64ARBPROC glad_glProgramUniform3ui64ARB;

extern PFNGLPROGRAMUNIFORM3UI64NVPROC glad_glProgramUniform3ui64NV;

extern PFNGLPROGRAMUNIFORM3UI64VARBPROC glad_glProgramUniform3ui64vARB;

extern PFNGLPROGRAMUNIFORM3UI64VNVPROC glad_glProgramUniform3ui64vNV;

extern PFNGLPROGRAMUNIFORM3UIEXTPROC glad_glProgramUniform3uiEXT;

extern PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv;

extern PFNGLPROGRAMUNIFORM3UIVEXTPROC glad_glProgramUniform3uivEXT;

extern PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d;

extern PFNGLPROGRAMUNIFORM4DEXTPROC glad_glProgramUniform4dEXT;

extern PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv;

extern PFNGLPROGRAMUNIFORM4DVEXTPROC glad_glProgramUniform4dvEXT;

extern PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f;

extern PFNGLPROGRAMUNIFORM4FEXTPROC glad_glProgramUniform4fEXT;

extern PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv;

extern PFNGLPROGRAMUNIFORM4FVEXTPROC glad_glProgramUniform4fvEXT;

extern PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i;

extern PFNGLPROGRAMUNIFORM4I64ARBPROC glad_glProgramUniform4i64ARB;

extern PFNGLPROGRAMUNIFORM4I64NVPROC glad_glProgramUniform4i64NV;

extern PFNGLPROGRAMUNIFORM4I64VARBPROC glad_glProgramUniform4i64vARB;

extern PFNGLPROGRAMUNIFORM4I64VNVPROC glad_glProgramUniform4i64vNV;

extern PFNGLPROGRAMUNIFORM4IEXTPROC glad_glProgramUniform4iEXT;

extern PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv;

extern PFNGLPROGRAMUNIFORM4IVEXTPROC glad_glProgramUniform4ivEXT;

extern PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui;

extern PFNGLPROGRAMUNIFORM4UI64ARBPROC glad_glProgramUniform4ui64ARB;

extern PFNGLPROGRAMUNIFORM4UI64NVPROC glad_glProgramUniform4ui64NV;

extern PFNGLPROGRAMUNIFORM4UI64VARBPROC glad_glProgramUniform4ui64vARB;

extern PFNGLPROGRAMUNIFORM4UI64VNVPROC glad_glProgramUniform4ui64vNV;

extern PFNGLPROGRAMUNIFORM4UIEXTPROC glad_glProgramUniform4uiEXT;

extern PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv;

extern PFNGLPROGRAMUNIFORM4UIVEXTPROC glad_glProgramUniform4uivEXT;

extern PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC glad_glProgramUniformHandleui64ARB;

extern PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC glad_glProgramUniformHandleui64NV;

extern PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC glad_glProgramUniformHandleui64vARB;

extern PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC glad_glProgramUniformHandleui64vNV;

extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv;

extern PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC glad_glProgramUniformMatrix2dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv;

extern PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC glad_glProgramUniformMatrix2fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv;

extern PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC glad_glProgramUniformMatrix2x3dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv;

extern PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC glad_glProgramUniformMatrix2x3fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv;

extern PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC glad_glProgramUniformMatrix2x4dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv;

extern PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC glad_glProgramUniformMatrix2x4fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv;

extern PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC glad_glProgramUniformMatrix3dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv;

extern PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC glad_glProgramUniformMatrix3fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv;

extern PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC glad_glProgramUniformMatrix3x2dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv;

extern PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC glad_glProgramUniformMatrix3x2fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv;

extern PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC glad_glProgramUniformMatrix3x4dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv;

extern PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC glad_glProgramUniformMatrix3x4fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv;

extern PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC glad_glProgramUniformMatrix4dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv;

extern PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC glad_glProgramUniformMatrix4fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv;

extern PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC glad_glProgramUniformMatrix4x2dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv;

extern PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC glad_glProgramUniformMatrix4x2fvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv;

extern PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC glad_glProgramUniformMatrix4x3dvEXT;

extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv;

extern PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC glad_glProgramUniformMatrix4x3fvEXT;

extern PFNGLPROGRAMUNIFORMUI64NVPROC glad_glProgramUniformui64NV;

extern PFNGLPROGRAMUNIFORMUI64VNVPROC glad_glProgramUniformui64vNV;

extern PFNGLPROGRAMVERTEXLIMITNVPROC glad_glProgramVertexLimitNV;

extern PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex;

extern PFNGLPROVOKINGVERTEXEXTPROC glad_glProvokingVertexEXT;

extern PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC glad_glPushClientAttribDefaultEXT;

extern PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup;

extern PFNGLPUSHGROUPMARKEREXTPROC glad_glPushGroupMarkerEXT;

extern PFNGLQUERYCOUNTERPROC glad_glQueryCounter;

extern PFNGLQUERYMATRIXXOESPROC glad_glQueryMatrixxOES;

extern PFNGLQUERYOBJECTPARAMETERUIAMDPROC glad_glQueryObjectParameteruiAMD;

extern PFNGLQUERYRESOURCENVPROC glad_glQueryResourceNV;

extern PFNGLQUERYRESOURCETAGNVPROC glad_glQueryResourceTagNV;

extern PFNGLRASTERPOS2XOESPROC glad_glRasterPos2xOES;

extern PFNGLRASTERPOS2XVOESPROC glad_glRasterPos2xvOES;

extern PFNGLRASTERPOS3XOESPROC glad_glRasterPos3xOES;

extern PFNGLRASTERPOS3XVOESPROC glad_glRasterPos3xvOES;

extern PFNGLRASTERPOS4XOESPROC glad_glRasterPos4xOES;

extern PFNGLRASTERPOS4XVOESPROC glad_glRasterPos4xvOES;

extern PFNGLRASTERSAMPLESEXTPROC glad_glRasterSamplesEXT;

extern PFNGLREADBUFFERPROC glad_glReadBuffer;

extern PFNGLREADINSTRUMENTSSGIXPROC glad_glReadInstrumentsSGIX;

extern PFNGLREADPIXELSPROC glad_glReadPixels;

extern PFNGLREADNPIXELSPROC glad_glReadnPixels;

extern PFNGLREADNPIXELSARBPROC glad_glReadnPixelsARB;

extern PFNGLRECTXOESPROC glad_glRectxOES;

extern PFNGLRECTXVOESPROC glad_glRectxvOES;

extern PFNGLREFERENCEPLANESGIXPROC glad_glReferencePlaneSGIX;

extern PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC glad_glReleaseKeyedMutexWin32EXT;

extern PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler;

extern PFNGLRENDERGPUMASKNVPROC glad_glRenderGpuMaskNV;

extern PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage;

extern PFNGLRENDERBUFFERSTORAGEEXTPROC glad_glRenderbufferStorageEXT;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC glad_glRenderbufferStorageMultisampleAdvancedAMD;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC glad_glRenderbufferStorageMultisampleCoverageNV;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC glad_glRenderbufferStorageMultisampleEXT;

extern PFNGLREPLACEMENTCODEPOINTERSUNPROC glad_glReplacementCodePointerSUN;

extern PFNGLREPLACEMENTCODEUBSUNPROC glad_glReplacementCodeubSUN;

extern PFNGLREPLACEMENTCODEUBVSUNPROC glad_glReplacementCodeubvSUN;

extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC glad_glReplacementCodeuiColor3fVertex3fSUN;

extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC glad_glReplacementCodeuiColor3fVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiColor4fNormal3fVertex3fSUN;

extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC glad_glReplacementCodeuiColor4ubVertex3fSUN;

extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC glad_glReplacementCodeuiColor4ubVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiNormal3fVertex3fSUN;

extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiNormal3fVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUISUNPROC glad_glReplacementCodeuiSUN;

extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;

extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC glad_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;

extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC glad_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC glad_glReplacementCodeuiTexCoord2fVertex3fSUN;

extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC glad_glReplacementCodeuiTexCoord2fVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC glad_glReplacementCodeuiVertex3fSUN;

extern PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC glad_glReplacementCodeuiVertex3fvSUN;

extern PFNGLREPLACEMENTCODEUIVSUNPROC glad_glReplacementCodeuivSUN;

extern PFNGLREPLACEMENTCODEUSSUNPROC glad_glReplacementCodeusSUN;

extern PFNGLREPLACEMENTCODEUSVSUNPROC glad_glReplacementCodeusvSUN;

extern PFNGLREQUESTRESIDENTPROGRAMSNVPROC glad_glRequestResidentProgramsNV;

extern PFNGLRESETHISTOGRAMEXTPROC glad_glResetHistogramEXT;

extern PFNGLRESETMEMORYOBJECTPARAMETERNVPROC glad_glResetMemoryObjectParameterNV;

extern PFNGLRESETMINMAXEXTPROC glad_glResetMinmaxEXT;

extern PFNGLRESIZEBUFFERSMESAPROC glad_glResizeBuffersMESA;

extern PFNGLRESOLVEDEPTHVALUESNVPROC glad_glResolveDepthValuesNV;

extern PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback;

extern PFNGLRESUMETRANSFORMFEEDBACKNVPROC glad_glResumeTransformFeedbackNV;

extern PFNGLROTATEXOESPROC glad_glRotatexOES;

extern PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage;

extern PFNGLSAMPLECOVERAGEARBPROC glad_glSampleCoverageARB;

extern PFNGLSAMPLEMAPATIPROC glad_glSampleMapATI;

extern PFNGLSAMPLEMASKEXTPROC glad_glSampleMaskEXT;

extern PFNGLSAMPLEMASKINDEXEDNVPROC glad_glSampleMaskIndexedNV;

extern PFNGLSAMPLEMASKSGISPROC glad_glSampleMaskSGIS;

extern PFNGLSAMPLEMASKIPROC glad_glSampleMaski;

extern PFNGLSAMPLEPATTERNEXTPROC glad_glSamplePatternEXT;

extern PFNGLSAMPLEPATTERNSGISPROC glad_glSamplePatternSGIS;

extern PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv;

extern PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv;

extern PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf;

extern PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv;

extern PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri;

extern PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv;

extern PFNGLSCALEXOESPROC glad_glScalexOES;

extern PFNGLSCISSORPROC glad_glScissor;

extern PFNGLSCISSORARRAYVPROC glad_glScissorArrayv;

extern PFNGLSCISSOREXCLUSIVEARRAYVNVPROC glad_glScissorExclusiveArrayvNV;

extern PFNGLSCISSOREXCLUSIVENVPROC glad_glScissorExclusiveNV;

extern PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed;

extern PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv;

extern PFNGLSECONDARYCOLOR3BEXTPROC glad_glSecondaryColor3bEXT;

extern PFNGLSECONDARYCOLOR3BVEXTPROC glad_glSecondaryColor3bvEXT;

extern PFNGLSECONDARYCOLOR3DEXTPROC glad_glSecondaryColor3dEXT;

extern PFNGLSECONDARYCOLOR3DVEXTPROC glad_glSecondaryColor3dvEXT;

extern PFNGLSECONDARYCOLOR3FEXTPROC glad_glSecondaryColor3fEXT;

extern PFNGLSECONDARYCOLOR3FVEXTPROC glad_glSecondaryColor3fvEXT;

extern PFNGLSECONDARYCOLOR3HNVPROC glad_glSecondaryColor3hNV;

extern PFNGLSECONDARYCOLOR3HVNVPROC glad_glSecondaryColor3hvNV;

extern PFNGLSECONDARYCOLOR3IEXTPROC glad_glSecondaryColor3iEXT;

extern PFNGLSECONDARYCOLOR3IVEXTPROC glad_glSecondaryColor3ivEXT;

extern PFNGLSECONDARYCOLOR3SEXTPROC glad_glSecondaryColor3sEXT;

extern PFNGLSECONDARYCOLOR3SVEXTPROC glad_glSecondaryColor3svEXT;

extern PFNGLSECONDARYCOLOR3UBEXTPROC glad_glSecondaryColor3ubEXT;

extern PFNGLSECONDARYCOLOR3UBVEXTPROC glad_glSecondaryColor3ubvEXT;

extern PFNGLSECONDARYCOLOR3UIEXTPROC glad_glSecondaryColor3uiEXT;

extern PFNGLSECONDARYCOLOR3UIVEXTPROC glad_glSecondaryColor3uivEXT;

extern PFNGLSECONDARYCOLOR3USEXTPROC glad_glSecondaryColor3usEXT;

extern PFNGLSECONDARYCOLOR3USVEXTPROC glad_glSecondaryColor3usvEXT;

extern PFNGLSECONDARYCOLORFORMATNVPROC glad_glSecondaryColorFormatNV;

extern PFNGLSECONDARYCOLORPOINTEREXTPROC glad_glSecondaryColorPointerEXT;

extern PFNGLSECONDARYCOLORPOINTERLISTIBMPROC glad_glSecondaryColorPointerListIBM;

extern PFNGLSELECTPERFMONITORCOUNTERSAMDPROC glad_glSelectPerfMonitorCountersAMD;

extern PFNGLSEMAPHOREPARAMETERIVNVPROC glad_glSemaphoreParameterivNV;

extern PFNGLSEMAPHOREPARAMETERUI64VEXTPROC glad_glSemaphoreParameterui64vEXT;

extern PFNGLSEPARABLEFILTER2DEXTPROC glad_glSeparableFilter2DEXT;

extern PFNGLSETFENCEAPPLEPROC glad_glSetFenceAPPLE;

extern PFNGLSETFENCENVPROC glad_glSetFenceNV;

extern PFNGLSETFRAGMENTSHADERCONSTANTATIPROC glad_glSetFragmentShaderConstantATI;

extern PFNGLSETINVARIANTEXTPROC glad_glSetInvariantEXT;

extern PFNGLSETLOCALCONSTANTEXTPROC glad_glSetLocalConstantEXT;

extern PFNGLSETMULTISAMPLEFVAMDPROC glad_glSetMultisamplefvAMD;

extern PFNGLSHADERBINARYPROC glad_glShaderBinary;

extern PFNGLSHADEROP1EXTPROC glad_glShaderOp1EXT;

extern PFNGLSHADEROP2EXTPROC glad_glShaderOp2EXT;

extern PFNGLSHADEROP3EXTPROC glad_glShaderOp3EXT;

extern PFNGLSHADERSOURCEPROC glad_glShaderSource;

extern PFNGLSHADERSOURCEARBPROC glad_glShaderSourceARB;

extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding;

extern PFNGLSHADINGRATEIMAGEBARRIERNVPROC glad_glShadingRateImageBarrierNV;

extern PFNGLSHADINGRATEIMAGEPALETTENVPROC glad_glShadingRateImagePaletteNV;

extern PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC glad_glShadingRateSampleOrderCustomNV;

extern PFNGLSHADINGRATESAMPLEORDERNVPROC glad_glShadingRateSampleOrderNV;

extern PFNGLSHARPENTEXFUNCSGISPROC glad_glSharpenTexFuncSGIS;

extern PFNGLSIGNALSEMAPHOREEXTPROC glad_glSignalSemaphoreEXT;

extern PFNGLSIGNALSEMAPHOREUI64NVXPROC glad_glSignalSemaphoreui64NVX;

extern PFNGLSIGNALVKFENCENVPROC glad_glSignalVkFenceNV;

extern PFNGLSIGNALVKSEMAPHORENVPROC glad_glSignalVkSemaphoreNV;

extern PFNGLSPECIALIZESHADERARBPROC glad_glSpecializeShaderARB;

extern PFNGLSPRITEPARAMETERFSGIXPROC glad_glSpriteParameterfSGIX;

extern PFNGLSPRITEPARAMETERFVSGIXPROC glad_glSpriteParameterfvSGIX;

extern PFNGLSPRITEPARAMETERISGIXPROC glad_glSpriteParameteriSGIX;

extern PFNGLSPRITEPARAMETERIVSGIXPROC glad_glSpriteParameterivSGIX;

extern PFNGLSTARTINSTRUMENTSSGIXPROC glad_glStartInstrumentsSGIX;

extern PFNGLSTATECAPTURENVPROC glad_glStateCaptureNV;

extern PFNGLSTENCILCLEARTAGEXTPROC glad_glStencilClearTagEXT;

extern PFNGLSTENCILFILLPATHINSTANCEDNVPROC glad_glStencilFillPathInstancedNV;

extern PFNGLSTENCILFILLPATHNVPROC glad_glStencilFillPathNV;

extern PFNGLSTENCILFUNCPROC glad_glStencilFunc;

extern PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate;

extern PFNGLSTENCILFUNCSEPARATEATIPROC glad_glStencilFuncSeparateATI;

extern PFNGLSTENCILMASKPROC glad_glStencilMask;

extern PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate;

extern PFNGLSTENCILOPPROC glad_glStencilOp;

extern PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate;

extern PFNGLSTENCILOPSEPARATEATIPROC glad_glStencilOpSeparateATI;

extern PFNGLSTENCILOPVALUEAMDPROC glad_glStencilOpValueAMD;

extern PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC glad_glStencilStrokePathInstancedNV;

extern PFNGLSTENCILSTROKEPATHNVPROC glad_glStencilStrokePathNV;

extern PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC glad_glStencilThenCoverFillPathInstancedNV;

extern PFNGLSTENCILTHENCOVERFILLPATHNVPROC glad_glStencilThenCoverFillPathNV;

extern PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC glad_glStencilThenCoverStrokePathInstancedNV;

extern PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC glad_glStencilThenCoverStrokePathNV;

extern PFNGLSTOPINSTRUMENTSSGIXPROC glad_glStopInstrumentsSGIX;

extern PFNGLSTRINGMARKERGREMEDYPROC glad_glStringMarkerGREMEDY;

extern PFNGLSUBPIXELPRECISIONBIASNVPROC glad_glSubpixelPrecisionBiasNV;

extern PFNGLSWIZZLEEXTPROC glad_glSwizzleEXT;

extern PFNGLSYNCTEXTUREINTELPROC glad_glSyncTextureINTEL;

extern PFNGLTAGSAMPLEBUFFERSGIXPROC glad_glTagSampleBufferSGIX;

extern PFNGLTANGENT3BEXTPROC glad_glTangent3bEXT;

extern PFNGLTANGENT3BVEXTPROC glad_glTangent3bvEXT;

extern PFNGLTANGENT3DEXTPROC glad_glTangent3dEXT;

extern PFNGLTANGENT3DVEXTPROC glad_glTangent3dvEXT;

extern PFNGLTANGENT3FEXTPROC glad_glTangent3fEXT;

extern PFNGLTANGENT3FVEXTPROC glad_glTangent3fvEXT;

extern PFNGLTANGENT3IEXTPROC glad_glTangent3iEXT;

extern PFNGLTANGENT3IVEXTPROC glad_glTangent3ivEXT;

extern PFNGLTANGENT3SEXTPROC glad_glTangent3sEXT;

extern PFNGLTANGENT3SVEXTPROC glad_glTangent3svEXT;

extern PFNGLTANGENTPOINTEREXTPROC glad_glTangentPointerEXT;

extern PFNGLTBUFFERMASK3DFXPROC glad_glTbufferMask3DFX;

extern PFNGLTESSELLATIONFACTORAMDPROC glad_glTessellationFactorAMD;

extern PFNGLTESSELLATIONMODEAMDPROC glad_glTessellationModeAMD;

extern PFNGLTESTFENCEAPPLEPROC glad_glTestFenceAPPLE;

extern PFNGLTESTFENCENVPROC glad_glTestFenceNV;

extern PFNGLTESTOBJECTAPPLEPROC glad_glTestObjectAPPLE;

extern PFNGLTEXATTACHMEMORYNVPROC glad_glTexAttachMemoryNV;

extern PFNGLTEXBUFFERPROC glad_glTexBuffer;

extern PFNGLTEXBUFFERARBPROC glad_glTexBufferARB;

extern PFNGLTEXBUFFEREXTPROC glad_glTexBufferEXT;

extern PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange;

extern PFNGLTEXBUMPPARAMETERFVATIPROC glad_glTexBumpParameterfvATI;

extern PFNGLTEXBUMPPARAMETERIVATIPROC glad_glTexBumpParameterivATI;

extern PFNGLTEXCOORD1BOESPROC glad_glTexCoord1bOES;

extern PFNGLTEXCOORD1BVOESPROC glad_glTexCoord1bvOES;

extern PFNGLTEXCOORD1HNVPROC glad_glTexCoord1hNV;

extern PFNGLTEXCOORD1HVNVPROC glad_glTexCoord1hvNV;

extern PFNGLTEXCOORD1XOESPROC glad_glTexCoord1xOES;

extern PFNGLTEXCOORD1XVOESPROC glad_glTexCoord1xvOES;

extern PFNGLTEXCOORD2BOESPROC glad_glTexCoord2bOES;

extern PFNGLTEXCOORD2BVOESPROC glad_glTexCoord2bvOES;

extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC glad_glTexCoord2fColor3fVertex3fSUN;

extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC glad_glTexCoord2fColor3fVertex3fvSUN;

extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC glad_glTexCoord2fColor4fNormal3fVertex3fSUN;

extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC glad_glTexCoord2fColor4fNormal3fVertex3fvSUN;

extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC glad_glTexCoord2fColor4ubVertex3fSUN;

extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC glad_glTexCoord2fColor4ubVertex3fvSUN;

extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC glad_glTexCoord2fNormal3fVertex3fSUN;

extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC glad_glTexCoord2fNormal3fVertex3fvSUN;

extern PFNGLTEXCOORD2FVERTEX3FSUNPROC glad_glTexCoord2fVertex3fSUN;

extern PFNGLTEXCOORD2FVERTEX3FVSUNPROC glad_glTexCoord2fVertex3fvSUN;

extern PFNGLTEXCOORD2HNVPROC glad_glTexCoord2hNV;

extern PFNGLTEXCOORD2HVNVPROC glad_glTexCoord2hvNV;

extern PFNGLTEXCOORD2XOESPROC glad_glTexCoord2xOES;

extern PFNGLTEXCOORD2XVOESPROC glad_glTexCoord2xvOES;

extern PFNGLTEXCOORD3BOESPROC glad_glTexCoord3bOES;

extern PFNGLTEXCOORD3BVOESPROC glad_glTexCoord3bvOES;

extern PFNGLTEXCOORD3HNVPROC glad_glTexCoord3hNV;

extern PFNGLTEXCOORD3HVNVPROC glad_glTexCoord3hvNV;

extern PFNGLTEXCOORD3XOESPROC glad_glTexCoord3xOES;

extern PFNGLTEXCOORD3XVOESPROC glad_glTexCoord3xvOES;

extern PFNGLTEXCOORD4BOESPROC glad_glTexCoord4bOES;

extern PFNGLTEXCOORD4BVOESPROC glad_glTexCoord4bvOES;

extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC glad_glTexCoord4fColor4fNormal3fVertex4fSUN;

extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC glad_glTexCoord4fColor4fNormal3fVertex4fvSUN;

extern PFNGLTEXCOORD4FVERTEX4FSUNPROC glad_glTexCoord4fVertex4fSUN;

extern PFNGLTEXCOORD4FVERTEX4FVSUNPROC glad_glTexCoord4fVertex4fvSUN;

extern PFNGLTEXCOORD4HNVPROC glad_glTexCoord4hNV;

extern PFNGLTEXCOORD4HVNVPROC glad_glTexCoord4hvNV;

extern PFNGLTEXCOORD4XOESPROC glad_glTexCoord4xOES;

extern PFNGLTEXCOORD4XVOESPROC glad_glTexCoord4xvOES;

extern PFNGLTEXCOORDFORMATNVPROC glad_glTexCoordFormatNV;

extern PFNGLTEXCOORDPOINTEREXTPROC glad_glTexCoordPointerEXT;

extern PFNGLTEXCOORDPOINTERLISTIBMPROC glad_glTexCoordPointerListIBM;

extern PFNGLTEXCOORDPOINTERVINTELPROC glad_glTexCoordPointervINTEL;

extern PFNGLTEXENVXOESPROC glad_glTexEnvxOES;

extern PFNGLTEXENVXVOESPROC glad_glTexEnvxvOES;

extern PFNGLTEXFILTERFUNCSGISPROC glad_glTexFilterFuncSGIS;

extern PFNGLTEXGENXOESPROC glad_glTexGenxOES;

extern PFNGLTEXGENXVOESPROC glad_glTexGenxvOES;

extern PFNGLTEXIMAGE1DPROC glad_glTexImage1D;

extern PFNGLTEXIMAGE2DPROC glad_glTexImage2D;

extern PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample;

extern PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTexImage2DMultisampleCoverageNV;

extern PFNGLTEXIMAGE3DPROC glad_glTexImage3D;

extern PFNGLTEXIMAGE3DEXTPROC glad_glTexImage3DEXT;

extern PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample;

extern PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTexImage3DMultisampleCoverageNV;

extern PFNGLTEXIMAGE4DSGISPROC glad_glTexImage4DSGIS;

extern PFNGLTEXPAGECOMMITMENTARBPROC glad_glTexPageCommitmentARB;

extern PFNGLTEXPAGECOMMITMENTMEMNVPROC glad_glTexPageCommitmentMemNV;

extern PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv;

extern PFNGLTEXPARAMETERIIVEXTPROC glad_glTexParameterIivEXT;

extern PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv;

extern PFNGLTEXPARAMETERIUIVEXTPROC glad_glTexParameterIuivEXT;

extern PFNGLTEXPARAMETERFPROC glad_glTexParameterf;

extern PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv;

extern PFNGLTEXPARAMETERIPROC glad_glTexParameteri;

extern PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv;

extern PFNGLTEXPARAMETERXOESPROC glad_glTexParameterxOES;

extern PFNGLTEXPARAMETERXVOESPROC glad_glTexParameterxvOES;

extern PFNGLTEXRENDERBUFFERNVPROC glad_glTexRenderbufferNV;

extern PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D;

extern PFNGLTEXSTORAGE1DEXTPROC glad_glTexStorage1DEXT;

extern PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D;

extern PFNGLTEXSTORAGE2DEXTPROC glad_glTexStorage2DEXT;

extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample;

extern PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D;

extern PFNGLTEXSTORAGE3DEXTPROC glad_glTexStorage3DEXT;

extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample;

extern PFNGLTEXSTORAGEMEM1DEXTPROC glad_glTexStorageMem1DEXT;

extern PFNGLTEXSTORAGEMEM2DEXTPROC glad_glTexStorageMem2DEXT;

extern PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTexStorageMem2DMultisampleEXT;

extern PFNGLTEXSTORAGEMEM3DEXTPROC glad_glTexStorageMem3DEXT;

extern PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTexStorageMem3DMultisampleEXT;

extern PFNGLTEXSTORAGESPARSEAMDPROC glad_glTexStorageSparseAMD;

extern PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D;

extern PFNGLTEXSUBIMAGE1DEXTPROC glad_glTexSubImage1DEXT;

extern PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D;

extern PFNGLTEXSUBIMAGE2DEXTPROC glad_glTexSubImage2DEXT;

extern PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D;

extern PFNGLTEXSUBIMAGE3DEXTPROC glad_glTexSubImage3DEXT;

extern PFNGLTEXSUBIMAGE4DSGISPROC glad_glTexSubImage4DSGIS;

extern PFNGLTEXTUREATTACHMEMORYNVPROC glad_glTextureAttachMemoryNV;

extern PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier;

extern PFNGLTEXTUREBARRIERNVPROC glad_glTextureBarrierNV;

extern PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer;

extern PFNGLTEXTUREBUFFEREXTPROC glad_glTextureBufferEXT;

extern PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange;

extern PFNGLTEXTUREBUFFERRANGEEXTPROC glad_glTextureBufferRangeEXT;

extern PFNGLTEXTURECOLORMASKSGISPROC glad_glTextureColorMaskSGIS;

extern PFNGLTEXTUREIMAGE1DEXTPROC glad_glTextureImage1DEXT;

extern PFNGLTEXTUREIMAGE2DEXTPROC glad_glTextureImage2DEXT;

extern PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC glad_glTextureImage2DMultisampleCoverageNV;

extern PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC glad_glTextureImage2DMultisampleNV;

extern PFNGLTEXTUREIMAGE3DEXTPROC glad_glTextureImage3DEXT;

extern PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC glad_glTextureImage3DMultisampleCoverageNV;

extern PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC glad_glTextureImage3DMultisampleNV;

extern PFNGLTEXTURELIGHTEXTPROC glad_glTextureLightEXT;

extern PFNGLTEXTUREMATERIALEXTPROC glad_glTextureMaterialEXT;

extern PFNGLTEXTURENORMALEXTPROC glad_glTextureNormalEXT;

extern PFNGLTEXTUREPAGECOMMITMENTEXTPROC glad_glTexturePageCommitmentEXT;

extern PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC glad_glTexturePageCommitmentMemNV;

extern PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv;

extern PFNGLTEXTUREPARAMETERIIVEXTPROC glad_glTextureParameterIivEXT;

extern PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv;

extern PFNGLTEXTUREPARAMETERIUIVEXTPROC glad_glTextureParameterIuivEXT;

extern PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf;

extern PFNGLTEXTUREPARAMETERFEXTPROC glad_glTextureParameterfEXT;

extern PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv;

extern PFNGLTEXTUREPARAMETERFVEXTPROC glad_glTextureParameterfvEXT;

extern PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri;

extern PFNGLTEXTUREPARAMETERIEXTPROC glad_glTextureParameteriEXT;

extern PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv;

extern PFNGLTEXTUREPARAMETERIVEXTPROC glad_glTextureParameterivEXT;

extern PFNGLTEXTURERANGEAPPLEPROC glad_glTextureRangeAPPLE;

extern PFNGLTEXTURERENDERBUFFEREXTPROC glad_glTextureRenderbufferEXT;

extern PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D;

extern PFNGLTEXTURESTORAGE1DEXTPROC glad_glTextureStorage1DEXT;

extern PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D;

extern PFNGLTEXTURESTORAGE2DEXTPROC glad_glTextureStorage2DEXT;

extern PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample;

extern PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC glad_glTextureStorage2DMultisampleEXT;

extern PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D;

extern PFNGLTEXTURESTORAGE3DEXTPROC glad_glTextureStorage3DEXT;

extern PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample;

extern PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC glad_glTextureStorage3DMultisampleEXT;

extern PFNGLTEXTURESTORAGEMEM1DEXTPROC glad_glTextureStorageMem1DEXT;

extern PFNGLTEXTURESTORAGEMEM2DEXTPROC glad_glTextureStorageMem2DEXT;

extern PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC glad_glTextureStorageMem2DMultisampleEXT;

extern PFNGLTEXTURESTORAGEMEM3DEXTPROC glad_glTextureStorageMem3DEXT;

extern PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC glad_glTextureStorageMem3DMultisampleEXT;

extern PFNGLTEXTURESTORAGESPARSEAMDPROC glad_glTextureStorageSparseAMD;

extern PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D;

extern PFNGLTEXTURESUBIMAGE1DEXTPROC glad_glTextureSubImage1DEXT;

extern PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D;

extern PFNGLTEXTURESUBIMAGE2DEXTPROC glad_glTextureSubImage2DEXT;

extern PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D;

extern PFNGLTEXTURESUBIMAGE3DEXTPROC glad_glTextureSubImage3DEXT;

extern PFNGLTEXTUREVIEWPROC glad_glTextureView;

extern PFNGLTRACKMATRIXNVPROC glad_glTrackMatrixNV;

extern PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC glad_glTransformFeedbackAttribsNV;

extern PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase;

extern PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange;

extern PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC glad_glTransformFeedbackStreamAttribsNV;

extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings;

extern PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC glad_glTransformFeedbackVaryingsEXT;

extern PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC glad_glTransformFeedbackVaryingsNV;

extern PFNGLTRANSFORMPATHNVPROC glad_glTransformPathNV;

extern PFNGLTRANSLATEXOESPROC glad_glTranslatexOES;

extern PFNGLUNIFORM1DPROC glad_glUniform1d;

extern PFNGLUNIFORM1DVPROC glad_glUniform1dv;

extern PFNGLUNIFORM1FPROC glad_glUniform1f;

extern PFNGLUNIFORM1FARBPROC glad_glUniform1fARB;

extern PFNGLUNIFORM1FVPROC glad_glUniform1fv;

extern PFNGLUNIFORM1FVARBPROC glad_glUniform1fvARB;

extern PFNGLUNIFORM1IPROC glad_glUniform1i;

extern PFNGLUNIFORM1I64ARBPROC glad_glUniform1i64ARB;

extern PFNGLUNIFORM1I64NVPROC glad_glUniform1i64NV;

extern PFNGLUNIFORM1I64VARBPROC glad_glUniform1i64vARB;

extern PFNGLUNIFORM1I64VNVPROC glad_glUniform1i64vNV;

extern PFNGLUNIFORM1IARBPROC glad_glUniform1iARB;

extern PFNGLUNIFORM1IVPROC glad_glUniform1iv;

extern PFNGLUNIFORM1IVARBPROC glad_glUniform1ivARB;

extern PFNGLUNIFORM1UIPROC glad_glUniform1ui;

extern PFNGLUNIFORM1UI64ARBPROC glad_glUniform1ui64ARB;

extern PFNGLUNIFORM1UI64NVPROC glad_glUniform1ui64NV;

extern PFNGLUNIFORM1UI64VARBPROC glad_glUniform1ui64vARB;

extern PFNGLUNIFORM1UI64VNVPROC glad_glUniform1ui64vNV;

extern PFNGLUNIFORM1UIEXTPROC glad_glUniform1uiEXT;

extern PFNGLUNIFORM1UIVPROC glad_glUniform1uiv;

extern PFNGLUNIFORM1UIVEXTPROC glad_glUniform1uivEXT;

extern PFNGLUNIFORM2DPROC glad_glUniform2d;

extern PFNGLUNIFORM2DVPROC glad_glUniform2dv;

extern PFNGLUNIFORM2FPROC glad_glUniform2f;

extern PFNGLUNIFORM2FARBPROC glad_glUniform2fARB;

extern PFNGLUNIFORM2FVPROC glad_glUniform2fv;

extern PFNGLUNIFORM2FVARBPROC glad_glUniform2fvARB;

extern PFNGLUNIFORM2IPROC glad_glUniform2i;

extern PFNGLUNIFORM2I64ARBPROC glad_glUniform2i64ARB;

extern PFNGLUNIFORM2I64NVPROC glad_glUniform2i64NV;

extern PFNGLUNIFORM2I64VARBPROC glad_glUniform2i64vARB;

extern PFNGLUNIFORM2I64VNVPROC glad_glUniform2i64vNV;

extern PFNGLUNIFORM2IARBPROC glad_glUniform2iARB;

extern PFNGLUNIFORM2IVPROC glad_glUniform2iv;

extern PFNGLUNIFORM2IVARBPROC glad_glUniform2ivARB;

extern PFNGLUNIFORM2UIPROC glad_glUniform2ui;

extern PFNGLUNIFORM2UI64ARBPROC glad_glUniform2ui64ARB;

extern PFNGLUNIFORM2UI64NVPROC glad_glUniform2ui64NV;

extern PFNGLUNIFORM2UI64VARBPROC glad_glUniform2ui64vARB;

extern PFNGLUNIFORM2UI64VNVPROC glad_glUniform2ui64vNV;

extern PFNGLUNIFORM2UIEXTPROC glad_glUniform2uiEXT;

extern PFNGLUNIFORM2UIVPROC glad_glUniform2uiv;

extern PFNGLUNIFORM2UIVEXTPROC glad_glUniform2uivEXT;

extern PFNGLUNIFORM3DPROC glad_glUniform3d;

extern PFNGLUNIFORM3DVPROC glad_glUniform3dv;

extern PFNGLUNIFORM3FPROC glad_glUniform3f;

extern PFNGLUNIFORM3FARBPROC glad_glUniform3fARB;

extern PFNGLUNIFORM3FVPROC glad_glUniform3fv;

extern PFNGLUNIFORM3FVARBPROC glad_glUniform3fvARB;

extern PFNGLUNIFORM3IPROC glad_glUniform3i;

extern PFNGLUNIFORM3I64ARBPROC glad_glUniform3i64ARB;

extern PFNGLUNIFORM3I64NVPROC glad_glUniform3i64NV;

extern PFNGLUNIFORM3I64VARBPROC glad_glUniform3i64vARB;

extern PFNGLUNIFORM3I64VNVPROC glad_glUniform3i64vNV;

extern PFNGLUNIFORM3IARBPROC glad_glUniform3iARB;

extern PFNGLUNIFORM3IVPROC glad_glUniform3iv;

extern PFNGLUNIFORM3IVARBPROC glad_glUniform3ivARB;

extern PFNGLUNIFORM3UIPROC glad_glUniform3ui;

extern PFNGLUNIFORM3UI64ARBPROC glad_glUniform3ui64ARB;

extern PFNGLUNIFORM3UI64NVPROC glad_glUniform3ui64NV;

extern PFNGLUNIFORM3UI64VARBPROC glad_glUniform3ui64vARB;

extern PFNGLUNIFORM3UI64VNVPROC glad_glUniform3ui64vNV;

extern PFNGLUNIFORM3UIEXTPROC glad_glUniform3uiEXT;

extern PFNGLUNIFORM3UIVPROC glad_glUniform3uiv;

extern PFNGLUNIFORM3UIVEXTPROC glad_glUniform3uivEXT;

extern PFNGLUNIFORM4DPROC glad_glUniform4d;

extern PFNGLUNIFORM4DVPROC glad_glUniform4dv;

extern PFNGLUNIFORM4FPROC glad_glUniform4f;

extern PFNGLUNIFORM4FARBPROC glad_glUniform4fARB;

extern PFNGLUNIFORM4FVPROC glad_glUniform4fv;

extern PFNGLUNIFORM4FVARBPROC glad_glUniform4fvARB;

extern PFNGLUNIFORM4IPROC glad_glUniform4i;

extern PFNGLUNIFORM4I64ARBPROC glad_glUniform4i64ARB;

extern PFNGLUNIFORM4I64NVPROC glad_glUniform4i64NV;

extern PFNGLUNIFORM4I64VARBPROC glad_glUniform4i64vARB;

extern PFNGLUNIFORM4I64VNVPROC glad_glUniform4i64vNV;

extern PFNGLUNIFORM4IARBPROC glad_glUniform4iARB;

extern PFNGLUNIFORM4IVPROC glad_glUniform4iv;

extern PFNGLUNIFORM4IVARBPROC glad_glUniform4ivARB;

extern PFNGLUNIFORM4UIPROC glad_glUniform4ui;

extern PFNGLUNIFORM4UI64ARBPROC glad_glUniform4ui64ARB;

extern PFNGLUNIFORM4UI64NVPROC glad_glUniform4ui64NV;

extern PFNGLUNIFORM4UI64VARBPROC glad_glUniform4ui64vARB;

extern PFNGLUNIFORM4UI64VNVPROC glad_glUniform4ui64vNV;

extern PFNGLUNIFORM4UIEXTPROC glad_glUniform4uiEXT;

extern PFNGLUNIFORM4UIVPROC glad_glUniform4uiv;

extern PFNGLUNIFORM4UIVEXTPROC glad_glUniform4uivEXT;

extern PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding;

extern PFNGLUNIFORMBUFFEREXTPROC glad_glUniformBufferEXT;

extern PFNGLUNIFORMHANDLEUI64ARBPROC glad_glUniformHandleui64ARB;

extern PFNGLUNIFORMHANDLEUI64NVPROC glad_glUniformHandleui64NV;

extern PFNGLUNIFORMHANDLEUI64VARBPROC glad_glUniformHandleui64vARB;

extern PFNGLUNIFORMHANDLEUI64VNVPROC glad_glUniformHandleui64vNV;

extern PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv;

extern PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv;

extern PFNGLUNIFORMMATRIX2FVARBPROC glad_glUniformMatrix2fvARB;

extern PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv;

extern PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv;

extern PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv;

extern PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv;

extern PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv;

extern PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv;

extern PFNGLUNIFORMMATRIX3FVARBPROC glad_glUniformMatrix3fvARB;

extern PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv;

extern PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv;

extern PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv;

extern PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv;

extern PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv;

extern PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv;

extern PFNGLUNIFORMMATRIX4FVARBPROC glad_glUniformMatrix4fvARB;

extern PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv;

extern PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv;

extern PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv;

extern PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv;

extern PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv;

extern PFNGLUNIFORMUI64NVPROC glad_glUniformui64NV;

extern PFNGLUNIFORMUI64VNVPROC glad_glUniformui64vNV;

extern PFNGLUNLOCKARRAYSEXTPROC glad_glUnlockArraysEXT;

extern PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer;

extern PFNGLUNMAPBUFFERARBPROC glad_glUnmapBufferARB;

extern PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer;

extern PFNGLUNMAPNAMEDBUFFEREXTPROC glad_glUnmapNamedBufferEXT;

extern PFNGLUNMAPOBJECTBUFFERATIPROC glad_glUnmapObjectBufferATI;

extern PFNGLUNMAPTEXTURE2DINTELPROC glad_glUnmapTexture2DINTEL;

extern PFNGLUPDATEOBJECTBUFFERATIPROC glad_glUpdateObjectBufferATI;

extern PFNGLUPLOADGPUMASKNVXPROC glad_glUploadGpuMaskNVX;

extern PFNGLUSEPROGRAMPROC glad_glUseProgram;

extern PFNGLUSEPROGRAMOBJECTARBPROC glad_glUseProgramObjectARB;

extern PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages;

extern PFNGLUSESHADERPROGRAMEXTPROC glad_glUseShaderProgramEXT;

extern PFNGLVDPAUFININVPROC glad_glVDPAUFiniNV;

extern PFNGLVDPAUGETSURFACEIVNVPROC glad_glVDPAUGetSurfaceivNV;

extern PFNGLVDPAUINITNVPROC glad_glVDPAUInitNV;

extern PFNGLVDPAUISSURFACENVPROC glad_glVDPAUIsSurfaceNV;

extern PFNGLVDPAUMAPSURFACESNVPROC glad_glVDPAUMapSurfacesNV;

extern PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC glad_glVDPAURegisterOutputSurfaceNV;

extern PFNGLVDPAUREGISTERVIDEOSURFACENVPROC glad_glVDPAURegisterVideoSurfaceNV;

extern PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC glad_glVDPAURegisterVideoSurfaceWithPictureStructureNV;

extern PFNGLVDPAUSURFACEACCESSNVPROC glad_glVDPAUSurfaceAccessNV;

extern PFNGLVDPAUUNMAPSURFACESNVPROC glad_glVDPAUUnmapSurfacesNV;

extern PFNGLVDPAUUNREGISTERSURFACENVPROC glad_glVDPAUUnregisterSurfaceNV;

extern PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram;

extern PFNGLVALIDATEPROGRAMARBPROC glad_glValidateProgramARB;

extern PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline;

extern PFNGLVARIANTARRAYOBJECTATIPROC glad_glVariantArrayObjectATI;

extern PFNGLVARIANTPOINTEREXTPROC glad_glVariantPointerEXT;

extern PFNGLVARIANTBVEXTPROC glad_glVariantbvEXT;

extern PFNGLVARIANTDVEXTPROC glad_glVariantdvEXT;

extern PFNGLVARIANTFVEXTPROC glad_glVariantfvEXT;

extern PFNGLVARIANTIVEXTPROC glad_glVariantivEXT;

extern PFNGLVARIANTSVEXTPROC glad_glVariantsvEXT;

extern PFNGLVARIANTUBVEXTPROC glad_glVariantubvEXT;

extern PFNGLVARIANTUIVEXTPROC glad_glVariantuivEXT;

extern PFNGLVARIANTUSVEXTPROC glad_glVariantusvEXT;

extern PFNGLVERTEX2BOESPROC glad_glVertex2bOES;

extern PFNGLVERTEX2BVOESPROC glad_glVertex2bvOES;

extern PFNGLVERTEX2HNVPROC glad_glVertex2hNV;

extern PFNGLVERTEX2HVNVPROC glad_glVertex2hvNV;

extern PFNGLVERTEX2XOESPROC glad_glVertex2xOES;

extern PFNGLVERTEX2XVOESPROC glad_glVertex2xvOES;

extern PFNGLVERTEX3BOESPROC glad_glVertex3bOES;

extern PFNGLVERTEX3BVOESPROC glad_glVertex3bvOES;

extern PFNGLVERTEX3HNVPROC glad_glVertex3hNV;

extern PFNGLVERTEX3HVNVPROC glad_glVertex3hvNV;

extern PFNGLVERTEX3XOESPROC glad_glVertex3xOES;

extern PFNGLVERTEX3XVOESPROC glad_glVertex3xvOES;

extern PFNGLVERTEX4BOESPROC glad_glVertex4bOES;

extern PFNGLVERTEX4BVOESPROC glad_glVertex4bvOES;

extern PFNGLVERTEX4HNVPROC glad_glVertex4hNV;

extern PFNGLVERTEX4HVNVPROC glad_glVertex4hvNV;

extern PFNGLVERTEX4XOESPROC glad_glVertex4xOES;

extern PFNGLVERTEX4XVOESPROC glad_glVertex4xvOES;

extern PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding;

extern PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat;

extern PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat;

extern PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat;

extern PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC glad_glVertexArrayBindVertexBufferEXT;

extern PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor;

extern PFNGLVERTEXARRAYCOLOROFFSETEXTPROC glad_glVertexArrayColorOffsetEXT;

extern PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC glad_glVertexArrayEdgeFlagOffsetEXT;

extern PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer;

extern PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC glad_glVertexArrayFogCoordOffsetEXT;

extern PFNGLVERTEXARRAYINDEXOFFSETEXTPROC glad_glVertexArrayIndexOffsetEXT;

extern PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC glad_glVertexArrayMultiTexCoordOffsetEXT;

extern PFNGLVERTEXARRAYNORMALOFFSETEXTPROC glad_glVertexArrayNormalOffsetEXT;

extern PFNGLVERTEXARRAYPARAMETERIAPPLEPROC glad_glVertexArrayParameteriAPPLE;

extern PFNGLVERTEXARRAYRANGEAPPLEPROC glad_glVertexArrayRangeAPPLE;

extern PFNGLVERTEXARRAYRANGENVPROC glad_glVertexArrayRangeNV;

extern PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC glad_glVertexArraySecondaryColorOffsetEXT;

extern PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC glad_glVertexArrayTexCoordOffsetEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC glad_glVertexArrayVertexAttribBindingEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC glad_glVertexArrayVertexAttribDivisorEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC glad_glVertexArrayVertexAttribFormatEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC glad_glVertexArrayVertexAttribIFormatEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC glad_glVertexArrayVertexAttribIOffsetEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC glad_glVertexArrayVertexAttribLFormatEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC glad_glVertexArrayVertexAttribLOffsetEXT;

extern PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC glad_glVertexArrayVertexAttribOffsetEXT;

extern PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC glad_glVertexArrayVertexBindingDivisorEXT;

extern PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer;

extern PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers;

extern PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC glad_glVertexArrayVertexOffsetEXT;

extern PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d;

extern PFNGLVERTEXATTRIB1DARBPROC glad_glVertexAttrib1dARB;

extern PFNGLVERTEXATTRIB1DNVPROC glad_glVertexAttrib1dNV;

extern PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv;

extern PFNGLVERTEXATTRIB1DVARBPROC glad_glVertexAttrib1dvARB;

extern PFNGLVERTEXATTRIB1DVNVPROC glad_glVertexAttrib1dvNV;

extern PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f;

extern PFNGLVERTEXATTRIB1FARBPROC glad_glVertexAttrib1fARB;

extern PFNGLVERTEXATTRIB1FNVPROC glad_glVertexAttrib1fNV;

extern PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv;

extern PFNGLVERTEXATTRIB1FVARBPROC glad_glVertexAttrib1fvARB;

extern PFNGLVERTEXATTRIB1FVNVPROC glad_glVertexAttrib1fvNV;

extern PFNGLVERTEXATTRIB1HNVPROC glad_glVertexAttrib1hNV;

extern PFNGLVERTEXATTRIB1HVNVPROC glad_glVertexAttrib1hvNV;

extern PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s;

extern PFNGLVERTEXATTRIB1SARBPROC glad_glVertexAttrib1sARB;

extern PFNGLVERTEXATTRIB1SNVPROC glad_glVertexAttrib1sNV;

extern PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv;

extern PFNGLVERTEXATTRIB1SVARBPROC glad_glVertexAttrib1svARB;

extern PFNGLVERTEXATTRIB1SVNVPROC glad_glVertexAttrib1svNV;

extern PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d;

extern PFNGLVERTEXATTRIB2DARBPROC glad_glVertexAttrib2dARB;

extern PFNGLVERTEXATTRIB2DNVPROC glad_glVertexAttrib2dNV;

extern PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv;

extern PFNGLVERTEXATTRIB2DVARBPROC glad_glVertexAttrib2dvARB;

extern PFNGLVERTEXATTRIB2DVNVPROC glad_glVertexAttrib2dvNV;

extern PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f;

extern PFNGLVERTEXATTRIB2FARBPROC glad_glVertexAttrib2fARB;

extern PFNGLVERTEXATTRIB2FNVPROC glad_glVertexAttrib2fNV;

extern PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv;

extern PFNGLVERTEXATTRIB2FVARBPROC glad_glVertexAttrib2fvARB;

extern PFNGLVERTEXATTRIB2FVNVPROC glad_glVertexAttrib2fvNV;

extern PFNGLVERTEXATTRIB2HNVPROC glad_glVertexAttrib2hNV;

extern PFNGLVERTEXATTRIB2HVNVPROC glad_glVertexAttrib2hvNV;

extern PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s;

extern PFNGLVERTEXATTRIB2SARBPROC glad_glVertexAttrib2sARB;

extern PFNGLVERTEXATTRIB2SNVPROC glad_glVertexAttrib2sNV;

extern PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv;

extern PFNGLVERTEXATTRIB2SVARBPROC glad_glVertexAttrib2svARB;

extern PFNGLVERTEXATTRIB2SVNVPROC glad_glVertexAttrib2svNV;

extern PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d;

extern PFNGLVERTEXATTRIB3DARBPROC glad_glVertexAttrib3dARB;

extern PFNGLVERTEXATTRIB3DNVPROC glad_glVertexAttrib3dNV;

extern PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv;

extern PFNGLVERTEXATTRIB3DVARBPROC glad_glVertexAttrib3dvARB;

extern PFNGLVERTEXATTRIB3DVNVPROC glad_glVertexAttrib3dvNV;

extern PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f;

extern PFNGLVERTEXATTRIB3FARBPROC glad_glVertexAttrib3fARB;

extern PFNGLVERTEXATTRIB3FNVPROC glad_glVertexAttrib3fNV;

extern PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv;

extern PFNGLVERTEXATTRIB3FVARBPROC glad_glVertexAttrib3fvARB;

extern PFNGLVERTEXATTRIB3FVNVPROC glad_glVertexAttrib3fvNV;

extern PFNGLVERTEXATTRIB3HNVPROC glad_glVertexAttrib3hNV;

extern PFNGLVERTEXATTRIB3HVNVPROC glad_glVertexAttrib3hvNV;

extern PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s;

extern PFNGLVERTEXATTRIB3SARBPROC glad_glVertexAttrib3sARB;

extern PFNGLVERTEXATTRIB3SNVPROC glad_glVertexAttrib3sNV;

extern PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv;

extern PFNGLVERTEXATTRIB3SVARBPROC glad_glVertexAttrib3svARB;

extern PFNGLVERTEXATTRIB3SVNVPROC glad_glVertexAttrib3svNV;

extern PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv;

extern PFNGLVERTEXATTRIB4NBVARBPROC glad_glVertexAttrib4NbvARB;

extern PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv;

extern PFNGLVERTEXATTRIB4NIVARBPROC glad_glVertexAttrib4NivARB;

extern PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv;

extern PFNGLVERTEXATTRIB4NSVARBPROC glad_glVertexAttrib4NsvARB;

extern PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub;

extern PFNGLVERTEXATTRIB4NUBARBPROC glad_glVertexAttrib4NubARB;

extern PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv;

extern PFNGLVERTEXATTRIB4NUBVARBPROC glad_glVertexAttrib4NubvARB;

extern PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv;

extern PFNGLVERTEXATTRIB4NUIVARBPROC glad_glVertexAttrib4NuivARB;

extern PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv;

extern PFNGLVERTEXATTRIB4NUSVARBPROC glad_glVertexAttrib4NusvARB;

extern PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv;

extern PFNGLVERTEXATTRIB4BVARBPROC glad_glVertexAttrib4bvARB;

extern PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d;

extern PFNGLVERTEXATTRIB4DARBPROC glad_glVertexAttrib4dARB;

extern PFNGLVERTEXATTRIB4DNVPROC glad_glVertexAttrib4dNV;

extern PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv;

extern PFNGLVERTEXATTRIB4DVARBPROC glad_glVertexAttrib4dvARB;

extern PFNGLVERTEXATTRIB4DVNVPROC glad_glVertexAttrib4dvNV;

extern PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f;

extern PFNGLVERTEXATTRIB4FARBPROC glad_glVertexAttrib4fARB;

extern PFNGLVERTEXATTRIB4FNVPROC glad_glVertexAttrib4fNV;

extern PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv;

extern PFNGLVERTEXATTRIB4FVARBPROC glad_glVertexAttrib4fvARB;

extern PFNGLVERTEXATTRIB4FVNVPROC glad_glVertexAttrib4fvNV;

extern PFNGLVERTEXATTRIB4HNVPROC glad_glVertexAttrib4hNV;

extern PFNGLVERTEXATTRIB4HVNVPROC glad_glVertexAttrib4hvNV;

extern PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv;

extern PFNGLVERTEXATTRIB4IVARBPROC glad_glVertexAttrib4ivARB;

extern PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s;

extern PFNGLVERTEXATTRIB4SARBPROC glad_glVertexAttrib4sARB;

extern PFNGLVERTEXATTRIB4SNVPROC glad_glVertexAttrib4sNV;

extern PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv;

extern PFNGLVERTEXATTRIB4SVARBPROC glad_glVertexAttrib4svARB;

extern PFNGLVERTEXATTRIB4SVNVPROC glad_glVertexAttrib4svNV;

extern PFNGLVERTEXATTRIB4UBNVPROC glad_glVertexAttrib4ubNV;

extern PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv;

extern PFNGLVERTEXATTRIB4UBVARBPROC glad_glVertexAttrib4ubvARB;

extern PFNGLVERTEXATTRIB4UBVNVPROC glad_glVertexAttrib4ubvNV;

extern PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv;

extern PFNGLVERTEXATTRIB4UIVARBPROC glad_glVertexAttrib4uivARB;

extern PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv;

extern PFNGLVERTEXATTRIB4USVARBPROC glad_glVertexAttrib4usvARB;

extern PFNGLVERTEXATTRIBARRAYOBJECTATIPROC glad_glVertexAttribArrayObjectATI;

extern PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding;

extern PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor;

extern PFNGLVERTEXATTRIBDIVISORARBPROC glad_glVertexAttribDivisorARB;

extern PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat;

extern PFNGLVERTEXATTRIBFORMATNVPROC glad_glVertexAttribFormatNV;

extern PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i;

extern PFNGLVERTEXATTRIBI1IEXTPROC glad_glVertexAttribI1iEXT;

extern PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv;

extern PFNGLVERTEXATTRIBI1IVEXTPROC glad_glVertexAttribI1ivEXT;

extern PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui;

extern PFNGLVERTEXATTRIBI1UIEXTPROC glad_glVertexAttribI1uiEXT;

extern PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv;

extern PFNGLVERTEXATTRIBI1UIVEXTPROC glad_glVertexAttribI1uivEXT;

extern PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i;

extern PFNGLVERTEXATTRIBI2IEXTPROC glad_glVertexAttribI2iEXT;

extern PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv;

extern PFNGLVERTEXATTRIBI2IVEXTPROC glad_glVertexAttribI2ivEXT;

extern PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui;

extern PFNGLVERTEXATTRIBI2UIEXTPROC glad_glVertexAttribI2uiEXT;

extern PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv;

extern PFNGLVERTEXATTRIBI2UIVEXTPROC glad_glVertexAttribI2uivEXT;

extern PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i;

extern PFNGLVERTEXATTRIBI3IEXTPROC glad_glVertexAttribI3iEXT;

extern PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv;

extern PFNGLVERTEXATTRIBI3IVEXTPROC glad_glVertexAttribI3ivEXT;

extern PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui;

extern PFNGLVERTEXATTRIBI3UIEXTPROC glad_glVertexAttribI3uiEXT;

extern PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv;

extern PFNGLVERTEXATTRIBI3UIVEXTPROC glad_glVertexAttribI3uivEXT;

extern PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv;

extern PFNGLVERTEXATTRIBI4BVEXTPROC glad_glVertexAttribI4bvEXT;

extern PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i;

extern PFNGLVERTEXATTRIBI4IEXTPROC glad_glVertexAttribI4iEXT;

extern PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv;

extern PFNGLVERTEXATTRIBI4IVEXTPROC glad_glVertexAttribI4ivEXT;

extern PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv;

extern PFNGLVERTEXATTRIBI4SVEXTPROC glad_glVertexAttribI4svEXT;

extern PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv;

extern PFNGLVERTEXATTRIBI4UBVEXTPROC glad_glVertexAttribI4ubvEXT;

extern PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui;

extern PFNGLVERTEXATTRIBI4UIEXTPROC glad_glVertexAttribI4uiEXT;

extern PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv;

extern PFNGLVERTEXATTRIBI4UIVEXTPROC glad_glVertexAttribI4uivEXT;

extern PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv;

extern PFNGLVERTEXATTRIBI4USVEXTPROC glad_glVertexAttribI4usvEXT;

extern PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat;

extern PFNGLVERTEXATTRIBIFORMATNVPROC glad_glVertexAttribIFormatNV;

extern PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer;

extern PFNGLVERTEXATTRIBIPOINTEREXTPROC glad_glVertexAttribIPointerEXT;

extern PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d;

extern PFNGLVERTEXATTRIBL1DEXTPROC glad_glVertexAttribL1dEXT;

extern PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv;

extern PFNGLVERTEXATTRIBL1DVEXTPROC glad_glVertexAttribL1dvEXT;

extern PFNGLVERTEXATTRIBL1I64NVPROC glad_glVertexAttribL1i64NV;

extern PFNGLVERTEXATTRIBL1I64VNVPROC glad_glVertexAttribL1i64vNV;

extern PFNGLVERTEXATTRIBL1UI64ARBPROC glad_glVertexAttribL1ui64ARB;

extern PFNGLVERTEXATTRIBL1UI64NVPROC glad_glVertexAttribL1ui64NV;

extern PFNGLVERTEXATTRIBL1UI64VARBPROC glad_glVertexAttribL1ui64vARB;

extern PFNGLVERTEXATTRIBL1UI64VNVPROC glad_glVertexAttribL1ui64vNV;

extern PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d;

extern PFNGLVERTEXATTRIBL2DEXTPROC glad_glVertexAttribL2dEXT;

extern PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv;

extern PFNGLVERTEXATTRIBL2DVEXTPROC glad_glVertexAttribL2dvEXT;

extern PFNGLVERTEXATTRIBL2I64NVPROC glad_glVertexAttribL2i64NV;

extern PFNGLVERTEXATTRIBL2I64VNVPROC glad_glVertexAttribL2i64vNV;

extern PFNGLVERTEXATTRIBL2UI64NVPROC glad_glVertexAttribL2ui64NV;

extern PFNGLVERTEXATTRIBL2UI64VNVPROC glad_glVertexAttribL2ui64vNV;

extern PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d;

extern PFNGLVERTEXATTRIBL3DEXTPROC glad_glVertexAttribL3dEXT;

extern PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv;

extern PFNGLVERTEXATTRIBL3DVEXTPROC glad_glVertexAttribL3dvEXT;

extern PFNGLVERTEXATTRIBL3I64NVPROC glad_glVertexAttribL3i64NV;

extern PFNGLVERTEXATTRIBL3I64VNVPROC glad_glVertexAttribL3i64vNV;

extern PFNGLVERTEXATTRIBL3UI64NVPROC glad_glVertexAttribL3ui64NV;

extern PFNGLVERTEXATTRIBL3UI64VNVPROC glad_glVertexAttribL3ui64vNV;

extern PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d;

extern PFNGLVERTEXATTRIBL4DEXTPROC glad_glVertexAttribL4dEXT;

extern PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv;

extern PFNGLVERTEXATTRIBL4DVEXTPROC glad_glVertexAttribL4dvEXT;

extern PFNGLVERTEXATTRIBL4I64NVPROC glad_glVertexAttribL4i64NV;

extern PFNGLVERTEXATTRIBL4I64VNVPROC glad_glVertexAttribL4i64vNV;

extern PFNGLVERTEXATTRIBL4UI64NVPROC glad_glVertexAttribL4ui64NV;

extern PFNGLVERTEXATTRIBL4UI64VNVPROC glad_glVertexAttribL4ui64vNV;

extern PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat;

extern PFNGLVERTEXATTRIBLFORMATNVPROC glad_glVertexAttribLFormatNV;

extern PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer;

extern PFNGLVERTEXATTRIBLPOINTEREXTPROC glad_glVertexAttribLPointerEXT;

extern PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui;

extern PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv;

extern PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui;

extern PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv;

extern PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui;

extern PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv;

extern PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui;

extern PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv;

extern PFNGLVERTEXATTRIBPARAMETERIAMDPROC glad_glVertexAttribParameteriAMD;

extern PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer;

extern PFNGLVERTEXATTRIBPOINTERARBPROC glad_glVertexAttribPointerARB;

extern PFNGLVERTEXATTRIBPOINTERNVPROC glad_glVertexAttribPointerNV;

extern PFNGLVERTEXATTRIBS1DVNVPROC glad_glVertexAttribs1dvNV;

extern PFNGLVERTEXATTRIBS1FVNVPROC glad_glVertexAttribs1fvNV;

extern PFNGLVERTEXATTRIBS1HVNVPROC glad_glVertexAttribs1hvNV;

extern PFNGLVERTEXATTRIBS1SVNVPROC glad_glVertexAttribs1svNV;

extern PFNGLVERTEXATTRIBS2DVNVPROC glad_glVertexAttribs2dvNV;

extern PFNGLVERTEXATTRIBS2FVNVPROC glad_glVertexAttribs2fvNV;

extern PFNGLVERTEXATTRIBS2HVNVPROC glad_glVertexAttribs2hvNV;

extern PFNGLVERTEXATTRIBS2SVNVPROC glad_glVertexAttribs2svNV;

extern PFNGLVERTEXATTRIBS3DVNVPROC glad_glVertexAttribs3dvNV;

extern PFNGLVERTEXATTRIBS3FVNVPROC glad_glVertexAttribs3fvNV;

extern PFNGLVERTEXATTRIBS3HVNVPROC glad_glVertexAttribs3hvNV;

extern PFNGLVERTEXATTRIBS3SVNVPROC glad_glVertexAttribs3svNV;

extern PFNGLVERTEXATTRIBS4DVNVPROC glad_glVertexAttribs4dvNV;

extern PFNGLVERTEXATTRIBS4FVNVPROC glad_glVertexAttribs4fvNV;

extern PFNGLVERTEXATTRIBS4HVNVPROC glad_glVertexAttribs4hvNV;

extern PFNGLVERTEXATTRIBS4SVNVPROC glad_glVertexAttribs4svNV;

extern PFNGLVERTEXATTRIBS4UBVNVPROC glad_glVertexAttribs4ubvNV;

extern PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor;

extern PFNGLVERTEXBLENDARBPROC glad_glVertexBlendARB;

extern PFNGLVERTEXBLENDENVFATIPROC glad_glVertexBlendEnvfATI;

extern PFNGLVERTEXBLENDENVIATIPROC glad_glVertexBlendEnviATI;

extern PFNGLVERTEXFORMATNVPROC glad_glVertexFormatNV;

extern PFNGLVERTEXPOINTEREXTPROC glad_glVertexPointerEXT;

extern PFNGLVERTEXPOINTERLISTIBMPROC glad_glVertexPointerListIBM;

extern PFNGLVERTEXPOINTERVINTELPROC glad_glVertexPointervINTEL;

extern PFNGLVERTEXSTREAM1DATIPROC glad_glVertexStream1dATI;

extern PFNGLVERTEXSTREAM1DVATIPROC glad_glVertexStream1dvATI;

extern PFNGLVERTEXSTREAM1FATIPROC glad_glVertexStream1fATI;

extern PFNGLVERTEXSTREAM1FVATIPROC glad_glVertexStream1fvATI;

extern PFNGLVERTEXSTREAM1IATIPROC glad_glVertexStream1iATI;

extern PFNGLVERTEXSTREAM1IVATIPROC glad_glVertexStream1ivATI;

extern PFNGLVERTEXSTREAM1SATIPROC glad_glVertexStream1sATI;

extern PFNGLVERTEXSTREAM1SVATIPROC glad_glVertexStream1svATI;

extern PFNGLVERTEXSTREAM2DATIPROC glad_glVertexStream2dATI;

extern PFNGLVERTEXSTREAM2DVATIPROC glad_glVertexStream2dvATI;

extern PFNGLVERTEXSTREAM2FATIPROC glad_glVertexStream2fATI;

extern PFNGLVERTEXSTREAM2FVATIPROC glad_glVertexStream2fvATI;

extern PFNGLVERTEXSTREAM2IATIPROC glad_glVertexStream2iATI;

extern PFNGLVERTEXSTREAM2IVATIPROC glad_glVertexStream2ivATI;

extern PFNGLVERTEXSTREAM2SATIPROC glad_glVertexStream2sATI;

extern PFNGLVERTEXSTREAM2SVATIPROC glad_glVertexStream2svATI;

extern PFNGLVERTEXSTREAM3DATIPROC glad_glVertexStream3dATI;

extern PFNGLVERTEXSTREAM3DVATIPROC glad_glVertexStream3dvATI;

extern PFNGLVERTEXSTREAM3FATIPROC glad_glVertexStream3fATI;

extern PFNGLVERTEXSTREAM3FVATIPROC glad_glVertexStream3fvATI;

extern PFNGLVERTEXSTREAM3IATIPROC glad_glVertexStream3iATI;

extern PFNGLVERTEXSTREAM3IVATIPROC glad_glVertexStream3ivATI;

extern PFNGLVERTEXSTREAM3SATIPROC glad_glVertexStream3sATI;

extern PFNGLVERTEXSTREAM3SVATIPROC glad_glVertexStream3svATI;

extern PFNGLVERTEXSTREAM4DATIPROC glad_glVertexStream4dATI;

extern PFNGLVERTEXSTREAM4DVATIPROC glad_glVertexStream4dvATI;

extern PFNGLVERTEXSTREAM4FATIPROC glad_glVertexStream4fATI;

extern PFNGLVERTEXSTREAM4FVATIPROC glad_glVertexStream4fvATI;

extern PFNGLVERTEXSTREAM4IATIPROC glad_glVertexStream4iATI;

extern PFNGLVERTEXSTREAM4IVATIPROC glad_glVertexStream4ivATI;

extern PFNGLVERTEXSTREAM4SATIPROC glad_glVertexStream4sATI;

extern PFNGLVERTEXSTREAM4SVATIPROC glad_glVertexStream4svATI;

extern PFNGLVERTEXWEIGHTPOINTEREXTPROC glad_glVertexWeightPointerEXT;

extern PFNGLVERTEXWEIGHTFEXTPROC glad_glVertexWeightfEXT;

extern PFNGLVERTEXWEIGHTFVEXTPROC glad_glVertexWeightfvEXT;

extern PFNGLVERTEXWEIGHTHNVPROC glad_glVertexWeighthNV;

extern PFNGLVERTEXWEIGHTHVNVPROC glad_glVertexWeighthvNV;

extern PFNGLVIDEOCAPTURENVPROC glad_glVideoCaptureNV;

extern PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC glad_glVideoCaptureStreamParameterdvNV;

extern PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC glad_glVideoCaptureStreamParameterfvNV;

extern PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC glad_glVideoCaptureStreamParameterivNV;

extern PFNGLVIEWPORTPROC glad_glViewport;

extern PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv;

extern PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf;

extern PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv;

extern PFNGLVIEWPORTPOSITIONWSCALENVPROC glad_glViewportPositionWScaleNV;

extern PFNGLVIEWPORTSWIZZLENVPROC glad_glViewportSwizzleNV;

extern PFNGLWAITSEMAPHOREEXTPROC glad_glWaitSemaphoreEXT;

extern PFNGLWAITSEMAPHOREUI64NVXPROC glad_glWaitSemaphoreui64NVX;

extern PFNGLWAITSYNCPROC glad_glWaitSync;

extern PFNGLWAITVKSEMAPHORENVPROC glad_glWaitVkSemaphoreNV;

extern PFNGLWEIGHTPATHSNVPROC glad_glWeightPathsNV;

extern PFNGLWEIGHTPOINTERARBPROC glad_glWeightPointerARB;

extern PFNGLWEIGHTBVARBPROC glad_glWeightbvARB;

extern PFNGLWEIGHTDVARBPROC glad_glWeightdvARB;

extern PFNGLWEIGHTFVARBPROC glad_glWeightfvARB;

extern PFNGLWEIGHTIVARBPROC glad_glWeightivARB;

extern PFNGLWEIGHTSVARBPROC glad_glWeightsvARB;

extern PFNGLWEIGHTUBVARBPROC glad_glWeightubvARB;

extern PFNGLWEIGHTUIVARBPROC glad_glWeightuivARB;

extern PFNGLWEIGHTUSVARBPROC glad_glWeightusvARB;

extern PFNGLWINDOWPOS2DARBPROC glad_glWindowPos2dARB;

extern PFNGLWINDOWPOS2DMESAPROC glad_glWindowPos2dMESA;

extern PFNGLWINDOWPOS2DVARBPROC glad_glWindowPos2dvARB;

extern PFNGLWINDOWPOS2DVMESAPROC glad_glWindowPos2dvMESA;

extern PFNGLWINDOWPOS2FARBPROC glad_glWindowPos2fARB;

extern PFNGLWINDOWPOS2FMESAPROC glad_glWindowPos2fMESA;

extern PFNGLWINDOWPOS2FVARBPROC glad_glWindowPos2fvARB;

extern PFNGLWINDOWPOS2FVMESAPROC glad_glWindowPos2fvMESA;

extern PFNGLWINDOWPOS2IARBPROC glad_glWindowPos2iARB;

extern PFNGLWINDOWPOS2IMESAPROC glad_glWindowPos2iMESA;

extern PFNGLWINDOWPOS2IVARBPROC glad_glWindowPos2ivARB;

extern PFNGLWINDOWPOS2IVMESAPROC glad_glWindowPos2ivMESA;

extern PFNGLWINDOWPOS2SARBPROC glad_glWindowPos2sARB;

extern PFNGLWINDOWPOS2SMESAPROC glad_glWindowPos2sMESA;

extern PFNGLWINDOWPOS2SVARBPROC glad_glWindowPos2svARB;

extern PFNGLWINDOWPOS2SVMESAPROC glad_glWindowPos2svMESA;

extern PFNGLWINDOWPOS3DARBPROC glad_glWindowPos3dARB;

extern PFNGLWINDOWPOS3DMESAPROC glad_glWindowPos3dMESA;

extern PFNGLWINDOWPOS3DVARBPROC glad_glWindowPos3dvARB;

extern PFNGLWINDOWPOS3DVMESAPROC glad_glWindowPos3dvMESA;

extern PFNGLWINDOWPOS3FARBPROC glad_glWindowPos3fARB;

extern PFNGLWINDOWPOS3FMESAPROC glad_glWindowPos3fMESA;

extern PFNGLWINDOWPOS3FVARBPROC glad_glWindowPos3fvARB;

extern PFNGLWINDOWPOS3FVMESAPROC glad_glWindowPos3fvMESA;

extern PFNGLWINDOWPOS3IARBPROC glad_glWindowPos3iARB;

extern PFNGLWINDOWPOS3IMESAPROC glad_glWindowPos3iMESA;

extern PFNGLWINDOWPOS3IVARBPROC glad_glWindowPos3ivARB;

extern PFNGLWINDOWPOS3IVMESAPROC glad_glWindowPos3ivMESA;

extern PFNGLWINDOWPOS3SARBPROC glad_glWindowPos3sARB;

extern PFNGLWINDOWPOS3SMESAPROC glad_glWindowPos3sMESA;

extern PFNGLWINDOWPOS3SVARBPROC glad_glWindowPos3svARB;

extern PFNGLWINDOWPOS3SVMESAPROC glad_glWindowPos3svMESA;

extern PFNGLWINDOWPOS4DMESAPROC glad_glWindowPos4dMESA;

extern PFNGLWINDOWPOS4DVMESAPROC glad_glWindowPos4dvMESA;

extern PFNGLWINDOWPOS4FMESAPROC glad_glWindowPos4fMESA;

extern PFNGLWINDOWPOS4FVMESAPROC glad_glWindowPos4fvMESA;

extern PFNGLWINDOWPOS4IMESAPROC glad_glWindowPos4iMESA;

extern PFNGLWINDOWPOS4IVMESAPROC glad_glWindowPos4ivMESA;

extern PFNGLWINDOWPOS4SMESAPROC glad_glWindowPos4sMESA;

extern PFNGLWINDOWPOS4SVMESAPROC glad_glWindowPos4svMESA;

extern PFNGLWINDOWRECTANGLESEXTPROC glad_glWindowRectanglesEXT;

extern PFNGLWRITEMASKEXTPROC glad_glWriteMaskEXT;






extern int gladLoadGLUserPtr( GLADuserptrloadfunc load, void *userptr);
extern int gladLoadGL( GLADloadfunc load);




}
#line 13568 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
#line 13569 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glad\\gl.h"
#line 4 "C:\\Users\\rapul\\FYSM\\Impi\\Impi\\headers\\rendering\\assets\\SphereMesh.h"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"







































































































#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\_fixes.hpp"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"

















#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"



#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"



#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4868 4988 5026 5027 5045 5220 5246 5278 5280 5281 6294  4984 5053 )





[[nodiscard]]   inline float acos(  float _Xx) noexcept  {
    return :: acosf(_Xx);
}

[[nodiscard]]   inline float acosh(  float _Xx) noexcept  {
    return :: acoshf(_Xx);
}

[[nodiscard]]   inline float asin(  float _Xx) noexcept  {
    return :: asinf(_Xx);
}

[[nodiscard]]   inline float asinh(  float _Xx) noexcept  {
    return :: asinhf(_Xx);
}

[[nodiscard]]   inline float atan(  float _Xx) noexcept  {
    return :: atanf(_Xx);
}

[[nodiscard]]   inline float atanh(  float _Xx) noexcept  {
    return :: atanhf(_Xx);
}

[[nodiscard]]   inline float atan2(  float _Yx,   float _Xx) noexcept  {
    return :: atan2f(_Yx, _Xx);
}

[[nodiscard]]   inline float cbrt(  float _Xx) noexcept  {
    return :: cbrtf(_Xx);
}

[[nodiscard]]   inline float ceil(  float _Xx) noexcept  {

    return __ceilf(_Xx);




#line 76 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline float copysign(  float _Number,   float _Sign) noexcept  {

    return __copysignf(_Number, _Sign);




#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline float cos(  float _Xx) noexcept  {
    return :: cosf(_Xx);
}

[[nodiscard]]   inline float cosh(  float _Xx) noexcept  {
    return :: coshf(_Xx);
}

[[nodiscard]]   inline float erf(  float _Xx) noexcept  {
    return :: erff(_Xx);
}

[[nodiscard]]   inline float erfc(  float _Xx) noexcept  {
    return :: erfcf(_Xx);
}

[[nodiscard]]   inline float exp(  float _Xx) noexcept  {
    return :: expf(_Xx);
}

[[nodiscard]]   inline float exp2(  float _Xx) noexcept  {
    return :: exp2f(_Xx);
}

[[nodiscard]]   inline float expm1(  float _Xx) noexcept  {
    return :: expm1f(_Xx);
}

[[nodiscard]]   inline float fabs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline float fdim(  float _Xx,   float _Yx) noexcept  {
    return :: fdimf(_Xx, _Yx);
}

[[nodiscard]]   inline float floor(  float _Xx) noexcept  {

    return __floorf(_Xx);




#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline float fma(  float _Xx,   float _Yx,   float _Zx) noexcept  {
    return :: fmaf(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float fmax(  float _Xx,   float _Yx) noexcept  {
    return :: fmaxf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmin(  float _Xx,   float _Yx) noexcept  {
    return :: fminf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmod(  float _Xx,   float _Yx) noexcept  {
    return :: fmodf(_Xx, _Yx);
}

inline float frexp(  float _Xx,   int* _Yx) noexcept  {
    return :: frexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float hypot(  float _Xx,   float _Yx) noexcept  {
    return :: hypotf(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  float _Xx) noexcept  {
    return :: ilogbf(_Xx);
}

[[nodiscard]]   inline float ldexp(  float _Xx,   int _Yx) noexcept  {
    return :: ldexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float lgamma(  float _Xx) noexcept  {
    return :: lgammaf(_Xx);
}

[[nodiscard]]   inline long long llrint(  float _Xx) noexcept  {
    return :: llrintf(_Xx);
}

[[nodiscard]]   inline long long llround(  float _Xx) noexcept  {
    return :: llroundf(_Xx);
}

[[nodiscard]]   inline float log(  float _Xx) noexcept  {
    return :: logf(_Xx);
}

[[nodiscard]]   inline float log10(  float _Xx) noexcept  {
    return :: log10f(_Xx);
}

[[nodiscard]]   inline float log1p(  float _Xx) noexcept  {
    return :: log1pf(_Xx);
}

[[nodiscard]]   inline float log2(  float _Xx) noexcept  {
    return :: log2f(_Xx);
}

[[nodiscard]]   inline float logb(  float _Xx) noexcept  {
    return :: logbf(_Xx);
}

[[nodiscard]]   inline long lrint(  float _Xx) noexcept  {
    return :: lrintf(_Xx);
}

[[nodiscard]]   inline long lround(  float _Xx) noexcept  {
    return :: lroundf(_Xx);
}

inline float modf(  float _Xx,   float* _Yx) noexcept  {
    return :: modff(_Xx, _Yx);
}

[[nodiscard]]   inline float nearbyint(  float _Xx) noexcept  {
    return :: nearbyintf(_Xx);
}

[[nodiscard]]   inline float nextafter(  float _Xx,   float _Yx) noexcept  {
    return :: nextafterf(_Xx, _Yx);
}

[[nodiscard]]   inline float nexttoward(  float _Xx,   long double _Yx) noexcept  {
    return :: nexttowardf(_Xx, _Yx);
}

[[nodiscard]]   inline float pow(  float _Xx,   float _Yx) noexcept  {
    return :: powf(_Xx, _Yx);
}

[[nodiscard]]   inline float remainder(  float _Xx,   float _Yx) noexcept  {
    return :: remainderf(_Xx, _Yx);
}

inline float remquo(  float _Xx,   float _Yx,   int* _Zx) noexcept  {
    return :: remquof(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float rint(  float _Xx) noexcept  {
    return :: rintf(_Xx);
}

[[nodiscard]]   inline float round(  float _Xx) noexcept  {

    return __roundf(_Xx);




#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline float scalbln(  float _Xx,   long _Yx) noexcept  {
    return :: scalblnf(_Xx, _Yx);
}

[[nodiscard]]   inline float scalbn(  float _Xx,   int _Yx) noexcept  {
    return :: scalbnf(_Xx, _Yx);
}

[[nodiscard]]   inline float sin(  float _Xx) noexcept  {
    return :: sinf(_Xx);
}

[[nodiscard]]   inline float sinh(  float _Xx) noexcept  {
    return :: sinhf(_Xx);
}

[[nodiscard]]   inline float sqrt(  float _Xx) noexcept  {
    return :: sqrtf(_Xx);
}

[[nodiscard]]   inline float tan(  float _Xx) noexcept  {
    return :: tanf(_Xx);
}

[[nodiscard]]   inline float tanh(  float _Xx) noexcept  {
    return :: tanhf(_Xx);
}

[[nodiscard]]   inline float tgamma(  float _Xx) noexcept  {
    return :: tgammaf(_Xx);
}

[[nodiscard]]   inline float trunc(  float _Xx) noexcept  {

    return __truncf(_Xx);




#line 288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline long double acos(  long double _Xx) noexcept  {
    return :: acosl(_Xx);
}

[[nodiscard]]   inline long double acosh(  long double _Xx) noexcept  {
    return :: acoshl(_Xx);
}

[[nodiscard]]   inline long double asin(  long double _Xx) noexcept  {
    return :: asinl(_Xx);
}

[[nodiscard]]   inline long double asinh(  long double _Xx) noexcept  {
    return :: asinhl(_Xx);
}

[[nodiscard]]   inline long double atan(  long double _Xx) noexcept  {
    return :: atanl(_Xx);
}

[[nodiscard]]   inline long double atanh(  long double _Xx) noexcept  {
    return :: atanhl(_Xx);
}

[[nodiscard]]   inline long double atan2(  long double _Yx,   long double _Xx) noexcept
 {
    return :: atan2l(_Yx, _Xx);
}

[[nodiscard]]   inline long double cbrt(  long double _Xx) noexcept  {
    return :: cbrtl(_Xx);
}

[[nodiscard]]   inline long double ceil(  long double _Xx) noexcept  {

    return __ceil(static_cast<double>(_Xx));




#line 331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline long double copysign(  long double _Number,   long double _Sign) noexcept
 {

    return __copysign(static_cast<double>(_Number), static_cast<double>(_Sign));




#line 342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline long double cos(  long double _Xx) noexcept  {
    return :: cosl(_Xx);
}

[[nodiscard]]   inline long double cosh(  long double _Xx) noexcept  {
    return :: coshl(_Xx);
}

[[nodiscard]]   inline long double erf(  long double _Xx) noexcept  {
    return :: erfl(_Xx);
}

[[nodiscard]]   inline long double erfc(  long double _Xx) noexcept  {
    return :: erfcl(_Xx);
}

[[nodiscard]]   inline long double exp(  long double _Xx) noexcept  {
    return :: expl(_Xx);
}

[[nodiscard]]   inline long double exp2(  long double _Xx) noexcept  {
    return :: exp2l(_Xx);
}

[[nodiscard]]   inline long double expm1(  long double _Xx) noexcept  {
    return :: expm1l(_Xx);
}

[[nodiscard]]   inline long double fabs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

[[nodiscard]]   inline long double fdim(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fdiml(_Xx, _Yx);
}

[[nodiscard]]   inline long double floor(  long double _Xx) noexcept  {

    return __floor(static_cast<double>(_Xx));




#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline long double fma(
      long double _Xx,   long double _Yx,   long double _Zx) noexcept  {
    return :: fmal(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double fmax(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fmaxl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmin(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fminl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmod(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fmodl(_Xx, _Yx);
}

inline long double frexp(  long double _Xx,   int* _Yx) noexcept  {
    return :: frexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double hypot(  long double _Xx,   long double _Yx) noexcept
 {
    return :: hypotl(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  long double _Xx) noexcept  {
    return :: ilogbl(_Xx);
}

[[nodiscard]]   inline long double ldexp(  long double _Xx,   int _Yx) noexcept  {
    return :: ldexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double lgamma(  long double _Xx) noexcept  {
    return :: lgammal(_Xx);
}

[[nodiscard]]   inline long long llrint(  long double _Xx) noexcept  {
    return :: llrintl(_Xx);
}

[[nodiscard]]   inline long long llround(  long double _Xx) noexcept  {
    return :: llroundl(_Xx);
}

[[nodiscard]]   inline long double log(  long double _Xx) noexcept  {
    return :: logl(_Xx);
}

[[nodiscard]]   inline long double log10(  long double _Xx) noexcept  {
    return :: log10l(_Xx);
}

[[nodiscard]]   inline long double log1p(  long double _Xx) noexcept  {
    return :: log1pl(_Xx);
}

[[nodiscard]]   inline long double log2(  long double _Xx) noexcept  {
    return :: log2l(_Xx);
}

[[nodiscard]]   inline long double logb(  long double _Xx) noexcept  {
    return :: logbl(_Xx);
}

[[nodiscard]]   inline long lrint(  long double _Xx) noexcept  {
    return :: lrintl(_Xx);
}

[[nodiscard]]   inline long lround(  long double _Xx) noexcept  {
    return :: lroundl(_Xx);
}

inline long double modf(  long double _Xx,   long double* _Yx) noexcept  {
    return :: modfl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nearbyint(  long double _Xx) noexcept  {
    return :: nearbyintl(_Xx);
}

[[nodiscard]]   inline long double nextafter(  long double _Xx,   long double _Yx) noexcept
 {
    return :: nextafterl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nexttoward(  long double _Xx,   long double _Yx) noexcept
 {
    return :: nexttowardl(_Xx, _Yx);
}

[[nodiscard]]   inline long double pow(  long double _Xx,   long double _Yx) noexcept
 {
    return :: powl(_Xx, _Yx);
}

[[nodiscard]]   inline long double remainder(  long double _Xx,   long double _Yx) noexcept
 {
    return :: remainderl(_Xx, _Yx);
}

inline long double remquo(  long double _Xx,   long double _Yx,   int* _Zx) noexcept  {
    return :: remquol(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double rint(  long double _Xx) noexcept  {
    return :: rintl(_Xx);
}

[[nodiscard]]   inline long double round(  long double _Xx) noexcept  {

    return __round(static_cast<double>(_Xx));




#line 512 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}

[[nodiscard]]   inline long double scalbln(  long double _Xx,   long _Yx) noexcept  {
    return :: scalblnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double scalbn(  long double _Xx,   int _Yx) noexcept  {
    return :: scalbnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double sin(  long double _Xx) noexcept  {
    return :: sinl(_Xx);
}

[[nodiscard]]   inline long double sinh(  long double _Xx) noexcept  {
    return :: sinhl(_Xx);
}

[[nodiscard]]   inline long double sqrt(  long double _Xx) noexcept  {
    return :: sqrtl(_Xx);
}

[[nodiscard]]   inline long double tan(  long double _Xx) noexcept  {
    return :: tanl(_Xx);
}

[[nodiscard]]   inline long double tanh(  long double _Xx) noexcept  {
    return :: tanhl(_Xx);
}

[[nodiscard]]   inline long double tgamma(  long double _Xx) noexcept  {
    return :: tgammal(_Xx);
}

[[nodiscard]]   inline long double trunc(  long double _Xx) noexcept  {

    return __trunc(static_cast<double>(_Xx));




#line 554 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
}


 namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; 
} 


template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value,   int* const _Exp) noexcept  {
    return :: frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty1, class _Ty2, class _Ty3,
    ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
}

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0>
::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
}
















































































































template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0>
[[nodiscard]]   inline int fpclassify(  const _Ty _Ix) noexcept  {
    return _Ix == 0 ? 0 : (-1);
}


template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0>
[[nodiscard]]   inline bool signbit(  const _Ty _Ix) noexcept  {
    if constexpr (static_cast<_Ty>(-1) < _Ty{}) {
        return _Ix < 0;
    } else {
        return false;
    }
}







[[nodiscard]]   inline bool isnormal(  const signed char _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const unsigned char _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const short _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const unsigned short _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const int _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const unsigned int _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const long _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const unsigned long _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const long long _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const unsigned long long _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const bool _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const char _Ix) noexcept { return _Ix != 0; }



[[nodiscard]]   inline bool isnormal(  const char16_t _Ix) noexcept { return _Ix != 0; }
[[nodiscard]]   inline bool isnormal(  const char32_t _Ix) noexcept { return _Ix != 0; }

[[nodiscard]]   inline bool isnormal(  const wchar_t _Ix) noexcept { return _Ix != 0; }
#line 748 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"

















#line 766 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"




























#line 795 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"











#line 807 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"





#line 813 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"




















template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acos(_Ty _Left) noexcept { return :: acos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asin(_Ty _Left) noexcept { return :: asin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atan(_Ty _Left) noexcept { return :: atan(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept { return :: atan2(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cos(_Ty _Left) noexcept { return :: cos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sin(_Ty _Left) noexcept { return :: sin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tan(_Ty _Left) noexcept { return :: tan(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acosh(_Ty _Left) noexcept { return :: acosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asinh(_Ty _Left) noexcept { return :: asinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atanh(_Ty _Left) noexcept { return :: atanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cosh(_Ty _Left) noexcept { return :: cosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sinh(_Ty _Left) noexcept { return :: sinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tanh(_Ty _Left) noexcept { return :: tanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp(_Ty _Left) noexcept { return :: exp(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp2(_Ty _Left) noexcept { return :: exp2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double expm1(_Ty _Left) noexcept { return :: expm1(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] int ilogb(_Ty _Left) noexcept { return :: ilogb(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ldexp(_Ty _Left, int _Arg2) noexcept { return :: ldexp(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log(_Ty _Left) noexcept { return :: log(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log10(_Ty _Left) noexcept { return :: log10(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log1p(_Ty _Left) noexcept { return :: log1p(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log2(_Ty _Left) noexcept { return :: log2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double logb(_Ty _Left) noexcept { return :: logb(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbn(_Ty _Left, int _Arg2) noexcept { return :: scalbn(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbln(_Ty _Left, long _Arg2) noexcept { return :: scalbln(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cbrt(_Ty _Left) noexcept { return :: cbrt(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double fabs(_Ty _Left) noexcept { return :: fabs(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept { return :: hypot(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(_Ty1 _Left, _Ty2 _Right) noexcept { return :: pow(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sqrt(_Ty _Left) noexcept { return :: sqrt(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erf(_Ty _Left) noexcept { return :: erf(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erfc(_Ty _Left) noexcept { return :: erfc(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double lgamma(_Ty _Left) noexcept { return :: lgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tgamma(_Ty _Left) noexcept { return :: tgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ceil(_Ty _Left) noexcept { return __ceil(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double floor(_Ty _Left) noexcept { return __floor(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nearbyint(_Ty _Left) noexcept { return :: nearbyint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double rint(_Ty _Left) noexcept { return :: rint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lrint(_Ty _Left) noexcept { return :: lrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llrint(_Ty _Left) noexcept { return :: llrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double round(_Ty _Left) noexcept { return __round(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lround(_Ty _Left) noexcept { return :: lround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llround(_Ty _Left) noexcept { return :: llround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double trunc(_Ty _Left) noexcept { return __trunc(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmod(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept { return :: remainder(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept { return __copysign(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept { return :: nextafter(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nexttoward(_Ty _Left, long double _Arg2) noexcept { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fdim(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmax(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmin(static_cast<double>(_Left), static_cast<double>(_Right)); }



[[nodiscard]]   inline bool isfinite(  signed char) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  unsigned char) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  short) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  unsigned short) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  int) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  unsigned int) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  long) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  unsigned long) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  long long) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  unsigned long long) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  bool) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  char) noexcept { return true; }  [[nodiscard]]   inline bool isfinite(  char16_t) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  char32_t) noexcept { return true; } [[nodiscard]]   inline bool isfinite(  wchar_t) noexcept { return true; }
[[nodiscard]]   inline bool isinf(  signed char) noexcept { return false; } [[nodiscard]]   inline bool isinf(  unsigned char) noexcept { return false; } [[nodiscard]]   inline bool isinf(  short) noexcept { return false; } [[nodiscard]]   inline bool isinf(  unsigned short) noexcept { return false; } [[nodiscard]]   inline bool isinf(  int) noexcept { return false; } [[nodiscard]]   inline bool isinf(  unsigned int) noexcept { return false; } [[nodiscard]]   inline bool isinf(  long) noexcept { return false; } [[nodiscard]]   inline bool isinf(  unsigned long) noexcept { return false; } [[nodiscard]]   inline bool isinf(  long long) noexcept { return false; } [[nodiscard]]   inline bool isinf(  unsigned long long) noexcept { return false; } [[nodiscard]]   inline bool isinf(  bool) noexcept { return false; } [[nodiscard]]   inline bool isinf(  char) noexcept { return false; }  [[nodiscard]]   inline bool isinf(  char16_t) noexcept { return false; } [[nodiscard]]   inline bool isinf(  char32_t) noexcept { return false; } [[nodiscard]]   inline bool isinf(  wchar_t) noexcept { return false; }
[[nodiscard]]   inline bool isnan(  signed char) noexcept { return false; } [[nodiscard]]   inline bool isnan(  unsigned char) noexcept { return false; } [[nodiscard]]   inline bool isnan(  short) noexcept { return false; } [[nodiscard]]   inline bool isnan(  unsigned short) noexcept { return false; } [[nodiscard]]   inline bool isnan(  int) noexcept { return false; } [[nodiscard]]   inline bool isnan(  unsigned int) noexcept { return false; } [[nodiscard]]   inline bool isnan(  long) noexcept { return false; } [[nodiscard]]   inline bool isnan(  unsigned long) noexcept { return false; } [[nodiscard]]   inline bool isnan(  long long) noexcept { return false; } [[nodiscard]]   inline bool isnan(  unsigned long long) noexcept { return false; } [[nodiscard]]   inline bool isnan(  bool) noexcept { return false; } [[nodiscard]]   inline bool isnan(  char) noexcept { return false; }  [[nodiscard]]   inline bool isnan(  char16_t) noexcept { return false; } [[nodiscard]]   inline bool isnan(  char32_t) noexcept { return false; } [[nodiscard]]   inline bool isnan(  wchar_t) noexcept { return false; }


















 namespace std {
 using :: abs;
 using :: acos;
 using :: asin;
 using :: atan;
 using :: atan2;
 using :: ceil;
 using :: cos;
 using :: cosh;
 using :: exp;
 using :: fabs;
 using :: floor;
 using :: fmod;
 using :: frexp;
 using :: ldexp;
 using :: log;
 using :: log10;
 using :: modf;
 using :: pow;
 using :: sin;
 using :: sinh;
 using :: sqrt;
 using :: tan;
 using :: tanh;

 using :: acosf;
 using :: asinf;
 using :: atanf;
 using :: atan2f;
 using :: ceilf;
 using :: cosf;
 using :: coshf;
 using :: expf;
 using :: fabsf;
 using :: floorf;
 using :: fmodf;
 using :: frexpf;
 using :: ldexpf;
 using :: logf;
 using :: log10f;
 using :: modff;
 using :: powf;
 using :: sinf;
 using :: sinhf;
 using :: sqrtf;
 using :: tanf;
 using :: tanhf;

 using :: acosl;
 using :: asinl;
 using :: atanl;
 using :: atan2l;
 using :: ceill;
 using :: cosl;
 using :: coshl;
 using :: expl;
 using :: fabsl;
 using :: floorl;
 using :: fmodl;
 using :: frexpl;
 using :: ldexpl;
 using :: logl;
 using :: log10l;
 using :: modfl;
 using :: powl;
 using :: sinl;
 using :: sinhl;
 using :: sqrtl;
 using :: tanl;
 using :: tanhl;

 using :: float_t;
 using :: double_t;

 using :: acosh;
 using :: asinh;
 using :: atanh;
 using :: cbrt;
 using :: erf;
 using :: erfc;
 using :: expm1;
 using :: exp2;

inline namespace _Binary_hypot {
     using :: hypot;
} 

 using :: ilogb;
 using :: lgamma;
 using :: log1p;
 using :: log2;
 using :: logb;
 using :: llrint;
 using :: lrint;
 using :: nearbyint;
 using :: rint;
 using :: llround;
 using :: lround;
 using :: fdim;
 using :: fma;
 using :: fmax;
 using :: fmin;
 using :: round;
 using :: trunc;
 using :: remainder;
 using :: remquo;
 using :: copysign;
 using :: nan;
 using :: nextafter;
 using :: scalbn;
 using :: scalbln;
 using :: nexttoward;
 using :: tgamma;

 using :: acoshf;
 using :: asinhf;
 using :: atanhf;
 using :: cbrtf;
 using :: erff;
 using :: erfcf;
 using :: expm1f;
 using :: exp2f;
 using :: hypotf;
 using :: ilogbf;
 using :: lgammaf;
 using :: log1pf;
 using :: log2f;
 using :: logbf;
 using :: llrintf;
 using :: lrintf;
 using :: nearbyintf;
 using :: rintf;
 using :: llroundf;
 using :: lroundf;
 using :: fdimf;
 using :: fmaf;
 using :: fmaxf;
 using :: fminf;
 using :: roundf;
 using :: truncf;
 using :: remainderf;
 using :: remquof;
 using :: copysignf;
 using :: nanf;
 using :: nextafterf;
 using :: scalbnf;
 using :: scalblnf;
 using :: nexttowardf;
 using :: tgammaf;

 using :: acoshl;
 using :: asinhl;
 using :: atanhl;
 using :: cbrtl;
 using :: erfl;
 using :: erfcl;
 using :: expm1l;
 using :: exp2l;
 using :: hypotl;
 using :: ilogbl;
 using :: lgammal;
 using :: log1pl;
 using :: log2l;
 using :: logbl;
 using :: llrintl;
 using :: lrintl;
 using :: nearbyintl;
 using :: rintl;
 using :: llroundl;
 using :: lroundl;
 using :: fdiml;
 using :: fmal;
 using :: fmaxl;
 using :: fminl;
 using :: roundl;
 using :: truncl;
 using :: remainderl;
 using :: remquol;
 using :: copysignl;
 using :: nanl;
 using :: nextafterl;
 using :: scalbnl;
 using :: scalblnl;
 using :: nexttowardl;
 using :: tgammal;

 using :: fpclassify;
 using :: signbit;
 using :: isfinite;
 using :: isinf;
 using :: isnan;
 using :: isnormal;
 using :: isgreater;
 using :: isgreaterequal;
 using :: isless;
 using :: islessequal;
 using :: islessgreater;
 using :: isunordered;
} 


































































































































































































































































































































































































































































































































































































#line 1693 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"



#pragma warning(pop)
#pragma pack(pop)

#line 1700 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
#line 1701 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cmath"
#pragma external_header(pop)
#line 2 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\_fixes.hpp"


























#line 105 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cassert"
#pragma external_header(pop)
#line 4 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
































#line 37 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 39 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"
#pragma once




















#line 23 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 25 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 27 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 29 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"











#line 41 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"















































































































#line 153 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"
















#line 170 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"



#line 174 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"





























































#line 236 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"
























#line 261 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"





































#line 299 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"














































#line 346 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"






#line 353 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 356 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 359 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 362 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 365 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 368 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 371 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 374 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"


#line 377 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"





























#line 407 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"










#line 418 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"
#line 419 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"



#line 423 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 425 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"




#line 430 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 432 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 434 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 436 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 438 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"

#line 440 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"













#line 454 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"




#line 459 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"




#line 464 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"





#line 470 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\simd\\platform.h"
#line 44 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 55 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 59 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
































#line 92 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 96 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 99 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 102 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 105 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 108 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 110 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 112 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"











#line 124 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 127 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 131 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 133 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"









#line 143 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 144 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"











#line 156 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 158 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 160 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





#line 166 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 173 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 178 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 185 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 196 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 201 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 209 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 214 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 221 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 226 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 234 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 239 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 246 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 251 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 259 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 264 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 272 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 277 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 285 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 290 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 298 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





#line 304 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 306 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





#line 312 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





#line 318 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"









#line 328 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 330 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 332 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 335 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 339 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 341 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




#line 346 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 348 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








#line 357 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"












#line 370 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 377 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 379 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





#line 385 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





#line 391 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

































#line 425 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








#line 434 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





#line 440 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 451 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"





















#line 473 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 476 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"















#line 492 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"


#line 495 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"













#line 509 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 516 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"













#line 530 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 534 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 536 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 538 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 549 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 560 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




























#line 589 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 590 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
















#line 607 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 615 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"















#line 631 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

namespace glm
{
	using std::size_t;


#line 638 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
		typedef int length_t;
#line 640 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
}







	namespace glm
	{
		template<typename T, std::size_t N>
		constexpr std::size_t countof(T const (&)[N])
		{
			return N;
		}
	}









#line 666 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"




namespace glm{
namespace detail
{
	template<typename T>
	struct is_int
	{
		enum test {value = 0};
	};

	template<>
	struct is_int<unsigned int>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<signed int>
	{
		enum test {value = ~0};
	};
}

	typedef unsigned int	uint;
}






#line 701 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

namespace glm{
namespace detail
{

		typedef std::uint64_t						uint64;
		typedef std::int64_t						int64;

















#line 726 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
}
}







namespace glm{
namespace detail
{
	using std::make_unsigned;
}
}













































































#line 819 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








#line 828 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 839 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 841 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 843 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 850 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 852 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 863 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"







#line 871 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"














#line 886 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 888 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"






#line 895 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 897 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








#line 906 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"










#line 917 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 919 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 921 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 923 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 927 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 929 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 931 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 933 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 937 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 939 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 941 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 943 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 947 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 949 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 951 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 953 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"



#line 957 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 959 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 961 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 963 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

































































































































































































































#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 107 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"

#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cassert"
#pragma external_header(pop)
#line 115 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\fwd.hpp"
#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"
#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 4 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"

namespace glm
{
	
	enum qualifier
	{
		packed_highp, 
		packed_mediump, 
		packed_lowp, 






#line 20 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"

		highp = packed_highp, 
		mediump = packed_mediump, 
		lowp = packed_lowp, 
		packed = packed_highp, 



#line 29 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"
			defaultp = highp
#line 31 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"
	};

	typedef qualifier precision;

	template<length_t L, typename T, qualifier Q = defaultp> struct vec;
	template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
	template<typename T, qualifier Q = defaultp> struct qua;


		template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
		template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
		template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
		template <typename T, qualifier Q = defaultp> using tquat = qua<T, Q>;
#line 55 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"

namespace detail
{
	template<glm::qualifier P>
	struct is_aligned
	{
		static const bool value = false;
	};



















#line 83 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"

	template<length_t L, typename T, bool is_aligned>
	struct storage
	{
		typedef struct type {
			T data[L];
		} type;
	};


		template<length_t L, typename T>
		struct storage<L, T, true>
		{
			typedef struct alignas(L * sizeof(T)) type {
				T data[L];
			} type;
		};

		template<typename T>
		struct storage<3, T, true>
		{
			typedef struct alignas(4 * sizeof(T)) type {
				T data[4];
			} type;
		};
#line 109 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"





































#line 147 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"






#line 154 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"













#line 168 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"



















#line 188 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\qualifier.hpp"

	enum genTypeEnum
	{
		GENTYPE_VEC,
		GENTYPE_MAT,
		GENTYPE_QUAT
	};

	template <typename genType>
	struct genTypeTrait
	{};

	template <length_t C, length_t R, typename T>
	struct genTypeTrait<mat<C, R, T> >
	{
		static const genTypeEnum GENTYPE = GENTYPE_MAT;
	};

	template<typename genType, genTypeEnum type>
	struct init_gentype
	{
	};

	template<typename genType>
	struct init_gentype<genType, GENTYPE_QUAT>
	{
		 inline constexpr static genType identity()
		{
			return genType(1, 0, 0, 0);
		}
	};

	template<typename genType>
	struct init_gentype<genType, GENTYPE_MAT>
	{
		 inline constexpr static genType identity()
		{
			return genType(1);
		}
	};
}
}
#line 4 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\fwd.hpp"

namespace glm
{

	typedef std::int8_t				int8;
	typedef std::int16_t			int16;
	typedef std::int32_t			int32;
	typedef std::int64_t			int64;

	typedef std::uint8_t			uint8;
	typedef std::uint16_t			uint16;
	typedef std::uint32_t			uint32;
	typedef std::uint64_t			uint64;










#line 28 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\fwd.hpp"

	

	typedef int8					lowp_i8;
	typedef int8					mediump_i8;
	typedef int8					highp_i8;
	typedef int8					i8;

	typedef int8					lowp_int8;
	typedef int8					mediump_int8;
	typedef int8					highp_int8;

	typedef int8					lowp_int8_t;
	typedef int8					mediump_int8_t;
	typedef int8					highp_int8_t;
	typedef int8					int8_t;

	typedef int16					lowp_i16;
	typedef int16					mediump_i16;
	typedef int16					highp_i16;
	typedef int16					i16;

	typedef int16					lowp_int16;
	typedef int16					mediump_int16;
	typedef int16					highp_int16;

	typedef int16					lowp_int16_t;
	typedef int16					mediump_int16_t;
	typedef int16					highp_int16_t;
	typedef int16					int16_t;

	typedef int32					lowp_i32;
	typedef int32					mediump_i32;
	typedef int32					highp_i32;
	typedef int32					i32;

	typedef int32					lowp_int32;
	typedef int32					mediump_int32;
	typedef int32					highp_int32;

	typedef int32					lowp_int32_t;
	typedef int32					mediump_int32_t;
	typedef int32					highp_int32_t;
	typedef int32					int32_t;

	typedef int64					lowp_i64;
	typedef int64					mediump_i64;
	typedef int64					highp_i64;
	typedef int64					i64;

	typedef int64					lowp_int64;
	typedef int64					mediump_int64;
	typedef int64					highp_int64;

	typedef int64					lowp_int64_t;
	typedef int64					mediump_int64_t;
	typedef int64					highp_int64_t;
	typedef int64					int64_t;

	

	typedef unsigned int			uint;

	typedef uint8					lowp_u8;
	typedef uint8					mediump_u8;
	typedef uint8					highp_u8;
	typedef uint8					u8;

	typedef uint8					lowp_uint8;
	typedef uint8					mediump_uint8;
	typedef uint8					highp_uint8;

	typedef uint8					lowp_uint8_t;
	typedef uint8					mediump_uint8_t;
	typedef uint8					highp_uint8_t;
	typedef uint8					uint8_t;

	typedef uint16					lowp_u16;
	typedef uint16					mediump_u16;
	typedef uint16					highp_u16;
	typedef uint16					u16;

	typedef uint16					lowp_uint16;
	typedef uint16					mediump_uint16;
	typedef uint16					highp_uint16;

	typedef uint16					lowp_uint16_t;
	typedef uint16					mediump_uint16_t;
	typedef uint16					highp_uint16_t;
	typedef uint16					uint16_t;

	typedef uint32					lowp_u32;
	typedef uint32					mediump_u32;
	typedef uint32					highp_u32;
	typedef uint32					u32;

	typedef uint32					lowp_uint32;
	typedef uint32					mediump_uint32;
	typedef uint32					highp_uint32;

	typedef uint32					lowp_uint32_t;
	typedef uint32					mediump_uint32_t;
	typedef uint32					highp_uint32_t;
	typedef uint32					uint32_t;

	typedef uint64					lowp_u64;
	typedef uint64					mediump_u64;
	typedef uint64					highp_u64;
	typedef uint64					u64;

	typedef uint64					lowp_uint64;
	typedef uint64					mediump_uint64;
	typedef uint64					highp_uint64;

	typedef uint64					lowp_uint64_t;
	typedef uint64					mediump_uint64_t;
	typedef uint64					highp_uint64_t;
	typedef uint64					uint64_t;

	

	typedef float					lowp_f32;
	typedef float					mediump_f32;
	typedef float					highp_f32;
	typedef float					f32;

	typedef float					lowp_float32;
	typedef float					mediump_float32;
	typedef float					highp_float32;
	typedef float					float32;

	typedef float					lowp_float32_t;
	typedef float					mediump_float32_t;
	typedef float					highp_float32_t;
	typedef float					float32_t;


	typedef double					lowp_f64;
	typedef double					mediump_f64;
	typedef double					highp_f64;
	typedef double					f64;

	typedef double					lowp_float64;
	typedef double					mediump_float64;
	typedef double					highp_float64;
	typedef double					float64;

	typedef double					lowp_float64_t;
	typedef double					mediump_float64_t;
	typedef double					highp_float64_t;
	typedef double					float64_t;

	

	typedef vec<1, bool, lowp>		lowp_bvec1;
	typedef vec<2, bool, lowp>		lowp_bvec2;
	typedef vec<3, bool, lowp>		lowp_bvec3;
	typedef vec<4, bool, lowp>		lowp_bvec4;

	typedef vec<1, bool, mediump>	mediump_bvec1;
	typedef vec<2, bool, mediump>	mediump_bvec2;
	typedef vec<3, bool, mediump>	mediump_bvec3;
	typedef vec<4, bool, mediump>	mediump_bvec4;

	typedef vec<1, bool, highp>		highp_bvec1;
	typedef vec<2, bool, highp>		highp_bvec2;
	typedef vec<3, bool, highp>		highp_bvec3;
	typedef vec<4, bool, highp>		highp_bvec4;

	typedef vec<1, bool, defaultp>	bvec1;
	typedef vec<2, bool, defaultp>	bvec2;
	typedef vec<3, bool, defaultp>	bvec3;
	typedef vec<4, bool, defaultp>	bvec4;

	

	typedef vec<1, int, lowp>		lowp_ivec1;
	typedef vec<2, int, lowp>		lowp_ivec2;
	typedef vec<3, int, lowp>		lowp_ivec3;
	typedef vec<4, int, lowp>		lowp_ivec4;

	typedef vec<1, int, mediump>	mediump_ivec1;
	typedef vec<2, int, mediump>	mediump_ivec2;
	typedef vec<3, int, mediump>	mediump_ivec3;
	typedef vec<4, int, mediump>	mediump_ivec4;

	typedef vec<1, int, highp>		highp_ivec1;
	typedef vec<2, int, highp>		highp_ivec2;
	typedef vec<3, int, highp>		highp_ivec3;
	typedef vec<4, int, highp>		highp_ivec4;

	typedef vec<1, int, defaultp>	ivec1;
	typedef vec<2, int, defaultp>	ivec2;
	typedef vec<3, int, defaultp>	ivec3;
	typedef vec<4, int, defaultp>	ivec4;

	typedef vec<1, i8, lowp>		lowp_i8vec1;
	typedef vec<2, i8, lowp>		lowp_i8vec2;
	typedef vec<3, i8, lowp>		lowp_i8vec3;
	typedef vec<4, i8, lowp>		lowp_i8vec4;

	typedef vec<1, i8, mediump>		mediump_i8vec1;
	typedef vec<2, i8, mediump>		mediump_i8vec2;
	typedef vec<3, i8, mediump>		mediump_i8vec3;
	typedef vec<4, i8, mediump>		mediump_i8vec4;

	typedef vec<1, i8, highp>		highp_i8vec1;
	typedef vec<2, i8, highp>		highp_i8vec2;
	typedef vec<3, i8, highp>		highp_i8vec3;
	typedef vec<4, i8, highp>		highp_i8vec4;

	typedef vec<1, i8, defaultp>	i8vec1;
	typedef vec<2, i8, defaultp>	i8vec2;
	typedef vec<3, i8, defaultp>	i8vec3;
	typedef vec<4, i8, defaultp>	i8vec4;

	typedef vec<1, i16, lowp>		lowp_i16vec1;
	typedef vec<2, i16, lowp>		lowp_i16vec2;
	typedef vec<3, i16, lowp>		lowp_i16vec3;
	typedef vec<4, i16, lowp>		lowp_i16vec4;

	typedef vec<1, i16, mediump>	mediump_i16vec1;
	typedef vec<2, i16, mediump>	mediump_i16vec2;
	typedef vec<3, i16, mediump>	mediump_i16vec3;
	typedef vec<4, i16, mediump>	mediump_i16vec4;

	typedef vec<1, i16, highp>		highp_i16vec1;
	typedef vec<2, i16, highp>		highp_i16vec2;
	typedef vec<3, i16, highp>		highp_i16vec3;
	typedef vec<4, i16, highp>		highp_i16vec4;

	typedef vec<1, i16, defaultp>	i16vec1;
	typedef vec<2, i16, defaultp>	i16vec2;
	typedef vec<3, i16, defaultp>	i16vec3;
	typedef vec<4, i16, defaultp>	i16vec4;

	typedef vec<1, i32, lowp>		lowp_i32vec1;
	typedef vec<2, i32, lowp>		lowp_i32vec2;
	typedef vec<3, i32, lowp>		lowp_i32vec3;
	typedef vec<4, i32, lowp>		lowp_i32vec4;

	typedef vec<1, i32, mediump>	mediump_i32vec1;
	typedef vec<2, i32, mediump>	mediump_i32vec2;
	typedef vec<3, i32, mediump>	mediump_i32vec3;
	typedef vec<4, i32, mediump>	mediump_i32vec4;

	typedef vec<1, i32, highp>		highp_i32vec1;
	typedef vec<2, i32, highp>		highp_i32vec2;
	typedef vec<3, i32, highp>		highp_i32vec3;
	typedef vec<4, i32, highp>		highp_i32vec4;

	typedef vec<1, i32, defaultp>	i32vec1;
	typedef vec<2, i32, defaultp>	i32vec2;
	typedef vec<3, i32, defaultp>	i32vec3;
	typedef vec<4, i32, defaultp>	i32vec4;

	typedef vec<1, i64, lowp>		lowp_i64vec1;
	typedef vec<2, i64, lowp>		lowp_i64vec2;
	typedef vec<3, i64, lowp>		lowp_i64vec3;
	typedef vec<4, i64, lowp>		lowp_i64vec4;

	typedef vec<1, i64, mediump>	mediump_i64vec1;
	typedef vec<2, i64, mediump>	mediump_i64vec2;
	typedef vec<3, i64, mediump>	mediump_i64vec3;
	typedef vec<4, i64, mediump>	mediump_i64vec4;

	typedef vec<1, i64, highp>		highp_i64vec1;
	typedef vec<2, i64, highp>		highp_i64vec2;
	typedef vec<3, i64, highp>		highp_i64vec3;
	typedef vec<4, i64, highp>		highp_i64vec4;

	typedef vec<1, i64, defaultp>	i64vec1;
	typedef vec<2, i64, defaultp>	i64vec2;
	typedef vec<3, i64, defaultp>	i64vec3;
	typedef vec<4, i64, defaultp>	i64vec4;

	

	typedef vec<1, uint, lowp>		lowp_uvec1;
	typedef vec<2, uint, lowp>		lowp_uvec2;
	typedef vec<3, uint, lowp>		lowp_uvec3;
	typedef vec<4, uint, lowp>		lowp_uvec4;

	typedef vec<1, uint, mediump>	mediump_uvec1;
	typedef vec<2, uint, mediump>	mediump_uvec2;
	typedef vec<3, uint, mediump>	mediump_uvec3;
	typedef vec<4, uint, mediump>	mediump_uvec4;

	typedef vec<1, uint, highp>		highp_uvec1;
	typedef vec<2, uint, highp>		highp_uvec2;
	typedef vec<3, uint, highp>		highp_uvec3;
	typedef vec<4, uint, highp>		highp_uvec4;

	typedef vec<1, uint, defaultp>	uvec1;
	typedef vec<2, uint, defaultp>	uvec2;
	typedef vec<3, uint, defaultp>	uvec3;
	typedef vec<4, uint, defaultp>	uvec4;

	typedef vec<1, u8, lowp>		lowp_u8vec1;
	typedef vec<2, u8, lowp>		lowp_u8vec2;
	typedef vec<3, u8, lowp>		lowp_u8vec3;
	typedef vec<4, u8, lowp>		lowp_u8vec4;

	typedef vec<1, u8, mediump>		mediump_u8vec1;
	typedef vec<2, u8, mediump>		mediump_u8vec2;
	typedef vec<3, u8, mediump>		mediump_u8vec3;
	typedef vec<4, u8, mediump>		mediump_u8vec4;

	typedef vec<1, u8, highp>		highp_u8vec1;
	typedef vec<2, u8, highp>		highp_u8vec2;
	typedef vec<3, u8, highp>		highp_u8vec3;
	typedef vec<4, u8, highp>		highp_u8vec4;

	typedef vec<1, u8, defaultp>	u8vec1;
	typedef vec<2, u8, defaultp>	u8vec2;
	typedef vec<3, u8, defaultp>	u8vec3;
	typedef vec<4, u8, defaultp>	u8vec4;

	typedef vec<1, u16, lowp>		lowp_u16vec1;
	typedef vec<2, u16, lowp>		lowp_u16vec2;
	typedef vec<3, u16, lowp>		lowp_u16vec3;
	typedef vec<4, u16, lowp>		lowp_u16vec4;

	typedef vec<1, u16, mediump>	mediump_u16vec1;
	typedef vec<2, u16, mediump>	mediump_u16vec2;
	typedef vec<3, u16, mediump>	mediump_u16vec3;
	typedef vec<4, u16, mediump>	mediump_u16vec4;

	typedef vec<1, u16, highp>		highp_u16vec1;
	typedef vec<2, u16, highp>		highp_u16vec2;
	typedef vec<3, u16, highp>		highp_u16vec3;
	typedef vec<4, u16, highp>		highp_u16vec4;

	typedef vec<1, u16, defaultp>	u16vec1;
	typedef vec<2, u16, defaultp>	u16vec2;
	typedef vec<3, u16, defaultp>	u16vec3;
	typedef vec<4, u16, defaultp>	u16vec4;

	typedef vec<1, u32, lowp>		lowp_u32vec1;
	typedef vec<2, u32, lowp>		lowp_u32vec2;
	typedef vec<3, u32, lowp>		lowp_u32vec3;
	typedef vec<4, u32, lowp>		lowp_u32vec4;

	typedef vec<1, u32, mediump>	mediump_u32vec1;
	typedef vec<2, u32, mediump>	mediump_u32vec2;
	typedef vec<3, u32, mediump>	mediump_u32vec3;
	typedef vec<4, u32, mediump>	mediump_u32vec4;

	typedef vec<1, u32, highp>		highp_u32vec1;
	typedef vec<2, u32, highp>		highp_u32vec2;
	typedef vec<3, u32, highp>		highp_u32vec3;
	typedef vec<4, u32, highp>		highp_u32vec4;

	typedef vec<1, u32, defaultp>	u32vec1;
	typedef vec<2, u32, defaultp>	u32vec2;
	typedef vec<3, u32, defaultp>	u32vec3;
	typedef vec<4, u32, defaultp>	u32vec4;

	typedef vec<1, u64, lowp>		lowp_u64vec1;
	typedef vec<2, u64, lowp>		lowp_u64vec2;
	typedef vec<3, u64, lowp>		lowp_u64vec3;
	typedef vec<4, u64, lowp>		lowp_u64vec4;

	typedef vec<1, u64, mediump>	mediump_u64vec1;
	typedef vec<2, u64, mediump>	mediump_u64vec2;
	typedef vec<3, u64, mediump>	mediump_u64vec3;
	typedef vec<4, u64, mediump>	mediump_u64vec4;

	typedef vec<1, u64, highp>		highp_u64vec1;
	typedef vec<2, u64, highp>		highp_u64vec2;
	typedef vec<3, u64, highp>		highp_u64vec3;
	typedef vec<4, u64, highp>		highp_u64vec4;

	typedef vec<1, u64, defaultp>	u64vec1;
	typedef vec<2, u64, defaultp>	u64vec2;
	typedef vec<3, u64, defaultp>	u64vec3;
	typedef vec<4, u64, defaultp>	u64vec4;

	

	typedef vec<1, float, lowp>			lowp_vec1;
	typedef vec<2, float, lowp>			lowp_vec2;
	typedef vec<3, float, lowp>			lowp_vec3;
	typedef vec<4, float, lowp>			lowp_vec4;

	typedef vec<1, float, mediump>		mediump_vec1;
	typedef vec<2, float, mediump>		mediump_vec2;
	typedef vec<3, float, mediump>		mediump_vec3;
	typedef vec<4, float, mediump>		mediump_vec4;

	typedef vec<1, float, highp>		highp_vec1;
	typedef vec<2, float, highp>		highp_vec2;
	typedef vec<3, float, highp>		highp_vec3;
	typedef vec<4, float, highp>		highp_vec4;

	typedef vec<1, float, defaultp>		vec1;
	typedef vec<2, float, defaultp>		vec2;
	typedef vec<3, float, defaultp>		vec3;
	typedef vec<4, float, defaultp>		vec4;

	typedef vec<1, float, lowp>			lowp_fvec1;
	typedef vec<2, float, lowp>			lowp_fvec2;
	typedef vec<3, float, lowp>			lowp_fvec3;
	typedef vec<4, float, lowp>			lowp_fvec4;

	typedef vec<1, float, mediump>		mediump_fvec1;
	typedef vec<2, float, mediump>		mediump_fvec2;
	typedef vec<3, float, mediump>		mediump_fvec3;
	typedef vec<4, float, mediump>		mediump_fvec4;

	typedef vec<1, float, highp>		highp_fvec1;
	typedef vec<2, float, highp>		highp_fvec2;
	typedef vec<3, float, highp>		highp_fvec3;
	typedef vec<4, float, highp>		highp_fvec4;

	typedef vec<1, f32, defaultp>		fvec1;
	typedef vec<2, f32, defaultp>		fvec2;
	typedef vec<3, f32, defaultp>		fvec3;
	typedef vec<4, f32, defaultp>		fvec4;

	typedef vec<1, f32, lowp>			lowp_f32vec1;
	typedef vec<2, f32, lowp>			lowp_f32vec2;
	typedef vec<3, f32, lowp>			lowp_f32vec3;
	typedef vec<4, f32, lowp>			lowp_f32vec4;

	typedef vec<1, f32, mediump>		mediump_f32vec1;
	typedef vec<2, f32, mediump>		mediump_f32vec2;
	typedef vec<3, f32, mediump>		mediump_f32vec3;
	typedef vec<4, f32, mediump>		mediump_f32vec4;

	typedef vec<1, f32, highp>			highp_f32vec1;
	typedef vec<2, f32, highp>			highp_f32vec2;
	typedef vec<3, f32, highp>			highp_f32vec3;
	typedef vec<4, f32, highp>			highp_f32vec4;

	typedef vec<1, f32, defaultp>		f32vec1;
	typedef vec<2, f32, defaultp>		f32vec2;
	typedef vec<3, f32, defaultp>		f32vec3;
	typedef vec<4, f32, defaultp>		f32vec4;

	typedef vec<1, f64, lowp>			lowp_dvec1;
	typedef vec<2, f64, lowp>			lowp_dvec2;
	typedef vec<3, f64, lowp>			lowp_dvec3;
	typedef vec<4, f64, lowp>			lowp_dvec4;

	typedef vec<1, f64, mediump>		mediump_dvec1;
	typedef vec<2, f64, mediump>		mediump_dvec2;
	typedef vec<3, f64, mediump>		mediump_dvec3;
	typedef vec<4, f64, mediump>		mediump_dvec4;

	typedef vec<1, f64, highp>			highp_dvec1;
	typedef vec<2, f64, highp>			highp_dvec2;
	typedef vec<3, f64, highp>			highp_dvec3;
	typedef vec<4, f64, highp>			highp_dvec4;

	typedef vec<1, f64, defaultp>		dvec1;
	typedef vec<2, f64, defaultp>		dvec2;
	typedef vec<3, f64, defaultp>		dvec3;
	typedef vec<4, f64, defaultp>		dvec4;

	typedef vec<1, f64, lowp>			lowp_f64vec1;
	typedef vec<2, f64, lowp>			lowp_f64vec2;
	typedef vec<3, f64, lowp>			lowp_f64vec3;
	typedef vec<4, f64, lowp>			lowp_f64vec4;

	typedef vec<1, f64, mediump>		mediump_f64vec1;
	typedef vec<2, f64, mediump>		mediump_f64vec2;
	typedef vec<3, f64, mediump>		mediump_f64vec3;
	typedef vec<4, f64, mediump>		mediump_f64vec4;

	typedef vec<1, f64, highp>			highp_f64vec1;
	typedef vec<2, f64, highp>			highp_f64vec2;
	typedef vec<3, f64, highp>			highp_f64vec3;
	typedef vec<4, f64, highp>			highp_f64vec4;

	typedef vec<1, f64, defaultp>		f64vec1;
	typedef vec<2, f64, defaultp>		f64vec2;
	typedef vec<3, f64, defaultp>		f64vec3;
	typedef vec<4, f64, defaultp>		f64vec4;

	

	typedef mat<2, 2, f32, lowp>		lowp_mat2;
	typedef mat<3, 3, f32, lowp>		lowp_mat3;
	typedef mat<4, 4, f32, lowp>		lowp_mat4;

	typedef mat<2, 2, f32, mediump>		mediump_mat2;
	typedef mat<3, 3, f32, mediump>		mediump_mat3;
	typedef mat<4, 4, f32, mediump>		mediump_mat4;

	typedef mat<2, 2, f32, highp>		highp_mat2;
	typedef mat<3, 3, f32, highp>		highp_mat3;
	typedef mat<4, 4, f32, highp>		highp_mat4;

	typedef mat<2, 2, f32, defaultp>	mat2;
	typedef mat<3, 3, f32, defaultp>	mat3;
	typedef mat<4, 4, f32, defaultp>	mat4;

	typedef mat<2, 2, f32, lowp>		lowp_fmat2;
	typedef mat<3, 3, f32, lowp>		lowp_fmat3;
	typedef mat<4, 4, f32, lowp>		lowp_fmat4;

	typedef mat<2, 2, f32, mediump>		mediump_fmat2;
	typedef mat<3, 3, f32, mediump>		mediump_fmat3;
	typedef mat<4, 4, f32, mediump>		mediump_fmat4;

	typedef mat<2, 2, f32, highp>		highp_fmat2;
	typedef mat<3, 3, f32, highp>		highp_fmat3;
	typedef mat<4, 4, f32, highp>		highp_fmat4;

	typedef mat<2, 2, f32, defaultp>	fmat2;
	typedef mat<3, 3, f32, defaultp>	fmat3;
	typedef mat<4, 4, f32, defaultp>	fmat4;

	typedef mat<2, 2, f32, lowp>		lowp_f32mat2;
	typedef mat<3, 3, f32, lowp>		lowp_f32mat3;
	typedef mat<4, 4, f32, lowp>		lowp_f32mat4;

	typedef mat<2, 2, f32, mediump>		mediump_f32mat2;
	typedef mat<3, 3, f32, mediump>		mediump_f32mat3;
	typedef mat<4, 4, f32, mediump>		mediump_f32mat4;

	typedef mat<2, 2, f32, highp>		highp_f32mat2;
	typedef mat<3, 3, f32, highp>		highp_f32mat3;
	typedef mat<4, 4, f32, highp>		highp_f32mat4;

	typedef mat<2, 2, f32, defaultp>	f32mat2;
	typedef mat<3, 3, f32, defaultp>	f32mat3;
	typedef mat<4, 4, f32, defaultp>	f32mat4;

	typedef mat<2, 2, f64, lowp>		lowp_dmat2;
	typedef mat<3, 3, f64, lowp>		lowp_dmat3;
	typedef mat<4, 4, f64, lowp>		lowp_dmat4;

	typedef mat<2, 2, f64, mediump>		mediump_dmat2;
	typedef mat<3, 3, f64, mediump>		mediump_dmat3;
	typedef mat<4, 4, f64, mediump>		mediump_dmat4;

	typedef mat<2, 2, f64, highp>		highp_dmat2;
	typedef mat<3, 3, f64, highp>		highp_dmat3;
	typedef mat<4, 4, f64, highp>		highp_dmat4;

	typedef mat<2, 2, f64, defaultp>	dmat2;
	typedef mat<3, 3, f64, defaultp>	dmat3;
	typedef mat<4, 4, f64, defaultp>	dmat4;

	typedef mat<2, 2, f64, lowp>		lowp_f64mat2;
	typedef mat<3, 3, f64, lowp>		lowp_f64mat3;
	typedef mat<4, 4, f64, lowp>		lowp_f64mat4;

	typedef mat<2, 2, f64, mediump>		mediump_f64mat2;
	typedef mat<3, 3, f64, mediump>		mediump_f64mat3;
	typedef mat<4, 4, f64, mediump>		mediump_f64mat4;

	typedef mat<2, 2, f64, highp>		highp_f64mat2;
	typedef mat<3, 3, f64, highp>		highp_f64mat3;
	typedef mat<4, 4, f64, highp>		highp_f64mat4;

	typedef mat<2, 2, f64, defaultp>	f64mat2;
	typedef mat<3, 3, f64, defaultp>	f64mat3;
	typedef mat<4, 4, f64, defaultp>	f64mat4;

	

	typedef mat<2, 2, f32, lowp>		lowp_mat2x2;
	typedef mat<2, 3, f32, lowp>		lowp_mat2x3;
	typedef mat<2, 4, f32, lowp>		lowp_mat2x4;
	typedef mat<3, 2, f32, lowp>		lowp_mat3x2;
	typedef mat<3, 3, f32, lowp>		lowp_mat3x3;
	typedef mat<3, 4, f32, lowp>		lowp_mat3x4;
	typedef mat<4, 2, f32, lowp>		lowp_mat4x2;
	typedef mat<4, 3, f32, lowp>		lowp_mat4x3;
	typedef mat<4, 4, f32, lowp>		lowp_mat4x4;

	typedef mat<2, 2, f32, mediump>		mediump_mat2x2;
	typedef mat<2, 3, f32, mediump>		mediump_mat2x3;
	typedef mat<2, 4, f32, mediump>		mediump_mat2x4;
	typedef mat<3, 2, f32, mediump>		mediump_mat3x2;
	typedef mat<3, 3, f32, mediump>		mediump_mat3x3;
	typedef mat<3, 4, f32, mediump>		mediump_mat3x4;
	typedef mat<4, 2, f32, mediump>		mediump_mat4x2;
	typedef mat<4, 3, f32, mediump>		mediump_mat4x3;
	typedef mat<4, 4, f32, mediump>		mediump_mat4x4;

	typedef mat<2, 2, f32, highp>		highp_mat2x2;
	typedef mat<2, 3, f32, highp>		highp_mat2x3;
	typedef mat<2, 4, f32, highp>		highp_mat2x4;
	typedef mat<3, 2, f32, highp>		highp_mat3x2;
	typedef mat<3, 3, f32, highp>		highp_mat3x3;
	typedef mat<3, 4, f32, highp>		highp_mat3x4;
	typedef mat<4, 2, f32, highp>		highp_mat4x2;
	typedef mat<4, 3, f32, highp>		highp_mat4x3;
	typedef mat<4, 4, f32, highp>		highp_mat4x4;

	typedef mat<2, 2, f32, defaultp>	mat2x2;
	typedef mat<2, 3, f32, defaultp>	mat2x3;
	typedef mat<2, 4, f32, defaultp>	mat2x4;
	typedef mat<3, 2, f32, defaultp>	mat3x2;
	typedef mat<3, 3, f32, defaultp>	mat3x3;
	typedef mat<3, 4, f32, defaultp>	mat3x4;
	typedef mat<4, 2, f32, defaultp>	mat4x2;
	typedef mat<4, 3, f32, defaultp>	mat4x3;
	typedef mat<4, 4, f32, defaultp>	mat4x4;

	typedef mat<2, 2, f32, lowp>		lowp_fmat2x2;
	typedef mat<2, 3, f32, lowp>		lowp_fmat2x3;
	typedef mat<2, 4, f32, lowp>		lowp_fmat2x4;
	typedef mat<3, 2, f32, lowp>		lowp_fmat3x2;
	typedef mat<3, 3, f32, lowp>		lowp_fmat3x3;
	typedef mat<3, 4, f32, lowp>		lowp_fmat3x4;
	typedef mat<4, 2, f32, lowp>		lowp_fmat4x2;
	typedef mat<4, 3, f32, lowp>		lowp_fmat4x3;
	typedef mat<4, 4, f32, lowp>		lowp_fmat4x4;

	typedef mat<2, 2, f32, mediump>		mediump_fmat2x2;
	typedef mat<2, 3, f32, mediump>		mediump_fmat2x3;
	typedef mat<2, 4, f32, mediump>		mediump_fmat2x4;
	typedef mat<3, 2, f32, mediump>		mediump_fmat3x2;
	typedef mat<3, 3, f32, mediump>		mediump_fmat3x3;
	typedef mat<3, 4, f32, mediump>		mediump_fmat3x4;
	typedef mat<4, 2, f32, mediump>		mediump_fmat4x2;
	typedef mat<4, 3, f32, mediump>		mediump_fmat4x3;
	typedef mat<4, 4, f32, mediump>		mediump_fmat4x4;

	typedef mat<2, 2, f32, highp>		highp_fmat2x2;
	typedef mat<2, 3, f32, highp>		highp_fmat2x3;
	typedef mat<2, 4, f32, highp>		highp_fmat2x4;
	typedef mat<3, 2, f32, highp>		highp_fmat3x2;
	typedef mat<3, 3, f32, highp>		highp_fmat3x3;
	typedef mat<3, 4, f32, highp>		highp_fmat3x4;
	typedef mat<4, 2, f32, highp>		highp_fmat4x2;
	typedef mat<4, 3, f32, highp>		highp_fmat4x3;
	typedef mat<4, 4, f32, highp>		highp_fmat4x4;

	typedef mat<2, 2, f32, defaultp>	fmat2x2;
	typedef mat<2, 3, f32, defaultp>	fmat2x3;
	typedef mat<2, 4, f32, defaultp>	fmat2x4;
	typedef mat<3, 2, f32, defaultp>	fmat3x2;
	typedef mat<3, 3, f32, defaultp>	fmat3x3;
	typedef mat<3, 4, f32, defaultp>	fmat3x4;
	typedef mat<4, 2, f32, defaultp>	fmat4x2;
	typedef mat<4, 3, f32, defaultp>	fmat4x3;
	typedef mat<4, 4, f32, defaultp>	fmat4x4;

	typedef mat<2, 2, f32, lowp>		lowp_f32mat2x2;
	typedef mat<2, 3, f32, lowp>		lowp_f32mat2x3;
	typedef mat<2, 4, f32, lowp>		lowp_f32mat2x4;
	typedef mat<3, 2, f32, lowp>		lowp_f32mat3x2;
	typedef mat<3, 3, f32, lowp>		lowp_f32mat3x3;
	typedef mat<3, 4, f32, lowp>		lowp_f32mat3x4;
	typedef mat<4, 2, f32, lowp>		lowp_f32mat4x2;
	typedef mat<4, 3, f32, lowp>		lowp_f32mat4x3;
	typedef mat<4, 4, f32, lowp>		lowp_f32mat4x4;
	
	typedef mat<2, 2, f32, mediump>		mediump_f32mat2x2;
	typedef mat<2, 3, f32, mediump>		mediump_f32mat2x3;
	typedef mat<2, 4, f32, mediump>		mediump_f32mat2x4;
	typedef mat<3, 2, f32, mediump>		mediump_f32mat3x2;
	typedef mat<3, 3, f32, mediump>		mediump_f32mat3x3;
	typedef mat<3, 4, f32, mediump>		mediump_f32mat3x4;
	typedef mat<4, 2, f32, mediump>		mediump_f32mat4x2;
	typedef mat<4, 3, f32, mediump>		mediump_f32mat4x3;
	typedef mat<4, 4, f32, mediump>		mediump_f32mat4x4;

	typedef mat<2, 2, f32, highp>		highp_f32mat2x2;
	typedef mat<2, 3, f32, highp>		highp_f32mat2x3;
	typedef mat<2, 4, f32, highp>		highp_f32mat2x4;
	typedef mat<3, 2, f32, highp>		highp_f32mat3x2;
	typedef mat<3, 3, f32, highp>		highp_f32mat3x3;
	typedef mat<3, 4, f32, highp>		highp_f32mat3x4;
	typedef mat<4, 2, f32, highp>		highp_f32mat4x2;
	typedef mat<4, 3, f32, highp>		highp_f32mat4x3;
	typedef mat<4, 4, f32, highp>		highp_f32mat4x4;

	typedef mat<2, 2, f32, defaultp>	f32mat2x2;
	typedef mat<2, 3, f32, defaultp>	f32mat2x3;
	typedef mat<2, 4, f32, defaultp>	f32mat2x4;
	typedef mat<3, 2, f32, defaultp>	f32mat3x2;
	typedef mat<3, 3, f32, defaultp>	f32mat3x3;
	typedef mat<3, 4, f32, defaultp>	f32mat3x4;
	typedef mat<4, 2, f32, defaultp>	f32mat4x2;
	typedef mat<4, 3, f32, defaultp>	f32mat4x3;
	typedef mat<4, 4, f32, defaultp>	f32mat4x4;

	typedef mat<2, 2, double, lowp>		lowp_dmat2x2;
	typedef mat<2, 3, double, lowp>		lowp_dmat2x3;
	typedef mat<2, 4, double, lowp>		lowp_dmat2x4;
	typedef mat<3, 2, double, lowp>		lowp_dmat3x2;
	typedef mat<3, 3, double, lowp>		lowp_dmat3x3;
	typedef mat<3, 4, double, lowp>		lowp_dmat3x4;
	typedef mat<4, 2, double, lowp>		lowp_dmat4x2;
	typedef mat<4, 3, double, lowp>		lowp_dmat4x3;
	typedef mat<4, 4, double, lowp>		lowp_dmat4x4;

	typedef mat<2, 2, double, mediump>	mediump_dmat2x2;
	typedef mat<2, 3, double, mediump>	mediump_dmat2x3;
	typedef mat<2, 4, double, mediump>	mediump_dmat2x4;
	typedef mat<3, 2, double, mediump>	mediump_dmat3x2;
	typedef mat<3, 3, double, mediump>	mediump_dmat3x3;
	typedef mat<3, 4, double, mediump>	mediump_dmat3x4;
	typedef mat<4, 2, double, mediump>	mediump_dmat4x2;
	typedef mat<4, 3, double, mediump>	mediump_dmat4x3;
	typedef mat<4, 4, double, mediump>	mediump_dmat4x4;

	typedef mat<2, 2, double, highp>	highp_dmat2x2;
	typedef mat<2, 3, double, highp>	highp_dmat2x3;
	typedef mat<2, 4, double, highp>	highp_dmat2x4;
	typedef mat<3, 2, double, highp>	highp_dmat3x2;
	typedef mat<3, 3, double, highp>	highp_dmat3x3;
	typedef mat<3, 4, double, highp>	highp_dmat3x4;
	typedef mat<4, 2, double, highp>	highp_dmat4x2;
	typedef mat<4, 3, double, highp>	highp_dmat4x3;
	typedef mat<4, 4, double, highp>	highp_dmat4x4;

	typedef mat<2, 2, double, defaultp>	dmat2x2;
	typedef mat<2, 3, double, defaultp>	dmat2x3;
	typedef mat<2, 4, double, defaultp>	dmat2x4;
	typedef mat<3, 2, double, defaultp>	dmat3x2;
	typedef mat<3, 3, double, defaultp>	dmat3x3;
	typedef mat<3, 4, double, defaultp>	dmat3x4;
	typedef mat<4, 2, double, defaultp>	dmat4x2;
	typedef mat<4, 3, double, defaultp>	dmat4x3;
	typedef mat<4, 4, double, defaultp>	dmat4x4;

	typedef mat<2, 2, f64, lowp>		lowp_f64mat2x2;
	typedef mat<2, 3, f64, lowp>		lowp_f64mat2x3;
	typedef mat<2, 4, f64, lowp>		lowp_f64mat2x4;
	typedef mat<3, 2, f64, lowp>		lowp_f64mat3x2;
	typedef mat<3, 3, f64, lowp>		lowp_f64mat3x3;
	typedef mat<3, 4, f64, lowp>		lowp_f64mat3x4;
	typedef mat<4, 2, f64, lowp>		lowp_f64mat4x2;
	typedef mat<4, 3, f64, lowp>		lowp_f64mat4x3;
	typedef mat<4, 4, f64, lowp>		lowp_f64mat4x4;

	typedef mat<2, 2, f64, mediump>		mediump_f64mat2x2;
	typedef mat<2, 3, f64, mediump>		mediump_f64mat2x3;
	typedef mat<2, 4, f64, mediump>		mediump_f64mat2x4;
	typedef mat<3, 2, f64, mediump>		mediump_f64mat3x2;
	typedef mat<3, 3, f64, mediump>		mediump_f64mat3x3;
	typedef mat<3, 4, f64, mediump>		mediump_f64mat3x4;
	typedef mat<4, 2, f64, mediump>		mediump_f64mat4x2;
	typedef mat<4, 3, f64, mediump>		mediump_f64mat4x3;
	typedef mat<4, 4, f64, mediump>		mediump_f64mat4x4;

	typedef mat<2, 2, f64, highp>		highp_f64mat2x2;
	typedef mat<2, 3, f64, highp>		highp_f64mat2x3;
	typedef mat<2, 4, f64, highp>		highp_f64mat2x4;
	typedef mat<3, 2, f64, highp>		highp_f64mat3x2;
	typedef mat<3, 3, f64, highp>		highp_f64mat3x3;
	typedef mat<3, 4, f64, highp>		highp_f64mat3x4;
	typedef mat<4, 2, f64, highp>		highp_f64mat4x2;
	typedef mat<4, 3, f64, highp>		highp_f64mat4x3;
	typedef mat<4, 4, f64, highp>		highp_f64mat4x4;

	typedef mat<2, 2, f64, defaultp>	f64mat2x2;
	typedef mat<2, 3, f64, defaultp>	f64mat2x3;
	typedef mat<2, 4, f64, defaultp>	f64mat2x4;
	typedef mat<3, 2, f64, defaultp>	f64mat3x2;
	typedef mat<3, 3, f64, defaultp>	f64mat3x3;
	typedef mat<3, 4, f64, defaultp>	f64mat3x4;
	typedef mat<4, 2, f64, defaultp>	f64mat4x2;
	typedef mat<4, 3, f64, defaultp>	f64mat4x3;
	typedef mat<4, 4, f64, defaultp>	f64mat4x4;

	

	typedef mat<2, 2, int, lowp>		lowp_imat2x2;
	typedef mat<2, 3, int, lowp>		lowp_imat2x3;
	typedef mat<2, 4, int, lowp>		lowp_imat2x4;
	typedef mat<3, 2, int, lowp>		lowp_imat3x2;
	typedef mat<3, 3, int, lowp>		lowp_imat3x3;
	typedef mat<3, 4, int, lowp>		lowp_imat3x4;
	typedef mat<4, 2, int, lowp>		lowp_imat4x2;
	typedef mat<4, 3, int, lowp>		lowp_imat4x3;
	typedef mat<4, 4, int, lowp>		lowp_imat4x4;

	typedef mat<2, 2, int, mediump>		mediump_imat2x2;
	typedef mat<2, 3, int, mediump>		mediump_imat2x3;
	typedef mat<2, 4, int, mediump>		mediump_imat2x4;
	typedef mat<3, 2, int, mediump>		mediump_imat3x2;
	typedef mat<3, 3, int, mediump>		mediump_imat3x3;
	typedef mat<3, 4, int, mediump>		mediump_imat3x4;
	typedef mat<4, 2, int, mediump>		mediump_imat4x2;
	typedef mat<4, 3, int, mediump>		mediump_imat4x3;
	typedef mat<4, 4, int, mediump>		mediump_imat4x4;

	typedef mat<2, 2, int, highp>		highp_imat2x2;
	typedef mat<2, 3, int, highp>		highp_imat2x3;
	typedef mat<2, 4, int, highp>		highp_imat2x4;
	typedef mat<3, 2, int, highp>		highp_imat3x2;
	typedef mat<3, 3, int, highp>		highp_imat3x3;
	typedef mat<3, 4, int, highp>		highp_imat3x4;
	typedef mat<4, 2, int, highp>		highp_imat4x2;
	typedef mat<4, 3, int, highp>		highp_imat4x3;
	typedef mat<4, 4, int, highp>		highp_imat4x4;

	typedef mat<2, 2, int, defaultp>	imat2x2;
	typedef mat<2, 3, int, defaultp>	imat2x3;
	typedef mat<2, 4, int, defaultp>	imat2x4;
	typedef mat<3, 2, int, defaultp>	imat3x2;
	typedef mat<3, 3, int, defaultp>	imat3x3;
	typedef mat<3, 4, int, defaultp>	imat3x4;
	typedef mat<4, 2, int, defaultp>	imat4x2;
	typedef mat<4, 3, int, defaultp>	imat4x3;
	typedef mat<4, 4, int, defaultp>	imat4x4;


	typedef mat<2, 2, int8, lowp>		lowp_i8mat2x2;
	typedef mat<2, 3, int8, lowp>		lowp_i8mat2x3;
	typedef mat<2, 4, int8, lowp>		lowp_i8mat2x4;
	typedef mat<3, 2, int8, lowp>		lowp_i8mat3x2;
	typedef mat<3, 3, int8, lowp>		lowp_i8mat3x3;
	typedef mat<3, 4, int8, lowp>		lowp_i8mat3x4;
	typedef mat<4, 2, int8, lowp>		lowp_i8mat4x2;
	typedef mat<4, 3, int8, lowp>		lowp_i8mat4x3;
	typedef mat<4, 4, int8, lowp>		lowp_i8mat4x4;

	typedef mat<2, 2, int8, mediump>	mediump_i8mat2x2;
	typedef mat<2, 3, int8, mediump>	mediump_i8mat2x3;
	typedef mat<2, 4, int8, mediump>	mediump_i8mat2x4;
	typedef mat<3, 2, int8, mediump>	mediump_i8mat3x2;
	typedef mat<3, 3, int8, mediump>	mediump_i8mat3x3;
	typedef mat<3, 4, int8, mediump>	mediump_i8mat3x4;
	typedef mat<4, 2, int8, mediump>	mediump_i8mat4x2;
	typedef mat<4, 3, int8, mediump>	mediump_i8mat4x3;
	typedef mat<4, 4, int8, mediump>	mediump_i8mat4x4;

	typedef mat<2, 2, int8, highp>		highp_i8mat2x2;
	typedef mat<2, 3, int8, highp>		highp_i8mat2x3;
	typedef mat<2, 4, int8, highp>		highp_i8mat2x4;
	typedef mat<3, 2, int8, highp>		highp_i8mat3x2;
	typedef mat<3, 3, int8, highp>		highp_i8mat3x3;
	typedef mat<3, 4, int8, highp>		highp_i8mat3x4;
	typedef mat<4, 2, int8, highp>		highp_i8mat4x2;
	typedef mat<4, 3, int8, highp>		highp_i8mat4x3;
	typedef mat<4, 4, int8, highp>		highp_i8mat4x4;

	typedef mat<2, 2, int8, defaultp>	i8mat2x2;
	typedef mat<2, 3, int8, defaultp>	i8mat2x3;
	typedef mat<2, 4, int8, defaultp>	i8mat2x4;
	typedef mat<3, 2, int8, defaultp>	i8mat3x2;
	typedef mat<3, 3, int8, defaultp>	i8mat3x3;
	typedef mat<3, 4, int8, defaultp>	i8mat3x4;
	typedef mat<4, 2, int8, defaultp>	i8mat4x2;
	typedef mat<4, 3, int8, defaultp>	i8mat4x3;
	typedef mat<4, 4, int8, defaultp>	i8mat4x4;


	typedef mat<2, 2, int16, lowp>		lowp_i16mat2x2;
	typedef mat<2, 3, int16, lowp>		lowp_i16mat2x3;
	typedef mat<2, 4, int16, lowp>		lowp_i16mat2x4;
	typedef mat<3, 2, int16, lowp>		lowp_i16mat3x2;
	typedef mat<3, 3, int16, lowp>		lowp_i16mat3x3;
	typedef mat<3, 4, int16, lowp>		lowp_i16mat3x4;
	typedef mat<4, 2, int16, lowp>		lowp_i16mat4x2;
	typedef mat<4, 3, int16, lowp>		lowp_i16mat4x3;
	typedef mat<4, 4, int16, lowp>		lowp_i16mat4x4;

	typedef mat<2, 2, int16, mediump>	mediump_i16mat2x2;
	typedef mat<2, 3, int16, mediump>	mediump_i16mat2x3;
	typedef mat<2, 4, int16, mediump>	mediump_i16mat2x4;
	typedef mat<3, 2, int16, mediump>	mediump_i16mat3x2;
	typedef mat<3, 3, int16, mediump>	mediump_i16mat3x3;
	typedef mat<3, 4, int16, mediump>	mediump_i16mat3x4;
	typedef mat<4, 2, int16, mediump>	mediump_i16mat4x2;
	typedef mat<4, 3, int16, mediump>	mediump_i16mat4x3;
	typedef mat<4, 4, int16, mediump>	mediump_i16mat4x4;

	typedef mat<2, 2, int16, highp>		highp_i16mat2x2;
	typedef mat<2, 3, int16, highp>		highp_i16mat2x3;
	typedef mat<2, 4, int16, highp>		highp_i16mat2x4;
	typedef mat<3, 2, int16, highp>		highp_i16mat3x2;
	typedef mat<3, 3, int16, highp>		highp_i16mat3x3;
	typedef mat<3, 4, int16, highp>		highp_i16mat3x4;
	typedef mat<4, 2, int16, highp>		highp_i16mat4x2;
	typedef mat<4, 3, int16, highp>		highp_i16mat4x3;
	typedef mat<4, 4, int16, highp>		highp_i16mat4x4;

	typedef mat<2, 2, int16, defaultp>	i16mat2x2;
	typedef mat<2, 3, int16, defaultp>	i16mat2x3;
	typedef mat<2, 4, int16, defaultp>	i16mat2x4;
	typedef mat<3, 2, int16, defaultp>	i16mat3x2;
	typedef mat<3, 3, int16, defaultp>	i16mat3x3;
	typedef mat<3, 4, int16, defaultp>	i16mat3x4;
	typedef mat<4, 2, int16, defaultp>	i16mat4x2;
	typedef mat<4, 3, int16, defaultp>	i16mat4x3;
	typedef mat<4, 4, int16, defaultp>	i16mat4x4;


	typedef mat<2, 2, int32, lowp>		lowp_i32mat2x2;
	typedef mat<2, 3, int32, lowp>		lowp_i32mat2x3;
	typedef mat<2, 4, int32, lowp>		lowp_i32mat2x4;
	typedef mat<3, 2, int32, lowp>		lowp_i32mat3x2;
	typedef mat<3, 3, int32, lowp>		lowp_i32mat3x3;
	typedef mat<3, 4, int32, lowp>		lowp_i32mat3x4;
	typedef mat<4, 2, int32, lowp>		lowp_i32mat4x2;
	typedef mat<4, 3, int32, lowp>		lowp_i32mat4x3;
	typedef mat<4, 4, int32, lowp>		lowp_i32mat4x4;

	typedef mat<2, 2, int32, mediump>	mediump_i32mat2x2;
	typedef mat<2, 3, int32, mediump>	mediump_i32mat2x3;
	typedef mat<2, 4, int32, mediump>	mediump_i32mat2x4;
	typedef mat<3, 2, int32, mediump>	mediump_i32mat3x2;
	typedef mat<3, 3, int32, mediump>	mediump_i32mat3x3;
	typedef mat<3, 4, int32, mediump>	mediump_i32mat3x4;
	typedef mat<4, 2, int32, mediump>	mediump_i32mat4x2;
	typedef mat<4, 3, int32, mediump>	mediump_i32mat4x3;
	typedef mat<4, 4, int32, mediump>	mediump_i32mat4x4;

	typedef mat<2, 2, int32, highp>		highp_i32mat2x2;
	typedef mat<2, 3, int32, highp>		highp_i32mat2x3;
	typedef mat<2, 4, int32, highp>		highp_i32mat2x4;
	typedef mat<3, 2, int32, highp>		highp_i32mat3x2;
	typedef mat<3, 3, int32, highp>		highp_i32mat3x3;
	typedef mat<3, 4, int32, highp>		highp_i32mat3x4;
	typedef mat<4, 2, int32, highp>		highp_i32mat4x2;
	typedef mat<4, 3, int32, highp>		highp_i32mat4x3;
	typedef mat<4, 4, int32, highp>		highp_i32mat4x4;

	typedef mat<2, 2, int32, defaultp>	i32mat2x2;
	typedef mat<2, 3, int32, defaultp>	i32mat2x3;
	typedef mat<2, 4, int32, defaultp>	i32mat2x4;
	typedef mat<3, 2, int32, defaultp>	i32mat3x2;
	typedef mat<3, 3, int32, defaultp>	i32mat3x3;
	typedef mat<3, 4, int32, defaultp>	i32mat3x4;
	typedef mat<4, 2, int32, defaultp>	i32mat4x2;
	typedef mat<4, 3, int32, defaultp>	i32mat4x3;
	typedef mat<4, 4, int32, defaultp>	i32mat4x4;


	typedef mat<2, 2, int64, lowp>		lowp_i64mat2x2;
	typedef mat<2, 3, int64, lowp>		lowp_i64mat2x3;
	typedef mat<2, 4, int64, lowp>		lowp_i64mat2x4;
	typedef mat<3, 2, int64, lowp>		lowp_i64mat3x2;
	typedef mat<3, 3, int64, lowp>		lowp_i64mat3x3;
	typedef mat<3, 4, int64, lowp>		lowp_i64mat3x4;
	typedef mat<4, 2, int64, lowp>		lowp_i64mat4x2;
	typedef mat<4, 3, int64, lowp>		lowp_i64mat4x3;
	typedef mat<4, 4, int64, lowp>		lowp_i64mat4x4;

	typedef mat<2, 2, int64, mediump>	mediump_i64mat2x2;
	typedef mat<2, 3, int64, mediump>	mediump_i64mat2x3;
	typedef mat<2, 4, int64, mediump>	mediump_i64mat2x4;
	typedef mat<3, 2, int64, mediump>	mediump_i64mat3x2;
	typedef mat<3, 3, int64, mediump>	mediump_i64mat3x3;
	typedef mat<3, 4, int64, mediump>	mediump_i64mat3x4;
	typedef mat<4, 2, int64, mediump>	mediump_i64mat4x2;
	typedef mat<4, 3, int64, mediump>	mediump_i64mat4x3;
	typedef mat<4, 4, int64, mediump>	mediump_i64mat4x4;

	typedef mat<2, 2, int64, highp>		highp_i64mat2x2;
	typedef mat<2, 3, int64, highp>		highp_i64mat2x3;
	typedef mat<2, 4, int64, highp>		highp_i64mat2x4;
	typedef mat<3, 2, int64, highp>		highp_i64mat3x2;
	typedef mat<3, 3, int64, highp>		highp_i64mat3x3;
	typedef mat<3, 4, int64, highp>		highp_i64mat3x4;
	typedef mat<4, 2, int64, highp>		highp_i64mat4x2;
	typedef mat<4, 3, int64, highp>		highp_i64mat4x3;
	typedef mat<4, 4, int64, highp>		highp_i64mat4x4;

	typedef mat<2, 2, int64, defaultp>	i64mat2x2;
	typedef mat<2, 3, int64, defaultp>	i64mat2x3;
	typedef mat<2, 4, int64, defaultp>	i64mat2x4;
	typedef mat<3, 2, int64, defaultp>	i64mat3x2;
	typedef mat<3, 3, int64, defaultp>	i64mat3x3;
	typedef mat<3, 4, int64, defaultp>	i64mat3x4;
	typedef mat<4, 2, int64, defaultp>	i64mat4x2;
	typedef mat<4, 3, int64, defaultp>	i64mat4x3;
	typedef mat<4, 4, int64, defaultp>	i64mat4x4;


	

	typedef mat<2, 2, uint, lowp>		lowp_umat2x2;
	typedef mat<2, 3, uint, lowp>		lowp_umat2x3;
	typedef mat<2, 4, uint, lowp>		lowp_umat2x4;
	typedef mat<3, 2, uint, lowp>		lowp_umat3x2;
	typedef mat<3, 3, uint, lowp>		lowp_umat3x3;
	typedef mat<3, 4, uint, lowp>		lowp_umat3x4;
	typedef mat<4, 2, uint, lowp>		lowp_umat4x2;
	typedef mat<4, 3, uint, lowp>		lowp_umat4x3;
	typedef mat<4, 4, uint, lowp>		lowp_umat4x4;

	typedef mat<2, 2, uint, mediump>	mediump_umat2x2;
	typedef mat<2, 3, uint, mediump>	mediump_umat2x3;
	typedef mat<2, 4, uint, mediump>	mediump_umat2x4;
	typedef mat<3, 2, uint, mediump>	mediump_umat3x2;
	typedef mat<3, 3, uint, mediump>	mediump_umat3x3;
	typedef mat<3, 4, uint, mediump>	mediump_umat3x4;
	typedef mat<4, 2, uint, mediump>	mediump_umat4x2;
	typedef mat<4, 3, uint, mediump>	mediump_umat4x3;
	typedef mat<4, 4, uint, mediump>	mediump_umat4x4;

	typedef mat<2, 2, uint, highp>		highp_umat2x2;
	typedef mat<2, 3, uint, highp>		highp_umat2x3;
	typedef mat<2, 4, uint, highp>		highp_umat2x4;
	typedef mat<3, 2, uint, highp>		highp_umat3x2;
	typedef mat<3, 3, uint, highp>		highp_umat3x3;
	typedef mat<3, 4, uint, highp>		highp_umat3x4;
	typedef mat<4, 2, uint, highp>		highp_umat4x2;
	typedef mat<4, 3, uint, highp>		highp_umat4x3;
	typedef mat<4, 4, uint, highp>		highp_umat4x4;

	typedef mat<2, 2, uint, defaultp>	umat2x2;
	typedef mat<2, 3, uint, defaultp>	umat2x3;
	typedef mat<2, 4, uint, defaultp>	umat2x4;
	typedef mat<3, 2, uint, defaultp>	umat3x2;
	typedef mat<3, 3, uint, defaultp>	umat3x3;
	typedef mat<3, 4, uint, defaultp>	umat3x4;
	typedef mat<4, 2, uint, defaultp>	umat4x2;
	typedef mat<4, 3, uint, defaultp>	umat4x3;
	typedef mat<4, 4, uint, defaultp>	umat4x4;


	typedef mat<2, 2, uint8, lowp>		lowp_u8mat2x2;
	typedef mat<2, 3, uint8, lowp>		lowp_u8mat2x3;
	typedef mat<2, 4, uint8, lowp>		lowp_u8mat2x4;
	typedef mat<3, 2, uint8, lowp>		lowp_u8mat3x2;
	typedef mat<3, 3, uint8, lowp>		lowp_u8mat3x3;
	typedef mat<3, 4, uint8, lowp>		lowp_u8mat3x4;
	typedef mat<4, 2, uint8, lowp>		lowp_u8mat4x2;
	typedef mat<4, 3, uint8, lowp>		lowp_u8mat4x3;
	typedef mat<4, 4, uint8, lowp>		lowp_u8mat4x4;

	typedef mat<2, 2, uint8, mediump>	mediump_u8mat2x2;
	typedef mat<2, 3, uint8, mediump>	mediump_u8mat2x3;
	typedef mat<2, 4, uint8, mediump>	mediump_u8mat2x4;
	typedef mat<3, 2, uint8, mediump>	mediump_u8mat3x2;
	typedef mat<3, 3, uint8, mediump>	mediump_u8mat3x3;
	typedef mat<3, 4, uint8, mediump>	mediump_u8mat3x4;
	typedef mat<4, 2, uint8, mediump>	mediump_u8mat4x2;
	typedef mat<4, 3, uint8, mediump>	mediump_u8mat4x3;
	typedef mat<4, 4, uint8, mediump>	mediump_u8mat4x4;

	typedef mat<2, 2, uint8, highp>		highp_u8mat2x2;
	typedef mat<2, 3, uint8, highp>		highp_u8mat2x3;
	typedef mat<2, 4, uint8, highp>		highp_u8mat2x4;
	typedef mat<3, 2, uint8, highp>		highp_u8mat3x2;
	typedef mat<3, 3, uint8, highp>		highp_u8mat3x3;
	typedef mat<3, 4, uint8, highp>		highp_u8mat3x4;
	typedef mat<4, 2, uint8, highp>		highp_u8mat4x2;
	typedef mat<4, 3, uint8, highp>		highp_u8mat4x3;
	typedef mat<4, 4, uint8, highp>		highp_u8mat4x4;

	typedef mat<2, 2, uint8, defaultp>	u8mat2x2;
	typedef mat<2, 3, uint8, defaultp>	u8mat2x3;
	typedef mat<2, 4, uint8, defaultp>	u8mat2x4;
	typedef mat<3, 2, uint8, defaultp>	u8mat3x2;
	typedef mat<3, 3, uint8, defaultp>	u8mat3x3;
	typedef mat<3, 4, uint8, defaultp>	u8mat3x4;
	typedef mat<4, 2, uint8, defaultp>	u8mat4x2;
	typedef mat<4, 3, uint8, defaultp>	u8mat4x3;
	typedef mat<4, 4, uint8, defaultp>	u8mat4x4;


	typedef mat<2, 2, uint16, lowp>		lowp_u16mat2x2;
	typedef mat<2, 3, uint16, lowp>		lowp_u16mat2x3;
	typedef mat<2, 4, uint16, lowp>		lowp_u16mat2x4;
	typedef mat<3, 2, uint16, lowp>		lowp_u16mat3x2;
	typedef mat<3, 3, uint16, lowp>		lowp_u16mat3x3;
	typedef mat<3, 4, uint16, lowp>		lowp_u16mat3x4;
	typedef mat<4, 2, uint16, lowp>		lowp_u16mat4x2;
	typedef mat<4, 3, uint16, lowp>		lowp_u16mat4x3;
	typedef mat<4, 4, uint16, lowp>		lowp_u16mat4x4;

	typedef mat<2, 2, uint16, mediump>	mediump_u16mat2x2;
	typedef mat<2, 3, uint16, mediump>	mediump_u16mat2x3;
	typedef mat<2, 4, uint16, mediump>	mediump_u16mat2x4;
	typedef mat<3, 2, uint16, mediump>	mediump_u16mat3x2;
	typedef mat<3, 3, uint16, mediump>	mediump_u16mat3x3;
	typedef mat<3, 4, uint16, mediump>	mediump_u16mat3x4;
	typedef mat<4, 2, uint16, mediump>	mediump_u16mat4x2;
	typedef mat<4, 3, uint16, mediump>	mediump_u16mat4x3;
	typedef mat<4, 4, uint16, mediump>	mediump_u16mat4x4;

	typedef mat<2, 2, uint16, highp>	highp_u16mat2x2;
	typedef mat<2, 3, uint16, highp>	highp_u16mat2x3;
	typedef mat<2, 4, uint16, highp>	highp_u16mat2x4;
	typedef mat<3, 2, uint16, highp>	highp_u16mat3x2;
	typedef mat<3, 3, uint16, highp>	highp_u16mat3x3;
	typedef mat<3, 4, uint16, highp>	highp_u16mat3x4;
	typedef mat<4, 2, uint16, highp>	highp_u16mat4x2;
	typedef mat<4, 3, uint16, highp>	highp_u16mat4x3;
	typedef mat<4, 4, uint16, highp>	highp_u16mat4x4;

	typedef mat<2, 2, uint16, defaultp>	u16mat2x2;
	typedef mat<2, 3, uint16, defaultp>	u16mat2x3;
	typedef mat<2, 4, uint16, defaultp>	u16mat2x4;
	typedef mat<3, 2, uint16, defaultp>	u16mat3x2;
	typedef mat<3, 3, uint16, defaultp>	u16mat3x3;
	typedef mat<3, 4, uint16, defaultp>	u16mat3x4;
	typedef mat<4, 2, uint16, defaultp>	u16mat4x2;
	typedef mat<4, 3, uint16, defaultp>	u16mat4x3;
	typedef mat<4, 4, uint16, defaultp>	u16mat4x4;


	typedef mat<2, 2, uint32, lowp>		lowp_u32mat2x2;
	typedef mat<2, 3, uint32, lowp>		lowp_u32mat2x3;
	typedef mat<2, 4, uint32, lowp>		lowp_u32mat2x4;
	typedef mat<3, 2, uint32, lowp>		lowp_u32mat3x2;
	typedef mat<3, 3, uint32, lowp>		lowp_u32mat3x3;
	typedef mat<3, 4, uint32, lowp>		lowp_u32mat3x4;
	typedef mat<4, 2, uint32, lowp>		lowp_u32mat4x2;
	typedef mat<4, 3, uint32, lowp>		lowp_u32mat4x3;
	typedef mat<4, 4, uint32, lowp>		lowp_u32mat4x4;

	typedef mat<2, 2, uint32, mediump>	mediump_u32mat2x2;
	typedef mat<2, 3, uint32, mediump>	mediump_u32mat2x3;
	typedef mat<2, 4, uint32, mediump>	mediump_u32mat2x4;
	typedef mat<3, 2, uint32, mediump>	mediump_u32mat3x2;
	typedef mat<3, 3, uint32, mediump>	mediump_u32mat3x3;
	typedef mat<3, 4, uint32, mediump>	mediump_u32mat3x4;
	typedef mat<4, 2, uint32, mediump>	mediump_u32mat4x2;
	typedef mat<4, 3, uint32, mediump>	mediump_u32mat4x3;
	typedef mat<4, 4, uint32, mediump>	mediump_u32mat4x4;

	typedef mat<2, 2, uint32, highp>	highp_u32mat2x2;
	typedef mat<2, 3, uint32, highp>	highp_u32mat2x3;
	typedef mat<2, 4, uint32, highp>	highp_u32mat2x4;
	typedef mat<3, 2, uint32, highp>	highp_u32mat3x2;
	typedef mat<3, 3, uint32, highp>	highp_u32mat3x3;
	typedef mat<3, 4, uint32, highp>	highp_u32mat3x4;
	typedef mat<4, 2, uint32, highp>	highp_u32mat4x2;
	typedef mat<4, 3, uint32, highp>	highp_u32mat4x3;
	typedef mat<4, 4, uint32, highp>	highp_u32mat4x4;

	typedef mat<2, 2, uint32, defaultp>	u32mat2x2;
	typedef mat<2, 3, uint32, defaultp>	u32mat2x3;
	typedef mat<2, 4, uint32, defaultp>	u32mat2x4;
	typedef mat<3, 2, uint32, defaultp>	u32mat3x2;
	typedef mat<3, 3, uint32, defaultp>	u32mat3x3;
	typedef mat<3, 4, uint32, defaultp>	u32mat3x4;
	typedef mat<4, 2, uint32, defaultp>	u32mat4x2;
	typedef mat<4, 3, uint32, defaultp>	u32mat4x3;
	typedef mat<4, 4, uint32, defaultp>	u32mat4x4;


	typedef mat<2, 2, uint64, lowp>		lowp_u64mat2x2;
	typedef mat<2, 3, uint64, lowp>		lowp_u64mat2x3;
	typedef mat<2, 4, uint64, lowp>		lowp_u64mat2x4;
	typedef mat<3, 2, uint64, lowp>		lowp_u64mat3x2;
	typedef mat<3, 3, uint64, lowp>		lowp_u64mat3x3;
	typedef mat<3, 4, uint64, lowp>		lowp_u64mat3x4;
	typedef mat<4, 2, uint64, lowp>		lowp_u64mat4x2;
	typedef mat<4, 3, uint64, lowp>		lowp_u64mat4x3;
	typedef mat<4, 4, uint64, lowp>		lowp_u64mat4x4;

	typedef mat<2, 2, uint64, mediump>	mediump_u64mat2x2;
	typedef mat<2, 3, uint64, mediump>	mediump_u64mat2x3;
	typedef mat<2, 4, uint64, mediump>	mediump_u64mat2x4;
	typedef mat<3, 2, uint64, mediump>	mediump_u64mat3x2;
	typedef mat<3, 3, uint64, mediump>	mediump_u64mat3x3;
	typedef mat<3, 4, uint64, mediump>	mediump_u64mat3x4;
	typedef mat<4, 2, uint64, mediump>	mediump_u64mat4x2;
	typedef mat<4, 3, uint64, mediump>	mediump_u64mat4x3;
	typedef mat<4, 4, uint64, mediump>	mediump_u64mat4x4;

	typedef mat<2, 2, uint64, highp>	highp_u64mat2x2;
	typedef mat<2, 3, uint64, highp>	highp_u64mat2x3;
	typedef mat<2, 4, uint64, highp>	highp_u64mat2x4;
	typedef mat<3, 2, uint64, highp>	highp_u64mat3x2;
	typedef mat<3, 3, uint64, highp>	highp_u64mat3x3;
	typedef mat<3, 4, uint64, highp>	highp_u64mat3x4;
	typedef mat<4, 2, uint64, highp>	highp_u64mat4x2;
	typedef mat<4, 3, uint64, highp>	highp_u64mat4x3;
	typedef mat<4, 4, uint64, highp>	highp_u64mat4x4;

	typedef mat<2, 2, uint64, defaultp>	u64mat2x2;
	typedef mat<2, 3, uint64, defaultp>	u64mat2x3;
	typedef mat<2, 4, uint64, defaultp>	u64mat2x4;
	typedef mat<3, 2, uint64, defaultp>	u64mat3x2;
	typedef mat<3, 3, uint64, defaultp>	u64mat3x3;
	typedef mat<3, 4, uint64, defaultp>	u64mat3x4;
	typedef mat<4, 2, uint64, defaultp>	u64mat4x2;
	typedef mat<4, 3, uint64, defaultp>	u64mat4x3;
	typedef mat<4, 4, uint64, defaultp>	u64mat4x4;

	

	typedef qua<float, lowp>			lowp_quat;
	typedef qua<float, mediump>			mediump_quat;
	typedef qua<float, highp>			highp_quat;
	typedef qua<float, defaultp>		quat;

	typedef qua<float, lowp>			lowp_fquat;
	typedef qua<float, mediump>			mediump_fquat;
	typedef qua<float, highp>			highp_fquat;
	typedef qua<float, defaultp>		fquat;

	typedef qua<f32, lowp>				lowp_f32quat;
	typedef qua<f32, mediump>			mediump_f32quat;
	typedef qua<f32, highp>				highp_f32quat;
	typedef qua<f32, defaultp>			f32quat;

	typedef qua<double, lowp>			lowp_dquat;
	typedef qua<double, mediump>		mediump_dquat;
	typedef qua<double, highp>			highp_dquat;
	typedef qua<double, defaultp>		dquat;

	typedef qua<f64, lowp>				lowp_f64quat;
	typedef qua<f64, mediump>			mediump_f64quat;
	typedef qua<f64, highp>				highp_f64quat;
	typedef qua<f64, defaultp>			f64quat;
}


#line 116 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"



#pragma once




#line 10 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"

#line 12 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<2, T, Q>
	{
		

		typedef T value_type;
		typedef vec<2, T, Q> type;
		typedef vec<2, bool, Q> bool_type;

		





#line 32 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"



#line 36 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  
#line 39 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
#line 40 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"






#line 47 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"




















#line 68 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
			union {T x, r, s;};
			union {T y, g, t;};



#line 74 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
#line 75 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"




#line 80 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"

#line 82 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
#pragma warning(pop)
#line 84 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
#line 85 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"

		

		
		typedef length_t length_type;
		  static constexpr length_type length(){return 2;}

		  constexpr T& operator[](length_type i);
		  constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;
		template<qualifier P>
		 constexpr vec(vec<2, T, P> const& v);

		

		 constexpr explicit vec(T scalar);
		 constexpr vec(T x, T y);

		

		template<typename U, qualifier P>
		 constexpr explicit vec(vec<1, U, P> const& v);

		
		template<typename A, typename B>
		 constexpr vec(A x, B y);
		template<typename A, typename B>
		 constexpr vec(vec<1, A, Q> const& x, B y);
		template<typename A, typename B>
		 constexpr vec(A x, vec<1, B, Q> const& y);
		template<typename A, typename B>
		 constexpr vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);

		

		
		template<typename U, qualifier P>
		 constexpr  vec(vec<3, U, P> const& v);
		
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);

		
		template<typename U, qualifier P>
		 constexpr  vec(vec<2, U, P> const& v);

		






#line 143 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"

		

		 constexpr vec<2, T, Q> & operator=(vec const& v) = default;

		template<typename U>
		 constexpr vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator+=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator-=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator*=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator/=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);

		

		 constexpr vec<2, T, Q> & operator++();
		 constexpr vec<2, T, Q> & operator--();
		  constexpr vec<2, T, Q> operator++(int);
		  constexpr vec<2, T, Q> operator--(int);

		

		template<typename U>
		 constexpr vec<2, T, Q> & operator%=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator&=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator|=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator^=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator<<=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator>>=(U scalar);
		template<typename U>
		 constexpr vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.inl"


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\compute_vector_relational.hpp"
#pragma once


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 5 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\compute_vector_relational.hpp"


namespace glm{
namespace detail
{
	template <typename T, bool isFloat>
	struct compute_equal
	{
		 inline constexpr static bool call(T a, T b)
		{
			return a == b;
		}
	};











}
}
#line 4 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.inl"

namespace glm
{
	








#line 17 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.inl"






#line 24 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<2, T, P> const& v)
		: x(v.x), y(v.y)
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q>::vec(T scalar)
		: x(scalar), y(scalar)
	{}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q>::vec(T _x, T _y)
		: x(_x), y(_y)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	 inline constexpr vec<2, T, Q>::vec(A _x, B _y)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	 inline constexpr vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B>
	 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<2, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<2, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.inl", (unsigned)(108)), 0)) ));
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		}
	}

	template<typename T, qualifier Q>
	 inline constexpr T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.inl", (unsigned)(122)), 0)) ));
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		}
	}

	









#line 144 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.inl"

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		this->y /= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator++(int)
	{
		vec<2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator--(int)
	{
		vec<2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		this->y %= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		this->y &= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		this->y |= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		this->y ^= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		this->y <<= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			-v.x,
			-v.y);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x + scalar,
			v.y + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.y + v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar + v.x,
			scalar + v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.x + v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x + v2.x,
			v1.y + v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x - scalar,
			v.y - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.y - v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar - v.x,
			scalar - v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.x - v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x - v2.x,
			v1.y - v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x * scalar,
			v.y * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.y * v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar * v.x,
			scalar * v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.x * v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x * v2.x,
			v1.y * v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x / scalar,
			v.y / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.y / v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar / v.x,
			scalar / v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.x / v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x / v2.x,
			v1.y / v2.y);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x % scalar,
			v.y % scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.y % v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar % v.x,
			scalar % v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.x % v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x % v2.x,
			v1.y % v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x & scalar,
			v.y & scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.y & v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar & v.x,
			scalar & v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.x & v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x & v2.x,
			v1.y & v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x | scalar,
			v.y | scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.y | v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar | v.x,
			scalar | v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.x | v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x | v2.x,
			v1.y | v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x ^ scalar,
			v.y ^ scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar ^ v.x,
			scalar ^ v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.x ^ v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x << scalar,
			v.y << scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.y << v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar << v.x,
			scalar << v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.x << v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x << v2.x,
			v1.y << v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
	{
		return vec<2, T, Q>(
			v.x >> scalar,
			v.y >> scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			scalar >> v.x,
			scalar >> v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.x >> v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return vec<2, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v)
	{
		return vec<2, T, Q>(
			~v.x,
			~v.y);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
	{
		return !(v1 == v2);
	}

	template<qualifier Q>
	 inline constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
	{
		return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
	}

	template<qualifier Q>
	 inline constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
	{
		return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
	}
}
#line 402 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
#line 403 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec2.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool2.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<2, bool, defaultp>		bvec2;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<2, bool, highp>		highp_bvec2;

	
	
	
	
	typedef vec<2, bool, mediump>	mediump_bvec2;

	
	
	
	
	typedef vec<2, bool, lowp>		lowp_bvec2;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_float2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, float, defaultp>	vec2;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_float2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<2, float, highp>		highp_vec2;

	
	
	
	
	typedef vec<2, float, mediump>		mediump_vec2;

	
	
	
	
	typedef vec<2, float, lowp>			lowp_vec2;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_double2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, double, defaultp>		dvec2;

	
}
#line 10 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_double2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<2, double, highp>		highp_dvec2;

	
	
	
	
	typedef vec<2, double, mediump>		mediump_dvec2;

	
	
	
	
	typedef vec<2, double, lowp>		lowp_dvec2;

	
}
#line 11 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, int, defaultp>		ivec2;

	
}
#line 12 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int2_sized.hpp"













#pragma once


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_int_sized.hpp"












#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 16 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_int_sized.hpp"



#line 20 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_int_sized.hpp"

namespace glm{
namespace detail
{

		typedef std::int8_t			int8;
		typedef std::int16_t		int16;
		typedef std::int32_t		int32;




#line 33 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_int_sized.hpp"

	template<>
	struct is_int<int8>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<int16>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<int64>
	{
		enum test {value = ~0};
	};
}


	
	

	
	typedef detail::int8		int8;

	
	typedef detail::int16		int16;

	
	typedef detail::int32		int32;

	
	typedef detail::int64		int64;

	
}
#line 18 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int2_sized.hpp"



#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<2, int8, defaultp>		i8vec2;

	
	
	
	typedef vec<2, int16, defaultp>		i16vec2;

	
	
	
	typedef vec<2, int32, defaultp>		i32vec2;

	
	
	
	typedef vec<2, int64, defaultp>		i64vec2;

	
}
#line 13 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<2, unsigned int, defaultp>		uvec2;

	
}
#line 14 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint2_sized.hpp"













#pragma once


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_uint_sized.hpp"












#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 16 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_uint_sized.hpp"



#line 20 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_uint_sized.hpp"

namespace glm{
namespace detail
{

		typedef std::uint8_t		uint8;
		typedef std::uint16_t		uint16;
		typedef std::uint32_t		uint32;




#line 33 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\scalar_uint_sized.hpp"

	template<>
	struct is_int<uint8>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<uint16>
	{
		enum test {value = ~0};
	};

	template<>
	struct is_int<uint64>
	{
		enum test {value = ~0};
	};
}


	
	

	
	typedef detail::uint8		uint8;

	
	typedef detail::uint16		uint16;

	
	typedef detail::uint32		uint32;

	
	typedef detail::uint64		uint64;

	
}
#line 18 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint2_sized.hpp"



#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint2_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<2, uint8, defaultp>		u8vec2;

	
	
	
	typedef vec<2, uint16, defaultp>	u16vec2;

	
	
	
	typedef vec<2, uint32, defaultp>	u32vec2;

	
	
	
	typedef vec<2, uint64, defaultp>	u64vec2;

	
}
#line 15 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec2.hpp"
#line 118 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"



#pragma once




#line 10 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"

#line 12 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<3, T, Q>
	{
		

		typedef T value_type;
		typedef vec<3, T, Q> type;
		typedef vec<3, bool, Q> bool_type;

		





#line 32 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"




#line 37 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  


#line 42 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#line 43 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#line 44 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"






#line 51 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"




















#line 72 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };



#line 79 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#line 80 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"




#line 85 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"

#line 87 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#pragma warning(pop)
#line 89 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#line 90 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"

		

		
		typedef length_t length_type;
		  static constexpr length_type length(){return 3;}

		  constexpr T & operator[](length_type i);
		  constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;
		template<qualifier P>
		 constexpr vec(vec<3, T, P> const& v);

		

		 constexpr explicit vec(T scalar);
		 constexpr vec(T a, T b, T c);

		

		template<typename U, qualifier P>
		 constexpr explicit vec(vec<1, U, P> const& v);

		
		template<typename X, typename Y, typename Z>
		 constexpr vec(X x, Y y, Z z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
		template<typename X, typename Y, typename Z>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);

		

		
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, B _z);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(A _x, vec<2, B, P> const& _yz);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);
		
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);

		
		template<typename U, qualifier P>
		 constexpr  vec(vec<3, U, P> const& v);

		


















#line 177 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"

		

		 constexpr vec<3, T, Q>& operator=(vec<3, T, Q> const& v) = default;

		template<typename U>
		 constexpr vec<3, T, Q> & operator=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator+=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator+=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator-=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator-=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator*=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator*=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator/=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator/=(vec<3, U, Q> const& v);

		

		 constexpr vec<3, T, Q> & operator++();
		 constexpr vec<3, T, Q> & operator--();
		  constexpr vec<3, T, Q> operator++(int);
		  constexpr vec<3, T, Q> operator--(int);

		

		template<typename U>
		 constexpr vec<3, T, Q> & operator%=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator%=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator&=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator&=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator|=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator|=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator^=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator^=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator<<=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator<<=(vec<3, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator>>=(U scalar);
		template<typename U>
		 constexpr vec<3, T, Q> & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<3, T, Q> & operator>>=(vec<3, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.inl"




namespace glm
{
	








#line 17 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.inl"






#line 24 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<3, T, P> const& v)
		: x(v.x), y(v.y), z(v.z)
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar)
	{}

	template <typename T, qualifier Q>
	 inline constexpr vec<3, T, Q>::vec(T _x, T _y, T _z)
		: x(_x), y(_y), z(_z)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.x))
		, z(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, Z _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z>
	 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
	{}

	

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<3, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.inl", (unsigned)(172)), 0)) ));
		switch(i)
		{
		default:
			case 0:
		return x;
			case 1:
		return y;
			case 2:
		return z;
		}
	}

	template<typename T, qualifier Q>
	 inline constexpr T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.inl", (unsigned)(188)), 0)) ));
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		}
	}

	










#line 213 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.inl"

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		this->z += static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		this->z += static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		this->z -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		this->z -= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		this->y *= static_cast<T>(scalar);
		this->z *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		this->z *= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
	{
		this->x /= static_cast<T>(v);
		this->y /= static_cast<T>(v);
		this->z /= static_cast<T>(v);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		this->z /= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator++(int)
	{
		vec<3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator--(int)
	{
		vec<3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
	{
		this->x %= scalar;
		this->y %= scalar;
		this->z %= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= v.x;
		this->y %= v.x;
		this->z %= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
	{
		this->x %= v.x;
		this->y %= v.y;
		this->z %= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
	{
		this->x &= scalar;
		this->y &= scalar;
		this->z &= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= v.x;
		this->y &= v.x;
		this->z &= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
	{
		this->x &= v.x;
		this->y &= v.y;
		this->z &= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
	{
		this->x |= scalar;
		this->y |= scalar;
		this->z |= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= v.x;
		this->y |= v.x;
		this->z |= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
	{
		this->x |= v.x;
		this->y |= v.y;
		this->z |= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
	{
		this->x ^= scalar;
		this->y ^= scalar;
		this->z ^= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= v.x;
		this->y ^= v.x;
		this->z ^= v.x;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
	{
		this->x ^= v.x;
		this->y ^= v.y;
		this->z ^= v.z;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
	{
		this->x <<= scalar;
		this->y <<= scalar;
		this->z <<= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		this->z <<= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		this->z <<= static_cast<T>(v.z);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		this->z >>= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		this->z >>= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			-v.x,
			-v.y,
			-v.z);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x + scalar,
			v.y + scalar,
			v.z + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x + scalar.x,
			v.y + scalar.x,
			v.z + scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar + v.x,
			scalar + v.y,
			scalar + v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x + v.x,
			scalar.x + v.y,
			scalar.x + v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x - scalar,
			v.y - scalar,
			v.z - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x - scalar.x,
			v.y - scalar.x,
			v.z - scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar - v.x,
			scalar - v.y,
			scalar - v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x - v.x,
			scalar.x - v.y,
			scalar.x - v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x * scalar,
			v.y * scalar,
			v.z * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x * scalar.x,
			v.y * scalar.x,
			v.z * scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar * v.x,
			scalar * v.y,
			scalar * v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x * v.x,
			scalar.x * v.y,
			scalar.x * v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x / scalar,
			v.y / scalar,
			v.z / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x / scalar.x,
			v.y / scalar.x,
			v.z / scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar / v.x,
			scalar / v.y,
			scalar / v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x / v.x,
			scalar.x / v.y,
			scalar.x / v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x % scalar,
			v.y % scalar,
			v.z % scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x % scalar.x,
			v.y % scalar.x,
			v.z % scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar % v.x,
			scalar % v.y,
			scalar % v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x % v.x,
			scalar.x % v.y,
			scalar.x % v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x & scalar,
			v.y & scalar,
			v.z & scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x & scalar.x,
			v.y & scalar.x,
			v.z & scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar & v.x,
			scalar & v.y,
			scalar & v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x & v.x,
			scalar.x & v.y,
			scalar.x & v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x | scalar,
			v.y | scalar,
			v.z | scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x | scalar.x,
			v.y | scalar.x,
			v.z | scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar | v.x,
			scalar | v.y,
			scalar | v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x | v.x,
			scalar.x | v.y,
			scalar.x | v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x ^ scalar,
			v.y ^ scalar,
			v.z ^ scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x ^ scalar.x,
			v.y ^ scalar.x,
			v.z ^ scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar ^ v.x,
			scalar ^ v.y,
			scalar ^ v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x ^ v.x,
			scalar.x ^ v.y,
			scalar.x ^ v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x << scalar,
			v.y << scalar,
			v.z << scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x << scalar.x,
			v.y << scalar.x,
			v.z << scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar << v.x,
			scalar << v.y,
			scalar << v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x << v.x,
			scalar.x << v.y,
			scalar.x << v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
	{
		return vec<3, T, Q>(
			v.x >> scalar,
			v.y >> scalar,
			v.z >> scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<3, T, Q>(
			v.x >> scalar.x,
			v.y >> scalar.x,
			v.z >> scalar.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar >> v.x,
			scalar >> v.y,
			scalar >> v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			scalar.x >> v.x,
			scalar.x >> v.y,
			scalar.x >> v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return vec<3, T, Q>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v)
	{
		return vec<3, T, Q>(
			~v.x,
			~v.y,
			~v.z);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
			detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
	{
		return !(v1 == v2);
	}

	template<qualifier Q>
	 inline constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
	{
		return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
	}

	template<qualifier Q>
	 inline constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
	{
		return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
	}
}
#line 436 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#line 437 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec3.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool3.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<3, bool, defaultp>		bvec3;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<3, bool, highp>		highp_bvec3;

	
	
	
	
	typedef vec<3, bool, mediump>	mediump_bvec3;

	
	
	
	
	typedef vec<3, bool, lowp>		lowp_bvec3;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_float3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, float, defaultp>		vec3;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_float3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<3, float, highp>		highp_vec3;

	
	
	
	
	typedef vec<3, float, mediump>		mediump_vec3;

	
	
	
	
	typedef vec<3, float, lowp>			lowp_vec3;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_double3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, double, defaultp>		dvec3;

	
}
#line 10 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_double3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	
	typedef vec<3, double, highp>		highp_dvec3;

	
	
	
	
	
	typedef vec<3, double, mediump>		mediump_dvec3;

	
	
	
	
	
	typedef vec<3, double, lowp>		lowp_dvec3;

	
}
#line 11 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, int, defaultp>		ivec3;

	
}
#line 12 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int3_sized.hpp"













#pragma once






#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<3, int8, defaultp>		i8vec3;

	
	
	
	typedef vec<3, int16, defaultp>		i16vec3;

	
	
	
	typedef vec<3, int32, defaultp>		i32vec3;

	
	
	
	typedef vec<3, int64, defaultp>		i64vec3;

	
}
#line 13 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<3, unsigned int, defaultp>		uvec3;

	
}
#line 14 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint3_sized.hpp"













#pragma once






#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint3_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<3, uint8, defaultp>		u8vec3;

	
	
	
	typedef vec<3, uint16, defaultp>	u16vec3;

	
	
	
	typedef vec<3, uint32, defaultp>	u32vec3;

	
	
	
	typedef vec<3, uint64, defaultp>	u64vec3;

	
}
#line 15 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec3.hpp"
#line 119 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"



#pragma once




#line 10 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"

#line 12 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<4, T, Q>
	{
		

		typedef T value_type;
		typedef vec<4, T, Q> type;
		typedef vec<4, bool, Q> bool_type;

		





#line 32 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"



#line 36 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  
#line 39 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
#line 40 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"






#line 47 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"




















#line 68 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
			union { T x, r, s; };
			union { T y, g, t; };
			union { T z, b, p; };
			union { T w, a, q; };



#line 76 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
#line 77 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"




#line 82 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"

#line 84 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
#pragma warning(pop)
#line 86 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
#line 87 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"

		

		typedef length_t length_type;

		
		  static constexpr length_type length(){return 4;}

		  constexpr T & operator[](length_type i);
		  constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default;
		 constexpr vec(vec<4, T, Q> const& v) = default;
		template<qualifier P>
		 constexpr vec(vec<4, T, P> const& v);

		

		 constexpr explicit vec(T scalar);
		 constexpr vec(T x, T y, T z, T w);

		

		template<typename U, qualifier P>
		 constexpr explicit vec(vec<1, U, P> const& v);

		
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(X _x, Y _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
		template<typename X, typename Y, typename Z, typename W>
		 constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);

		

		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, B _z, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(A _x, vec<2, B, P> const& _yz, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(A _x, B _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, typename C, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<3, A, P> const& _xyz, B _w);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(A _x, vec<3, B, P> const& _yzw);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);
		
		template<typename A, typename B, qualifier P>
		 constexpr vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);

		
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);

		










































#line 249 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"

		

		 constexpr vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default;

		template<typename U>
		 constexpr vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator+=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator-=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator*=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator/=(U scalar);
		template<typename U>
		 constexpr vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);

		

		 constexpr vec<4, T, Q> & operator++();
		 constexpr vec<4, T, Q> & operator--();
		  constexpr vec<4, T, Q> operator++(int);
		  constexpr vec<4, T, Q> operator--(int);

		

		template<typename U>
		  constexpr vec<4, T, Q> & operator%=(U scalar);
		template<typename U>
		  constexpr vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator&=(U scalar);
		template<typename U>
		  constexpr vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator|=(U scalar);
		template<typename U>
		  constexpr vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator^=(U scalar);
		template<typename U>
		  constexpr vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator<<=(U scalar);
		template<typename U>
		  constexpr vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator>>=(U scalar);
		template<typename U>
		  constexpr vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
		template<typename U>
		  constexpr vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.inl"




namespace glm{
namespace detail
{
	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_add
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_sub
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_mul
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_div
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_vec4_mod
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_and
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_or
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_xor
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_left
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_shift_right
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_equal
	{
		 inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
		{
			return
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
				detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_nequal
	{
		 inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
		{
			return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
		}
	};

	template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
	struct compute_vec4_bitwise_not
	{
		 inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& v)
		{
			return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
		}
	};
}

	








#line 140 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.inl"






#line 147 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<4, T, P> const& v)
		: x(v.x), y(v.y), z(v.z), w(v.w)
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q>::vec(T scalar)
		: x(scalar), y(scalar), z(scalar), w(scalar)
	{}

	template <typename T, qualifier Q>
	 inline constexpr vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
		: x(_x), y(_y), z(_z), w(_w)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.x))
		, z(static_cast<T>(v.x))
		, w(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename X, typename Y, typename Z, typename W>
	 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_z.x))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yz.x))
		, z(static_cast<T>(_yz.y))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, typename C, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_y.x))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
		: x(static_cast<T>(_xyz.x))
		, y(static_cast<T>(_xyz.y))
		, z(static_cast<T>(_xyz.z))
		, w(static_cast<T>(_w))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
		: x(static_cast<T>(_xyz.x))
		, y(static_cast<T>(_xyz.y))
		, z(static_cast<T>(_xyz.z))
		, w(static_cast<T>(_w.x))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
		: x(static_cast<T>(_x))
		, y(static_cast<T>(_yzw.x))
		, z(static_cast<T>(_yzw.y))
		, w(static_cast<T>(_yzw.z))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
		: x(static_cast<T>(_x.x))
		, y(static_cast<T>(_yzw.x))
		, z(static_cast<T>(_yzw.y))
		, w(static_cast<T>(_yzw.z))
	{}

	template<typename T, qualifier Q>
	template<typename A, typename B, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
		: x(static_cast<T>(_xy.x))
		, y(static_cast<T>(_xy.y))
		, z(static_cast<T>(_zw.x))
		, w(static_cast<T>(_zw.y))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<4, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
		, z(static_cast<T>(v.z))
		, w(static_cast<T>(v.w))
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.inl", (unsigned)(481)), 0)) ));
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		case 3:
			return w;
		}
	}

	template<typename T, qualifier Q>
	 inline constexpr T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.inl", (unsigned)(499)), 0)) ));
		switch(i)
		{
		default:
		case 0:
			return x;
		case 1:
			return y;
		case 2:
			return z;
		case 3:
			return w;
		}
	}

	











#line 527 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.inl"

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		this->w = static_cast<T>(v.w);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		++this->w;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		--this->w;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator++(int)
	{
		vec<4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator--(int)
	{
		vec<4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
	{
		return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(0) -= v;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) += scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) += v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(v) += scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v2) += v1;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) += v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) -= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) -= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) -= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) -= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) -= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) *= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) *= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(v) *= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v2) *= v1;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) *= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) /= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) /= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) /= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) /= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) /= v2;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) %= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) %= v2.x;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) %= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar.x) %= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) %= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) &= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
	{
		return vec<4, T, Q>(v) &= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) &= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) &= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) &= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) |= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) |= v2.x;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) |= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) |= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) |= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) ^= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) ^= v2.x;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) ^= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) ^= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) ^= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) <<= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) <<= v2.x;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) <<= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) <<= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) <<= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
	{
		return vec<4, T, Q>(v) >>= scalar;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) >>= v2.x;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
	{
		return vec<4, T, Q>(scalar) >>= v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1.x) >>= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return vec<4, T, Q>(v1) >>= v2;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v)
	{
		return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
	{
		return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
	}

	template<qualifier Q>
	 inline constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
	{
		return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
	}

	template<qualifier Q>
	 inline constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
	{
		return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
	}
}



#line 1143 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.inl"
#line 508 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
#line 509 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec4.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool4.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<4, bool, defaultp>		bvec4;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_bool4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<4, bool, highp>		highp_bvec4;

	
	
	
	
	typedef vec<4, bool, mediump>	mediump_bvec4;

	
	
	
	
	typedef vec<4, bool, lowp>		lowp_bvec4;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_float4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, float, defaultp>		vec4;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_float4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef vec<4, float, highp>		highp_vec4;

	
	
	
	
	typedef vec<4, float, mediump>		mediump_vec4;

	
	
	
	
	typedef vec<4, float, lowp>			lowp_vec4;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_double4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, double, defaultp>		dvec4;

	
}
#line 10 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_double4_precision.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_double4_precision.hpp"


namespace glm
{
	
	

	
	
	
	
	
	typedef vec<4, double, highp>		highp_dvec4;

	
	
	
	
	
	typedef vec<4, double, mediump>		mediump_dvec4;

	
	
	
	
	
	typedef vec<4, double, lowp>		lowp_dvec4;

	
}
#line 11 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, int, defaultp>		ivec4;

	
}
#line 12 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int4_sized.hpp"













#pragma once






#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_int4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<4, int8, defaultp>		i8vec4;

	
	
	
	typedef vec<4, int16, defaultp>		i16vec4;

	
	
	
	typedef vec<4, int32, defaultp>		i32vec4;

	
	
	
	typedef vec<4, int64, defaultp>		i64vec4;

	
}
#line 13 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef vec<4, unsigned int, defaultp>		uvec4;

	
}
#line 14 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint4_sized.hpp"













#pragma once






#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\vector_uint4_sized.hpp"

namespace glm
{
	
	

	
	
	
	typedef vec<4, uint8, defaultp>		u8vec4;

	
	
	
	typedef vec<4, uint16, defaultp>	u16vec4;

	
	
	
	typedef vec<4, uint32, defaultp>	u32vec4;

	
	
	
	typedef vec<4, uint64, defaultp>	u64vec4;

	
}
#line 15 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vec4.hpp"

#line 120 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.hpp"



#pragma once





namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 2, T, Q> type;
		typedef mat<2, 2, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 2; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<2, 2, T, P> const& m);

		 constexpr  mat(T scalar);
		 constexpr mat(
			T const& x1, T const& y1,
			T const& x2, T const& y2);
		 constexpr mat(
			col_type const& v1,
			col_type const& v2);

		

		template<typename U, typename V, typename M, typename N>
		 constexpr mat(
			U const& x1, V const& y1,
			M const& x2, N const& y2);

		template<typename U, typename V>
		 constexpr mat(
			vec<2, U, Q> const& v1,
			vec<2, V, Q> const& v2);

		

		template<typename U, qualifier P>
		 constexpr  mat(mat<2, 2, U, P> const& m);

		 constexpr  mat(mat<3, 3, T, Q> const& x);
		 constexpr  mat(mat<4, 4, T, Q> const& x);
		 constexpr  mat(mat<2, 3, T, Q> const& x);
		 constexpr  mat(mat<3, 2, T, Q> const& x);
		 constexpr  mat(mat<2, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator/=(U s);
		template<typename U>
		 constexpr mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);

		

		 constexpr mat<2, 2, T, Q> & operator++ ();
		 constexpr mat<2, 2, T, Q> & operator-- ();
		  constexpr mat<2, 2, T, Q> operator++(int);
		  constexpr mat<2, 2, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
} 


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"












#pragma once



#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 18 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"




#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 3, T, Q> type;
		typedef mat<3, 2, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 2; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<2, 3, T, P> const& m);

		 constexpr  mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1);

		

		template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2);

		template<typename U, typename V>
		 constexpr mat(
			vec<3, U, Q> const& v1,
			vec<3, V, Q> const& v2);

		

		template<typename U, qualifier P>
		 constexpr  mat(mat<2, 3, U, P> const& m);

		 constexpr  mat(mat<2, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 3, T, Q> const& x);
		 constexpr  mat(mat<4, 4, T, Q> const& x);
		 constexpr  mat(mat<2, 4, T, Q> const& x);
		 constexpr  mat(mat<3, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 2, T, Q> const& x);
		 constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<2, 3, T, Q> & operator/=(U s);

		

		 constexpr mat<2, 3, T, Q> & operator++ ();
		 constexpr mat<2, 3, T, Q> & operator-- ();
		  constexpr mat<2, 3, T, Q> operator++(int);
		  constexpr mat<2, 3, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
namespace glm
{
	













#line 18 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 25 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 30 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(T scalar)

			: value{col_type(scalar, 0, 0), col_type(0, scalar, 0)}
#line 37 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 42 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1)}
#line 53 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 58 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)

			: value{col_type(v0), col_type(v1)}
#line 65 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 70 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2>
	 inline constexpr mat<2, 3, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2
	)

			: value{col_type(x1, y1, z1), col_type(x2, y2, z2)}
#line 86 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 91 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	 inline constexpr mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 99 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 104 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 114 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 119 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 126 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 131 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr  mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 138 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 143 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

		: value{col_type(m[0]), col_type(m[1])}
#line 150 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 155 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 162 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 167 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 174 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 179 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 186 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 191 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 198 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 203 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 210 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	{



#line 215 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl", (unsigned)(222)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.inl", (unsigned)(229)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
	{
		mat<2, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
	{
		mat<2, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			-m[0],
			-m[1]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 3, T, Q>::col_type operator*
	(
		mat<2, 3, T, Q> const& m,
		typename mat<2, 3, T, Q>::row_type const& v)
	{
		return typename mat<2, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 3, T, Q>::row_type operator*
	(
		typename mat<2, 3, T, Q>::col_type const& v,
		mat<2, 3, T, Q> const& m)
	{
		return typename mat<2, 3, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];

		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
	{
		return mat<2, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
	{
		return mat<2, 3, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 159 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.hpp"
#line 160 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x3.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, double, defaultp>		dmat2x3;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 3, double, lowp>		lowp_dmat2x3;

	
	
	
	
	typedef mat<2, 3, double, mediump>	mediump_dmat2x3;

	
	
	
	
	typedef mat<2, 3, double, highp>	highp_dmat2x3;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float2x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 3, float, defaultp>		mat2x3;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float2x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 3, float, lowp>		lowp_mat2x3;

	
	
	
	
	typedef mat<2, 3, float, mediump>	mediump_mat2x3;

	
	
	
	
	typedef mat<2, 3, float, highp>		highp_mat2x3;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x3.hpp"

#line 23 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<2, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<2, T, Q> row_type;
		typedef mat<2, 4, T, Q> type;
		typedef mat<4, 2, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[2];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 2; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<2, 4, T, P> const& m);

		 constexpr  mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2);

		template<typename U, typename V>
		 constexpr mat(
			vec<4, U, Q> const& v1,
			vec<4, V, Q> const& v2);

		

		template<typename U, qualifier P>
		 constexpr  mat(mat<2, 4, U, P> const& m);

		 constexpr  mat(mat<2, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 3, T, Q> const& x);
		 constexpr  mat(mat<4, 4, T, Q> const& x);
		 constexpr  mat(mat<2, 3, T, Q> const& x);
		 constexpr  mat(mat<3, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 2, T, Q> const& x);
		 constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<2, 4, T, Q> & operator/=(U s);

		

		 constexpr mat<2, 4, T, Q> & operator++ ();
		 constexpr mat<2, 4, T, Q> & operator-- ();
		  constexpr mat<2, 4, T, Q> operator++(int);
		  constexpr mat<2, 4, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
namespace glm
{
	













#line 18 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 25 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 30 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0)}
#line 37 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 42 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1
	)

			: value{col_type(x0, y0, z0, w0), col_type(x1, y1, z1, w1)}
#line 53 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 58 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)

			: value{col_type(v0), col_type(v1)}
#line 65 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 70 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 inline constexpr mat<2, 4, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)

			: value{
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 88 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 93 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	 inline constexpr mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 101 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 106 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 116 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 121 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 128 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 133 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 140 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 145 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 152 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 157 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 164 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 169 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 176 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 181 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 188 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 193 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}
#line 200 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 205 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0)}
#line 212 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	{



#line 217 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl", (unsigned)(224)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.inl", (unsigned)(231)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
	{
		mat<2, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
	{
		mat<2, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			-m[0],
			-m[1]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
	{
		return typename mat<2, 4, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
	{
		return typename mat<2, 4, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA03 = m1[0][3];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcA13 = m1[1][3];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		T SrcB30 = m2[3][0];
		T SrcB31 = m2[3][1];

		mat<4, 4, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
	{
		return mat<2, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
	{
		return mat<2, 4, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 161 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.hpp"
#line 162 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x4.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, double, defaultp>		dmat2x4;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 4, double, lowp>		lowp_dmat2x4;

	
	
	
	
	typedef mat<2, 4, double, mediump>	mediump_dmat2x4;

	
	
	
	
	typedef mat<2, 4, double, highp>	highp_dmat2x4;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float2x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 4, float, defaultp>		mat2x4;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float2x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 4, float, lowp>		lowp_mat2x4;

	
	
	
	
	typedef mat<2, 4, float, mediump>	mediump_mat2x4;

	
	
	
	
	typedef mat<2, 4, float, highp>		highp_mat2x4;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x4.hpp"

#line 24 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 2, T, Q> type;
		typedef mat<2, 3, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 3; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<3, 2, T, P> const& m);

		 constexpr  mat(T scalar);
		 constexpr mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
			 constexpr mat(
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template<typename V1, typename V2, typename V3>
		 constexpr mat(
			vec<2, V1, Q> const& v1,
			vec<2, V2, Q> const& v2,
			vec<2, V3, Q> const& v3);

		

		template<typename U, qualifier P>
		 constexpr  mat(mat<3, 2, U, P> const& m);

		 constexpr  mat(mat<2, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 3, T, Q> const& x);
		 constexpr  mat(mat<4, 4, T, Q> const& x);
		 constexpr  mat(mat<2, 3, T, Q> const& x);
		 constexpr  mat(mat<2, 4, T, Q> const& x);
		 constexpr  mat(mat<3, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 2, T, Q> const& x);
		 constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<3, 2, T, Q> & operator/=(U s);

		

		 constexpr mat<3, 2, T, Q> & operator++ ();
		 constexpr mat<3, 2, T, Q> & operator-- ();
		  constexpr mat<3, 2, T, Q> operator++(int);
		  constexpr mat<3, 2, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
namespace glm
{
	














#line 19 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 26 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 32 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(T s)

			: value{col_type(s, 0), col_type(0, s), col_type(0, 0)}
#line 39 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 45 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}
#line 57 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 63 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 70 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 76 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0,
		typename X1, typename Y1,
		typename X2, typename Y2>
	 inline constexpr mat<3, 2, T, Q>::mat
	(
		X0 x0, Y0 y0,
		X1 x1, Y1 y1,
		X2 x2, Y2 y2
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}
#line 94 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 100 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	template<typename V0, typename V1, typename V2>
	 inline constexpr mat<3, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 108 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 114 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 124 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 130 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 137 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 143 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 150 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 156 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 163 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 169 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 176 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 182 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0)}
#line 189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 195 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 202 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 208 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 215 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 221 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 228 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	{




#line 234 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl", (unsigned)(241)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.inl", (unsigned)(248)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
	{
		mat<3, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
	{
		mat<3, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
	{
		return typename mat<3, 2, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
	{
		return typename mat<3, 2, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];

		mat<2, 2, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
	{
		return mat<3, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
	{
		return mat<3, 2, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 167 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.hpp"
#line 168 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x2.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, double, defaultp>		dmat3x2;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 2, double, lowp>		lowp_dmat3x2;

	
	
	
	
	typedef mat<3, 2, double, mediump>	mediump_dmat3x2;

	
	
	
	
	typedef mat<3, 2, double, highp>	highp_dmat3x2;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float3x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 2, float, defaultp>			mat3x2;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float3x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 2, float, lowp>		lowp_mat3x2;

	
	
	
	
	typedef mat<3, 2, float, mediump>	mediump_mat3x2;

	
	
	
	
	typedef mat<3, 2, float, highp>		highp_mat3x2;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x2.hpp"

#line 25 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.hpp"



#pragma once





namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 3, T, Q> type;
		typedef mat<3, 3, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 3; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<3, 3, T, P> const& m);

		 constexpr  mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0,
			T x1, T y1, T z1,
			T x2, T y2, T z2);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1,
			X2 x2, Y2 y2, Z2 z2,
			X3 x3, Y3 y3, Z3 z3);

		template<typename V1, typename V2, typename V3>
		 constexpr mat(
			vec<3, V1, Q> const& v1,
			vec<3, V2, Q> const& v2,
			vec<3, V3, Q> const& v3);

		

		template<typename U, qualifier P>
		 constexpr  mat(mat<3, 3, U, P> const& m);

		 constexpr  mat(mat<2, 2, T, Q> const& x);
		 constexpr  mat(mat<4, 4, T, Q> const& x);
		 constexpr  mat(mat<2, 3, T, Q> const& x);
		 constexpr  mat(mat<3, 2, T, Q> const& x);
		 constexpr  mat(mat<2, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator/=(U s);
		template<typename U>
		 constexpr mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);

		

		 constexpr mat<3, 3, T, Q> & operator++();
		 constexpr mat<3, 3, T, Q> & operator--();
		  constexpr mat<3, 3, T, Q> operator++(int);
		  constexpr mat<3, 3, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"


namespace glm
{
	














#line 21 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 28 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 34 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(T s)

			: value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s)}
#line 41 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 47 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat
	(
		T x0, T y0, T z0,
		T x1, T y1, T z1,
		T x2, T y2, T z2
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2)}
#line 59 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 65 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 72 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 78 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 inline constexpr mat<3, 3, T, Q>::mat
	(
		X1 x1, Y1 y1, Z1 z1,
		X2 x2, Y2 y2, Z2 z2,
		X3 x3, Y3 y3, Z3 z3
	)

			: value{col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 96 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 102 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3>
	 inline constexpr mat<3, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3)

			: value{col_type(v1), col_type(v2), col_type(v3)}
#line 110 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 116 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 126 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 132 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1)}
#line 139 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 145 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 152 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 158 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}
#line 165 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 171 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}
#line 178 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 184 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}
#line 191 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 197 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}
#line 204 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 210 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 217 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 223 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 230 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	{




#line 236 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl", (unsigned)(243)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.inl", (unsigned)(250)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
	{
		mat<3, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
	{
		mat<3, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
	{
		return typename mat<3, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
	{
		return typename mat<3, 3, T, Q>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];

		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m,	T scalar)
	{
		return mat<3, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
	{
		return mat<3, 3, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
	{
		return  inverse(m) * v;
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
	{
		return v * inverse(m);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		mat<3, 3, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 184 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.hpp"
#line 185 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x3.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, double, defaultp>		dmat3x3;

	
	
	
	typedef mat<3, 3, double, defaultp>		dmat3;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 3, double, lowp>		lowp_dmat3;

	
	
	
	
	typedef mat<3, 3, double, mediump>	mediump_dmat3;

	
	
	
	
	typedef mat<3, 3, double, highp>	highp_dmat3;

	
	
	
	
	typedef mat<3, 3, double, lowp>		lowp_dmat3x3;

	
	
	
	
	typedef mat<3, 3, double, mediump>	mediump_dmat3x3;

	
	
	
	
	typedef mat<3, 3, double, highp>	highp_dmat3x3;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float3x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 3, float, defaultp>			mat3x3;

	
	
	
	typedef mat<3, 3, float, defaultp>			mat3;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float3x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 3, float, lowp>		lowp_mat3;

	
	
	
	
	typedef mat<3, 3, float, mediump>	mediump_mat3;

	
	
	
	
	typedef mat<3, 3, float, highp>		highp_mat3;

	
	
	
	
	typedef mat<3, 3, float, lowp>		lowp_mat3x3;

	
	
	
	
	typedef mat<3, 3, float, mediump>	mediump_mat3x3;

	
	
	
	
	typedef mat<3, 3, float, highp>		highp_mat3x3;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x3.hpp"
#line 26 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<3, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<3, T, Q> row_type;
		typedef mat<3, 4, T, Q> type;
		typedef mat<4, 3, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[3];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 3; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<3, 4, T, P> const& m);

		 constexpr  mat(T scalar);
		 constexpr mat(
			T x0, T y0, T z0, T w0,
			T x1, T y1, T z1, T w1,
			T x2, T y2, T z2, T w2);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3>
		 constexpr mat(
			X1 x1, Y1 y1, Z1 z1, W1 w1,
			X2 x2, Y2 y2, Z2 z2, W2 w2,
			X3 x3, Y3 y3, Z3 z3, W3 w3);

		template<typename V1, typename V2, typename V3>
		 constexpr mat(
			vec<4, V1, Q> const& v1,
			vec<4, V2, Q> const& v2,
			vec<4, V3, Q> const& v3);

		

		template<typename U, qualifier P>
		 constexpr  mat(mat<3, 4, U, P> const& m);

		 constexpr  mat(mat<2, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 3, T, Q> const& x);
		 constexpr  mat(mat<4, 4, T, Q> const& x);
		 constexpr  mat(mat<2, 3, T, Q> const& x);
		 constexpr  mat(mat<3, 2, T, Q> const& x);
		 constexpr  mat(mat<2, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 2, T, Q> const& x);
		 constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<3, 4, T, Q> & operator/=(U s);

		

		 constexpr mat<3, 4, T, Q> & operator++();
		 constexpr mat<3, 4, T, Q> & operator--();
		  constexpr mat<3, 4, T, Q> operator++(int);
		  constexpr mat<3, 4, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1,	mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1,	mat<3, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
namespace glm
{
	














#line 19 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 26 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 32 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0)}
#line 39 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 45 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat
	(
		T x0, T y0, T z0, T w0,
		T x1, T y1, T z1, T w1,
		T x2, T y2, T z2, T w2
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 60 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 66 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 73 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 79 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0, typename Z0, typename W0,
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 inline constexpr mat<3, 4, T, Q>::mat
	(
		X0 x0, Y0 y0, Z0 z0, W0 w0,
		X1 x1, Y1 y1, Z1 z1, W1 w1,
		X2 x2, Y2 y2, Z2 z2, W2 w2
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2)}
#line 100 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 106 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3>
	 inline constexpr mat<3, 4, T, Q>::mat(vec<4, V1, Q> const& v0, vec<4, V2, Q> const& v1, vec<4, V3, Q> const& v2)

			: value{col_type(v0), col_type(v1), col_type(v2)}
#line 114 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 120 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 130 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 136 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0)}
#line 143 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 149 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}
#line 156 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 162 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2])}
#line 169 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 175 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0)}
#line 182 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 188 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}
#line 195 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 201 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0)}
#line 208 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 214 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}
#line 221 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 227 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}
#line 234 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	{




#line 240 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl", (unsigned)(247)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.inl", (unsigned)(254)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
	{
		mat<3, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
	{
		mat<3, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			-m[0],
			-m[1],
			-m[2]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m,	T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 4, T, Q>::col_type operator*
	(
		mat<3, 4, T, Q> const& m,
		typename mat<3, 4, T, Q>::row_type const& v
	)
	{
		return typename mat<3, 4, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<3, 4, T, Q>::row_type operator*
	(
		typename mat<3, 4, T, Q>::col_type const& v,
		mat<3, 4, T, Q> const& m
	)
	{
		return typename mat<3, 4, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA02 = m1[0][2];
		const T SrcA03 = m1[0][3];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA12 = m1[1][2];
		const T SrcA13 = m1[1][3];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcA22 = m1[2][2];
		const T SrcA23 = m1[2][3];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		const T SrcB20 = m2[2][0];
		const T SrcB21 = m2[2][1];
		const T SrcB22 = m2[2][2];
		const T SrcB30 = m2[3][0];
		const T SrcB31 = m2[3][1];
		const T SrcB32 = m2[3][2];

		mat<4, 4, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m,	T scalar)
	{
		return mat<3, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
	{
		return mat<3, 4, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 166 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.hpp"
#line 167 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat3x4.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, double, defaultp>		dmat3x4;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double3x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 4, double, lowp>		lowp_dmat3x4;

	
	
	
	
	typedef mat<3, 4, double, mediump>	mediump_dmat3x4;

	
	
	
	
	typedef mat<3, 4, double, highp>	highp_dmat3x4;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float3x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<3, 4, float, defaultp>			mat3x4;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float3x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<3, 4, float, lowp>		lowp_mat3x4;

	
	
	
	
	typedef mat<3, 4, float, mediump>	mediump_mat3x4;

	
	
	
	
	typedef mat<3, 4, float, highp>		highp_mat3x4;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat3x4.hpp"
#line 27 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x2.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 2, T, Q>
	{
		typedef vec<2, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 2, T, Q> type;
		typedef mat<2, 4, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 4; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<4, 2, T, P> const& m);

		 constexpr mat(T scalar);
		 constexpr mat(
			T x0, T y0,
			T x1, T y1,
			T x2, T y2,
			T x3, T y3);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X0, typename Y0,
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		 constexpr mat(
			X0 x0, Y0 y0,
			X1 x1, Y1 y1,
			X2 x2, Y2 y2,
			X3 x3, Y3 y3);

		template<typename V1, typename V2, typename V3, typename V4>
		 constexpr mat(
			vec<2, V1, Q> const& v1,
			vec<2, V2, Q> const& v2,
			vec<2, V3, Q> const& v3,
			vec<2, V4, Q> const& v4);

		

		template<typename U, qualifier P>
		 constexpr mat(mat<4, 2, U, P> const& m);

		 constexpr mat(mat<2, 2, T, Q> const& x);
		 constexpr mat(mat<3, 3, T, Q> const& x);
		 constexpr mat(mat<4, 4, T, Q> const& x);
		 constexpr mat(mat<2, 3, T, Q> const& x);
		 constexpr mat(mat<3, 2, T, Q> const& x);
		 constexpr mat(mat<2, 4, T, Q> const& x);
		 constexpr mat(mat<4, 3, T, Q> const& x);
		 constexpr mat(mat<3, 4, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<4, 2, T, Q> & operator/=(U s);

		

		 constexpr mat<4, 2, T, Q> & operator++ ();
		 constexpr mat<4, 2, T, Q> & operator-- ();
		  constexpr mat<4, 2, T, Q> operator++(int);
		  constexpr mat<4, 2, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1,	mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
namespace glm
{
	















#line 20 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 27 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 34 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(T s)

			: value{col_type(s, 0), col_type(0, s), col_type(0, 0), col_type(0, 0)}
#line 41 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 48 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat
	(
		T x0, T y0,
		T x1, T y1,
		T x2, T y2,
		T x3, T y3
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}
#line 61 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 68 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 75 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 82 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0,
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3>
	 inline constexpr mat<4, 2, T, Q>::mat
	(
		X0 x0, Y0 y0,
		X1 x1, Y1 y1,
		X2 x2, Y2 y2,
		X3 x3, Y3 y3
	)

			: value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}
#line 102 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 109 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	template<typename V0, typename V1, typename V2, typename V3>
	 inline constexpr mat<4, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2, vec<2, V3, Q> const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 117 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 124 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 134 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 141 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 148 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 155 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 162 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 169 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 176 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 183 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 190 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 197 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 204 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 211 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}
#line 218 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 225 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 232 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 239 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 246 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	{





#line 253 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl", (unsigned)(260)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.inl", (unsigned)(267)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
	{
		mat<4, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
	{
		mat<4, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
	{
		return typename mat<4, 2, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
	{
		return typename mat<4, 2, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];

		mat<2, 2, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
	{
		return mat<4, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
	{
		return mat<4, 2, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 171 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.hpp"
#line 172 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x2.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, double, defaultp>		dmat4x2;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 2, double, lowp>		lowp_dmat4x2;

	
	
	
	
	typedef mat<4, 2, double, mediump>	mediump_dmat4x2;

	
	
	
	
	typedef mat<4, 2, double, highp>	highp_dmat4x2;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float4x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 2, float, defaultp>			mat4x2;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float4x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 2, float, lowp>		lowp_mat4x2;

	
	
	
	
	typedef mat<4, 2, float, mediump>	mediump_mat4x2;

	
	
	
	
	typedef mat<4, 2, float, highp>		highp_mat4x2;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x2.hpp"

#line 28 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x3.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.hpp"



#pragma once






namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 3, T, Q>
	{
		typedef vec<3, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 3, T, Q> type;
		typedef mat<3, 4, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length() { return 4; }

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<4, 3, T, P> const& m);

		 constexpr  mat(T s);
		 constexpr mat(
			T const& x0, T const& y0, T const& z0,
			T const& x1, T const& y1, T const& z1,
			T const& x2, T const& y2, T const& z2,
			T const& x3, T const& y3, T const& z3);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3,
			typename X4, typename Y4, typename Z4>
		 constexpr mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1,
			X2 const& x2, Y2 const& y2, Z2 const& z2,
			X3 const& x3, Y3 const& y3, Z3 const& z3,
			X4 const& x4, Y4 const& y4, Z4 const& z4);

		template<typename V1, typename V2, typename V3, typename V4>
		 constexpr mat(
			vec<3, V1, Q> const& v1,
			vec<3, V2, Q> const& v2,
			vec<3, V3, Q> const& v3,
			vec<3, V4, Q> const& v4);

		

		template<typename U, qualifier P>
		 constexpr mat(mat<4, 3, U, P> const& m);

		 constexpr mat(mat<2, 2, T, Q> const& x);
		 constexpr mat(mat<3, 3, T, Q> const& x);
		 constexpr mat(mat<4, 4, T, Q> const& x);
		 constexpr mat(mat<2, 3, T, Q> const& x);
		 constexpr mat(mat<3, 2, T, Q> const& x);
		 constexpr mat(mat<2, 4, T, Q> const& x);
		 constexpr mat(mat<4, 2, T, Q> const& x);
		 constexpr mat(mat<3, 4, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<4, 3, T, Q> & operator/=(U s);

		

		 constexpr mat<4, 3, T, Q>& operator++();
		 constexpr mat<4, 3, T, Q>& operator--();
		  constexpr mat<4, 3, T, Q> operator++(int);
		  constexpr mat<4, 3, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1,	mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
namespace glm
{
	















#line 20 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 27 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 34 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(T s)

			: value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s), col_type(0, 0, 0)}
#line 41 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 48 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat
	(
		T const& x0, T const& y0, T const& z0,
		T const& x1, T const& y1, T const& z1,
		T const& x2, T const& y2, T const& z2,
		T const& x3, T const& y3, T const& z3
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 61 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 68 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 75 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 82 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X0, typename Y0, typename Z0,
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 inline constexpr mat<4, 3, T, Q>::mat
	(
		X0 const& x0, Y0 const& y0, Z0 const& z0,
		X1 const& x1, Y1 const& y1, Z1 const& z1,
		X2 const& x2, Y2 const& y2, Z2 const& z2,
		X3 const& x3, Y3 const& y3, Z3 const& z3
	)

			: value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}
#line 102 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 109 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3, typename V4>
	 inline constexpr mat<4, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3, vec<3, V4, Q> const& v4)

			: value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}
#line 117 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 124 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 134 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 141 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1), col_type(0)}
#line 148 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 155 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 162 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 169 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 176 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 183 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}
#line 190 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 197 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(0)}
#line 204 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 211 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}
#line 218 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 225 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(m[3], 0)}
#line 232 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 239 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}
#line 246 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	{





#line 253 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl", (unsigned)(260)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.inl", (unsigned)(267)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
	{
		mat<4, 3, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
	{
		mat<4, 3, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 3, T, Q>::col_type operator*
	(
		mat<4, 3, T, Q> const& m,
		typename mat<4, 3, T, Q>::row_type const& v)
	{
		return typename mat<4, 3, T, Q>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 3, T, Q>::row_type operator*
	(
		typename mat<4, 3, T, Q>::col_type const& v,
		mat<4, 3, T, Q> const& m)
	{
		return typename mat<4, 3, T, Q>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcA32 = m1[3][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		T const SrcB23 = m2[2][3];

		mat<3, 3, T, Q> Result;
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 3, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar)
	{
		return mat<4, 3, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m)
	{
		return mat<4, 3, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 171 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.hpp"
#line 172 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x3.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x3.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, double, defaultp>		dmat4x3;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 3, double, lowp>		lowp_dmat4x3;

	
	
	
	
	typedef mat<4, 3, double, mediump>	mediump_dmat4x3;

	
	
	
	
	typedef mat<4, 3, double, highp>	highp_dmat4x3;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float4x3.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 3, float, defaultp>			mat4x3;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x3.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float4x3_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 3, float, lowp>		lowp_mat4x3;

	
	
	
	
	typedef mat<4, 3, float, mediump>	mediump_mat4x3;

	
	
	
	
	typedef mat<4, 3, float, highp>		highp_mat4x3;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x3.hpp"
#line 29 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x4.hpp"



#pragma once
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.hpp"



#pragma once





namespace glm
{
	template<typename T, qualifier Q>
	struct mat<4, 4, T, Q>
	{
		typedef vec<4, T, Q> col_type;
		typedef vec<4, T, Q> row_type;
		typedef mat<4, 4, T, Q> type;
		typedef mat<4, 4, T, Q> transpose_type;
		typedef T value_type;

	private:
		col_type value[4];

	public:
		

		typedef length_t length_type;
		  static constexpr length_type length(){return 4;}

		  constexpr col_type & operator[](length_type i) noexcept;
		  constexpr col_type const& operator[](length_type i) const noexcept;

		

		 constexpr mat() = default;
		template<qualifier P>
		 constexpr mat(mat<4, 4, T, P> const& m);

		 constexpr  mat(T s);
		 constexpr mat(
			T const& x0, T const& y0, T const& z0, T const& w0,
			T const& x1, T const& y1, T const& z1, T const& w1,
			T const& x2, T const& y2, T const& z2, T const& w2,
			T const& x3, T const& y3, T const& z3, T const& w3);
		 constexpr mat(
			col_type const& v0,
			col_type const& v1,
			col_type const& v2,
			col_type const& v3);

		

		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3,
			typename X4, typename Y4, typename Z4, typename W4>
		 constexpr mat(
			X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
			X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
			X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
			X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

		template<typename V1, typename V2, typename V3, typename V4>
		 constexpr mat(
			vec<4, V1, Q> const& v1,
			vec<4, V2, Q> const& v2,
			vec<4, V3, Q> const& v3,
			vec<4, V4, Q> const& v4);

		

		template<typename U, qualifier P>
		 constexpr  mat(mat<4, 4, U, P> const& m);

		 constexpr  mat(mat<2, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 3, T, Q> const& x);
		 constexpr  mat(mat<2, 3, T, Q> const& x);
		 constexpr  mat(mat<3, 2, T, Q> const& x);
		 constexpr  mat(mat<2, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 2, T, Q> const& x);
		 constexpr  mat(mat<3, 4, T, Q> const& x);
		 constexpr  mat(mat<4, 3, T, Q> const& x);

		

		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator+=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator-=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator*=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator/=(U s);
		template<typename U>
		 constexpr mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);

		

		 constexpr mat<4, 4, T, Q> & operator++();
		 constexpr mat<4, 4, T, Q> & operator--();
		  constexpr mat<4, 4, T, Q> operator++(int);
		  constexpr mat<4, 4, T, Q> operator--(int);
	};

	

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);

	

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1,	mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

	template<typename T, qualifier Q>
	  constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

	template<typename T, qualifier Q>
	  constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1,	mat<4, 4, T, Q> const& m2);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"


namespace glm
{
	















#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 29 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 36 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(T s)

			: value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}
#line 43 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 50 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat
	(
		T const& x0, T const& y0, T const& z0, T const& w0,
		T const& x1, T const& y1, T const& z1, T const& w1,
		T const& x2, T const& y2, T const& z2, T const& w2,
		T const& x3, T const& y3, T const& z3, T const& w3
	)

			: value{
				col_type(x0, y0, z0, w0),
				col_type(x1, y1, z1, w1),
				col_type(x2, y2, z2, w2),
				col_type(x3, y3, z3, w3)}
#line 67 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 74 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

			: value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}
#line 81 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 88 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}
#line 96 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 103 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T, qualifier Q>
	template<
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3,
		typename X4, typename Y4, typename Z4, typename W4>
	 inline constexpr mat<4, 4, T, Q>::mat
	(
		X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
		X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
		X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
		X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
	)

			: value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}
#line 123 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{
		static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

		static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
		static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
		static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
		static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

		static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
		static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
		static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
		static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

		static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
		static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
		static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
		static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");






#line 150 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2, typename V3, typename V4>
	 inline constexpr mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)

			: value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}
#line 158 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{
		static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");






#line 170 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 179 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 186 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}
#line 193 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 200 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 207 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 214 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}
#line 221 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 228 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 235 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 242 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}
#line 249 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 256 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}
#line 263 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 270 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}
#line 277 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	{





#line 284 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl", (unsigned)(291)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl", (unsigned)(298)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
	{
		mat<4, 4, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
	{
		mat<4, 4, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			m[0] + scalar,
			m[1] + scalar,
			m[2] + scalar,
			m[3] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 4, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] - scalar,
			m[1] - scalar,
			m[2] - scalar,
			m[3] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			scalar - m[0],
			scalar - m[1],
			scalar - m[2],
			scalar - m[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return mat<4, 4, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			m[0] * scalar,
			m[1] * scalar,
			m[2] * scalar,
			m[3] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 4, T, Q>::col_type operator*
	(
		mat<4, 4, T, Q> const& m,
		typename mat<4, 4, T, Q>::row_type const& v
	)
	{



















		typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
		typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
		typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
		typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
		typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
		typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
		typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
		typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
		typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
		typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
		typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
		return Add2;








	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 4, T, Q>::row_type operator*
	(
		typename mat<4, 4, T, Q>::col_type const& v,
		mat<4, 4, T, Q> const& m
	)
	{
		return typename mat<4, 4, T, Q>::row_type(
			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
	{
		return mat<2, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
	{
		return mat<3, 4, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
		typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
		typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
		typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];

		typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
		typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
		typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
		typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];

		mat<4, 4, T, Q> Result;
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar)
	{
		return mat<4, 4, T, Q>(
			m[0] / scalar,
			m[1] / scalar,
			m[2] / scalar,
			m[3] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator/(T scalar,	mat<4, 4, T, Q> const& m)
	{
		return mat<4, 4, T, Q>(
			scalar / m[0],
			scalar / m[1],
			scalar / m[2],
			scalar / m[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
	{
		return inverse(m) * v;
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
	{
		return v * inverse(m);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		mat<4, 4, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
}



#line 707 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.inl"
#line 189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.hpp"
#line 190 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat4x4.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x4.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, double, defaultp>		dmat4x4;

	
	
	
	typedef mat<4, 4, double, defaultp>		dmat4;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double4x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 4, double, lowp>		lowp_dmat4;

	
	
	
	
	typedef mat<4, 4, double, mediump>	mediump_dmat4;

	
	
	
	
	typedef mat<4, 4, double, highp>	highp_dmat4;

	
	
	
	
	typedef mat<4, 4, double, lowp>		lowp_dmat4x4;

	
	
	
	
	typedef mat<4, 4, double, mediump>	mediump_dmat4x4;

	
	
	
	
	typedef mat<4, 4, double, highp>	highp_dmat4x4;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float4x4.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<4, 4, float, defaultp>			mat4x4;

	
	
	
	typedef mat<4, 4, float, defaultp>			mat4;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x4.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float4x4_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<4, 4, float, lowp>		lowp_mat4;

	
	
	
	
	typedef mat<4, 4, float, mediump>	mediump_mat4;

	
	
	
	
	typedef mat<4, 4, float, highp>		highp_mat4;

	
	
	
	
	typedef mat<4, 4, float, lowp>		lowp_mat4x4;

	
	
	
	
	typedef mat<4, 4, float, mediump>	mediump_mat4x4;

	
	
	
	
	typedef mat<4, 4, float, highp>		highp_mat4x4;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat4x4.hpp"

#line 30 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"

namespace glm {
namespace detail
{
	template<length_t C, length_t R, typename T, qualifier Q>
	struct outerProduct_trait{};

	template<typename T, qualifier Q>
	struct outerProduct_trait<2, 2, T, Q>
	{
		typedef mat<2, 2, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<2, 3, T, Q>
	{
		typedef mat<3, 2, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<2, 4, T, Q>
	{
		typedef mat<4, 2, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<3, 2, T, Q>
	{
		typedef mat<2, 3, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<3, 3, T, Q>
	{
		typedef mat<3, 3, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<3, 4, T, Q>
	{
		typedef mat<4, 3, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<4, 2, T, Q>
	{
		typedef mat<2, 4, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<4, 3, T, Q>
	{
		typedef mat<3, 4, T, Q> type;
	};

	template<typename T, qualifier Q>
	struct outerProduct_trait<4, 4, T, Q>
	{
		typedef mat<4, 4, T, Q> type;
	};
}

	 
	 

	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	template<length_t C, length_t R, typename T, qualifier Q>
	  mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	  typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	  typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	  T determinant(mat<C, R, T, Q> const& m);

	
	
	
	
	
	
	
	
	
	template<length_t C, length_t R, typename T, qualifier Q>
	  mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_matrix.inl"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\geometric.hpp"












#pragma once



namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  T length(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	template<typename T, qualifier Q>
	  constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> normalize(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> faceforward(
		vec<L, T, Q> const& N,
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& Nref);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> reflect(
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& N);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> refract(
		vec<L, T, Q> const& I,
		vec<L, T, Q> const& N,
		T eta);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_geometric.inl"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\exponential.hpp"














#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"



#pragma once




#line 10 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"

#line 12 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"


namespace glm
{
	template<typename T, qualifier Q>
	struct vec<1, T, Q>
	{
		

		typedef T value_type;
		typedef vec<1, T, Q> type;
		typedef vec<1, bool, Q> bool_type;

		





#line 32 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"



#line 36 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"
#pragma warning(push)
#pragma warning(disable: 4201)  
#line 39 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"
#line 40 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"



#line 44 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"





















#line 66 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"
			union {T x, r, s;};





#line 73 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"




#line 78 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"

#line 80 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"
#pragma warning(pop)
#line 82 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"
#line 83 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"

		

		
		typedef length_t length_type;
		  static constexpr length_type length(){return 1;}

		  constexpr T & operator[](length_type i);
		  constexpr T const& operator[](length_type i) const;

		

		 constexpr vec() = default;
		 constexpr vec(vec const& v) = default;
		template<qualifier P>
		 constexpr vec(vec<1, T, P> const& v);

		

		 constexpr explicit vec(T scalar);

		

		
		template<typename U, qualifier P>
		 constexpr  vec(vec<2, U, P> const& v);
		
		template<typename U, qualifier P>
		 constexpr  vec(vec<3, U, P> const& v);
		
		template<typename U, qualifier P>
		 constexpr  vec(vec<4, U, P> const& v);

		
		template<typename U, qualifier P>
		 constexpr  vec(vec<1, U, P> const& v);

		









		

		 constexpr vec<1, T, Q> & operator=(vec const& v) = default;

		template<typename U>
		 constexpr vec<1, T, Q> & operator=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator+=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator+=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator-=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator-=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator*=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator*=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator/=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator/=(vec<1, U, Q> const& v);

		

		 constexpr vec<1, T, Q> & operator++();
		 constexpr vec<1, T, Q> & operator--();
		  constexpr vec<1, T, Q> operator++(int);
		  constexpr vec<1, T, Q> operator--(int);

		

		template<typename U>
		 constexpr vec<1, T, Q> & operator%=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator%=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator&=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator&=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator|=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator|=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator^=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator^=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator<<=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator<<=(vec<1, U, Q> const& v);
		template<typename U>
		 constexpr vec<1, T, Q> & operator>>=(U scalar);
		template<typename U>
		 constexpr vec<1, T, Q> & operator>>=(vec<1, U, Q> const& v);
	};

	

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v);

	

	template<typename T, qualifier Q>
	  constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<typename T, qualifier Q>
	  constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);

	template<qualifier Q>
	  constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
}


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.inl"




namespace glm
{
	








#line 17 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.inl"






#line 24 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<1, T, P> const& v)
		: x(v.x)
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q>::vec(T scalar)
		: x(scalar)
	{}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<1, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<2, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<3, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr vec<1, T, Q>::vec(vec<4, U, P> const& v)
		: x(static_cast<T>(v.x))
	{}

	

	template<typename T, qualifier Q>
	 inline constexpr T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type)
	{
		return x;
	}

	template<typename T, qualifier Q>
	 inline constexpr T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type) const
	{
		return x;
	}

	








#line 88 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.inl"

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
	{
		this->x = static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
	{
		this->x += static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
	{
		this->x -= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
	{
		this->x *= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
	{
		this->x *= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
	{
		this->x /= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
	{
		this->x /= static_cast<T>(v.x);
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator++()
	{
		++this->x;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator--()
	{
		--this->x;
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator++(int)
	{
		vec<1, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator--(int)
	{
		vec<1, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
	{
		this->x %= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
	{
		this->x &= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
	{
		this->x |= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
	{
		this->x ^= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
	{
		this->x <<= static_cast<T>(v.x);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
	{
		this->x >>= static_cast<T>(v.x);
		return *this;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v)
	{
		return v;
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			-v.x);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar + v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x + v2.x);
	}

	
	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar - v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x - v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar * v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x * v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar / v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x / v2.x);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x % scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar % v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x % v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x & scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar & v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x & v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x | scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar | v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x | v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			v.x ^ scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			scalar ^ v.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			v1.x ^ v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			static_cast<T>(v.x << scalar));
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			static_cast<T>(scalar << v.x));
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			static_cast<T>(v1.x << v2.x));
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
	{
		return vec<1, T, Q>(
			static_cast<T>(v.x >> scalar));
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			static_cast<T>(scalar >> v.x));
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return vec<1, T, Q>(
			static_cast<T>(v1.x >> v2.x));
	}

	template<typename T, qualifier Q>
	 inline constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v)
	{
		return vec<1, T, Q>(
			~v.x);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
	{
		return !(v1 == v2);
	}

	template<qualifier Q>
	 inline constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
	{
		return vec<1, bool, Q>(v1.x && v2.x);
	}

	template<qualifier Q>
	 inline constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
	{
		return vec<1, bool, Q>(v1.x || v2.x);
	}
}
#line 308 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"
#line 309 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_vec1.hpp"
#line 18 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\exponential.hpp"





namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> exp(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> log(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> exp2(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> log2(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> sqrt(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_exponential.inl"



#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vector_relational.hpp"



















#pragma once


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 24 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vector_relational.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  constexpr bool any(vec<L, bool, Q> const& v);

	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  constexpr bool all(vec<L, bool, Q> const& v);

	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_vector_relational.inl"
namespace glm
{
	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template<length_t L, qualifier Q>
	 inline constexpr bool any(vec<L, bool, Q> const& v)
	{
		bool Result = false;
		for(length_t i = 0; i < L; ++i)
			Result = Result || v[i];
		return Result;
	}

	template<length_t L, qualifier Q>
	 inline constexpr bool all(vec<L, bool, Q> const& v)
	{
		bool Result = true;
		for(length_t i = 0; i < L; ++i)
			Result = Result && v[i];
		return Result;
	}

	template<length_t L, qualifier Q>
	 inline constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
	{
		vec<L, bool, Q> Result(true);
		for(length_t i = 0; i < L; ++i)
			Result[i] = !v[i];
		return Result;
	}
}



#line 88 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_vector_relational.inl"
#line 122 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\vector_relational.hpp"
#line 5 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_exponential.inl"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\_vectorize.hpp"
#pragma once

namespace glm{
namespace detail
{
	template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>
	struct functor1{};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 1, R, T, Q>
	{
		 inline constexpr static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
		{
			return vec<1, R, Q>(Func(v.x));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 2, R, T, Q>
	{
		 inline constexpr static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
		{
			return vec<2, R, Q>(Func(v.x), Func(v.y));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 3, R, T, Q>
	{
		 inline constexpr static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
		{
			return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
	struct functor1<vec, 4, R, T, Q>
	{
		 inline constexpr static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
		{
			return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
	struct functor2{};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 1, T, Q>
	{
		 inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
		{
			return vec<1, T, Q>(Func(a.x, b.x));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 2, T, Q>
	{
		 inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
		{
			return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 3, T, Q>
	{
		 inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
		{
			return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2<vec, 4, T, Q>
	{
		 inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
	struct functor2_vec_sca{};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 1, T, Q>
	{
		 inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
		{
			return vec<1, T, Q>(Func(a.x, b));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 2, T, Q>
	{
		 inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
		{
			return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 3, T, Q>
	{
		 inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
		{
			return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
		}
	};

	template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
	struct functor2_vec_sca<vec, 4, T, Q>
	{
		 inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
		{
			return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
		}
	};

	template<length_t L, typename T, qualifier Q>
	struct functor2_vec_int {};

	template<typename T, qualifier Q>
	struct functor2_vec_int<1, T, Q>
	{
		 inline static vec<1, int, Q> call(int (*Func) (T x, int y), vec<1, T, Q> const& a, vec<1, int, Q> const& b)
		{
			return vec<1, int, Q>(Func(a.x, b.x));
		}
	};

	template<typename T, qualifier Q>
	struct functor2_vec_int<2, T, Q>
	{
		 inline static vec<2, int, Q> call(int (*Func) (T x, int y), vec<2, T, Q> const& a, vec<2, int, Q> const& b)
		{
			return vec<2, int, Q>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template<typename T, qualifier Q>
	struct functor2_vec_int<3, T, Q>
	{
		 inline static vec<3, int, Q> call(int (*Func) (T x, int y), vec<3, T, Q> const& a, vec<3, int, Q> const& b)
		{
			return vec<3, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template<typename T, qualifier Q>
	struct functor2_vec_int<4, T, Q>
	{
		 inline static vec<4, int, Q> call(int (*Func) (T x, int y), vec<4, T, Q> const& a, vec<4, int, Q> const& b)
		{
			return vec<4, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};
}
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_exponential.inl"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cassert"








#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )

__pragma(pack(push, 8)) extern "C" {





#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"









    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 10 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207\\include\\cassert"
#pragma external_header(pop)
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_exponential.inl"

namespace glm{
namespace detail
{

		using std::log2;






#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_exponential.inl"

	template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
	struct compute_log2
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");

			return detail::functor1<vec, L, T, T, Q>::call(log2, v);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_sqrt
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_inversesqrt
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return static_cast<T>(1) / sqrt(x);
		}
	};

	template<length_t L, bool Aligned>
	struct compute_inversesqrt<L, float, lowp, Aligned>
	{
		 inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
		{
			vec<L, float, lowp> tmp(x);
			vec<L, float, lowp> xhalf(tmp * 0.5f);
			vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
			vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
			vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
			tmp = *ptmp;
			tmp = tmp * (1.5f - xhalf * tmp * tmp);
			return tmp;
		}
	};
}

	
	using std::pow;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
	{
		return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
	}

	
	using std::exp;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
	{
		return detail::functor1<vec, L, T, T, Q>::call(exp, x);
	}

	
	using std::log;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> log(vec<L, T, Q> const& x)
	{
		return detail::functor1<vec, L, T, T, Q>::call(log, x);
	}


    using std::exp2;









#line 105 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_exponential.inl"

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
	{
		return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
	}

	
	template<typename genType>
	 inline genType log2(genType x)
	{
		return log2(vec<1, genType>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
	{
		return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
	}

	
	using std::sqrt;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sqrt' only accept floating-point inputs");
		return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	 inline genType inversesqrt(genType x)
	{
		return static_cast<genType>(1) / sqrt(x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inversesqrt' only accept floating-point inputs");
		return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}
}



#line 152 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_exponential.inl"

#line 111 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\exponential.hpp"
#line 2 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_geometric.inl"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\common.hpp"














#pragma once


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\_fixes.hpp"



























#line 19 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template<typename genType>
	  constexpr genType abs(genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> floor(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> trunc(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> round(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> roundEven(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> ceil(vec<L, T, Q> const& x);

	
	
	
	
	
	
	template<typename genType>
	  genType fract(genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> fract(vec<L, T, Q> const& x);

	template<typename genType>
	  genType mod(genType x, genType y);

	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	
	
	template<typename genType>
	  genType modf(genType x, genType& i);

	
	
	
	
	
	
	template<typename genType>
	  constexpr genType min(genType x, genType y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, T y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	template<typename genType>
	  constexpr genType max(genType x, genType y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, T y);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);

	
	
	
	
	
	
	
	template<typename genType>
	  constexpr genType clamp(genType x, genType minVal, genType maxVal);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genTypeT, typename genTypeU>
	  constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

	template<length_t L, typename T, typename U, qualifier Q>
	  constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);

	template<length_t L, typename T, typename U, qualifier Q>
	  constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);

	
	
	
	
	template<typename genType>
	  genType step(genType edge, genType x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	  genType smoothstep(genType edge0, genType edge1, genType x);

	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);

	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, bool, Q> isnan(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, bool, Q> isinf(vec<L, T, Q> const& x);

	
	
	
	
	
	
	  int floatBitsToInt(float v);

	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);

	
	
	
	
	
	
	  uint floatBitsToUint(float v);

	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);

	
	
	
	
	
	
	
	
	  float intBitsToFloat(int v);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);

	
	
	
	
	
	
	
	
	  float uintBitsToFloat(uint v);

	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);

	
	
	
	
	
	
	template<typename genType>
	  genType fma(genType const& a, genType const& b, genType const& c);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	  genType frexp(genType x, int& exp);
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp);

	
	
	
	
	
	
	
	
	
	
	
	template<typename genType>
	  genType ldexp(genType const& x, int const& exp);
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"




#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\compute_common.hpp"
#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 4 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\compute_common.hpp"


namespace glm{
namespace detail
{
	template<typename genFIType, bool >
	struct compute_abs
	{};

	template<typename genFIType>
	struct compute_abs<genFIType, true>
	{
		 inline constexpr static genFIType call(genFIType x)
		{
			static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 21 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\compute_common.hpp"

			return x >= genFIType(0) ? x : -x;
			
		}
	};










#line 37 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\compute_common.hpp"

	template<typename genFIType>
	struct compute_abs<genFIType, false>
	{
		 inline constexpr static genFIType call(genFIType x)
		{
			static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'abs' only accept floating-point and integer scalar or vector inputs");
#line 46 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\compute_common.hpp"
			return x;
		}
	};
}
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"







namespace glm
{
	
	template<typename genType>
	 inline constexpr genType min(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");
		return (y < x) ? y : x;
	}

	
	template<typename genType>
	 inline constexpr genType max(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

		return (x < y) ? y : x;
	}

	
	template<>
	 inline constexpr int abs(int x)
	{
		int const y = x >> (sizeof(int) * 8 - 1);
		return (x ^ y) - y;
	}

	

		using ::std::round;








#line 52 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

	

		using ::std::trunc;








#line 65 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

}

namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_abs_vector
	{
		 inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(abs, x);
		}
	};

	template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
	struct compute_mix_vector
	{
		 inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mix_vector<L, T, bool, Q, Aligned>
	{
		 inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
		{
			vec<L, T, Q> Result(0);
			for(length_t i = 0; i < x.length(); ++i)
				Result[i] = a[i] ? y[i] : x[i];
			return Result;
		}
	};

	template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
	struct compute_mix_scalar
	{
		 inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mix_scalar<L, T, bool, Q, Aligned>
	{
		 inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
		{
			return a ? y : x;
		}
	};

	template<typename T, typename U>
	struct compute_mix
	{
		 inline constexpr static T call(T const& x, T const& y, U const& a)
		{
			static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

			return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
		}
	};

	template<typename T>
	struct compute_mix<T, bool>
	{
		 inline constexpr static T call(T const& x, T const& y, bool const& a)
		{
			return a ? y : x;
		}
	};

	template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
	struct compute_sign
	{
		 inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
		}
	};


	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_sign<L, T, Q, false, Aligned>
	{
		 inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
			vec<L, T, Q> const y(vec<L, typename detail::make_unsigned<T>::type, Q>(-x) >> typename detail::make_unsigned<T>::type(Shift));

			return (x >> Shift) | y;
		}
	};
#line 165 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_floor
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(std::floor, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_ceil
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_fract
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return x - floor(x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_trunc
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(trunc, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_round
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
		{
			return detail::functor1<vec, L, T, T, Q>::call(round, x);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_mod
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
			return a - b * floor(a / b);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_min_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
		{
			return detail::functor2<vec, L, T, Q>::call(min, x, y);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_max_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
		{
			return detail::functor2<vec, L, T, Q>::call(max, x, y);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_clamp_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
		{
			return min(max(x, minVal), maxVal);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_step_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
		{
			return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_smoothstep_vector
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");
			vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
			return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
		}
	};
}

	template<typename genFIType>
	 inline constexpr genFIType abs(genFIType x)
	{
		return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x)
	{
		return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	
	template<typename genFIType>
	 inline constexpr genFIType sign(genFIType x)
	{
		static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs");
#line 289 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

		return detail::compute_sign<1, genFIType, defaultp,
                                    std::numeric_limits<genFIType>::is_iec559, detail::is_aligned<highp>::value>::call(vec<1, genFIType>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs");
#line 300 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

		return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
	}

	
	using ::std::floor;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'floor' only accept floating-point inputs.");
		return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'trunc' only accept floating-point inputs");
		return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> round(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'round' only accept floating-point inputs");
		return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}












	
	template<typename genType>
	 inline genType roundEven(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");

		int Integer = static_cast<int>(x);
		genType IntegerPart = static_cast<genType>(Integer);
		genType FractionalPart = fract(x);

		if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= static_cast<genType>(0)) 
		{
			return IntegerPart - static_cast<genType>(1);
		}
		else
		{
			return IntegerPart + static_cast<genType>(1);
		}
		
		
		
		
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");
		return detail::functor1<vec, L, T, T, Q>::call(roundEven, x);
	}

	
	using ::std::ceil;
	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ceil' only accept floating-point inputs");
		return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	 inline genType fract(genType x)
	{
		return fract(vec<1, genType>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fract' only accept floating-point inputs");
		return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	 inline genType mod(genType x, genType y)
	{




#line 409 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"
			return mod(vec<1, genType, defaultp>(x), y).x;
#line 411 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
	{
		return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
	}

	
	template<typename genType>
	 inline genType modf(genType x, genType & i)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'modf' only accept floating-point inputs");
		return std::modf(x, &i);
	}

	template<typename T, qualifier Q>
	 inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
	{
		return vec<1, T, Q>(
			modf(x.x, i.x));
	}

	template<typename T, qualifier Q>
	 inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
	{
		return vec<2, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}

	template<typename T, qualifier Q>
	 inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
	{
		return vec<3, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}

	template<typename T, qualifier Q>
	 inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
	{
		return vec<4, T, Q>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}

	
	
	
	
	
	
	

	
	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
		return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
	}

	
	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
		return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
	{
		return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
	}

	
	template<typename genType>
	 inline constexpr genType clamp(genType x, genType minVal, genType maxVal)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");
		return min(max(x, minVal), maxVal);
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
		return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
	}

	template<typename genTypeT, typename genTypeU>
	 inline constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
	{
		return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
	}

	template<length_t L, typename T, typename U, qualifier Q>
	 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
	{
		return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
	}

	template<length_t L, typename T, typename U, qualifier Q>
	 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
	{
		return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
	}

	
	template<typename genType>
	 inline genType step(genType edge, genType x)
	{
		return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
	{
		return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
	{
		return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
	}

	
	template<typename genType>
	 inline genType smoothstep(genType edge0, genType edge1, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");

		genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
	{
		return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
	}


		using std::isnan;
























#line 611 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs");

		vec<L, bool, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isnan(v[l]);
		return Result;
	}


		using std::isinf;



























#line 653 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs");

		vec<L, bool, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = glm::isinf(v[l]);
		return Result;
	}

	 inline int floatBitsToInt(float v)
	{
		union
		{
			float in;
			int out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	 inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
	{
		return detail::functor1<vec, L, int, float, Q>::call(floatBitsToInt, v);
	}

	 inline uint floatBitsToUint(float v)
	{
		union
		{
			float in;
			uint out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	 inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
	{
		return detail::functor1<vec, L, uint, float, Q>::call(floatBitsToUint, v);
	}

	 inline float intBitsToFloat(int v)
	{
		union
		{
			int in;
			float out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	 inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
	{
		return detail::functor1<vec, L, float, int, Q>::call(intBitsToFloat, v);
	}

	 inline float uintBitsToFloat(uint v)
	{
		union
		{
			uint in;
			float out;
		} u;

		u.in = v;

		return u.out;
	}

	template<length_t L, qualifier Q>
	 inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
	{
		return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
	}


		using std::fma;






#line 750 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"

	template<typename genType>
	 inline genType frexp(genType x, int& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

		return std::frexp(x, &exp);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

		vec<L, T, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::frexp(v[l], &exp[l]);
		return Result;
	}

	template<typename genType>
	 inline genType ldexp(genType const& x, int const& exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

		return std::ldexp(x, exp);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

		vec<L, T, Q> Result(0);
		for (length_t l = 0; l < v.length(); ++l)
			Result[l] = std::ldexp(v[l], exp[l]);
		return Result;
	}
}



#line 793 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_common.inl"
#line 539 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\common.hpp"

#line 3 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_geometric.inl"

namespace glm{
namespace detail
{
	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_length
	{
		 inline static T call(vec<L, T, Q> const& v)
		{
			return sqrt(dot(v, v));
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_distance
	{
		 inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
		{
			return length(p1 - p0);
		}
	};

	template<typename V, typename T, bool Aligned>
	struct compute_dot{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<1, T, Q>, T, Aligned>
	{
		 inline constexpr static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
		{
			return a.x * b.x;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<2, T, Q>, T, Aligned>
	{
		 inline constexpr static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
		{
			vec<2, T, Q> tmp(a * b);
			return tmp.x + tmp.y;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<3, T, Q>, T, Aligned>
	{
		 inline constexpr static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
		{
			vec<3, T, Q> tmp(a * b);
			return tmp.x + tmp.y + tmp.z;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_dot<vec<4, T, Q>, T, Aligned>
	{
		 inline constexpr static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
		{
			vec<4, T, Q> tmp(a * b);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_cross
	{
		 inline constexpr static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");

			return vec<3, T, Q>(
				x.y * y.z - y.y * x.z,
				x.z * y.x - y.z * x.x,
				x.x * y.y - y.x * x.y);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_normalize
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

			return v * inversesqrt(dot(v, v));
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_faceforward
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

			return dot(Nref, I) < static_cast<T>(0) ? N : -N;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_reflect
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
		{
			return I - N * dot(N, I) * static_cast<T>(2);
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_refract
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
		{
			T const dotValue(dot(N, I));
			T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
			vec<L, T, Q> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T, Q>(0);
			return Result;
		}
	};
}

	
	template<typename genType>
	 inline genType length(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");

		return abs(x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline T length(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");

		return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
	}

	
	template<typename genType>
	 inline genType distance(genType const& p0, genType const& p1)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");

		return length(p1 - p0);
	}

	template<length_t L, typename T, qualifier Q>
	 inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
	{
		return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
	}

	
	template<typename T>
	 inline constexpr T dot(T x, T y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return x * y;
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
		return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
	}

	
	template<typename T, qualifier Q>
	 inline constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
	{
		return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
	}










	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

		return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
	}

	
	template<typename genType>
	 inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
	{
		return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
	{
		return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
	}

	
	template<typename genType>
	 inline genType reflect(genType const& I, genType const& N)
	{
		return I - N * dot(N, I) * genType(2);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
	{
		return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
	}

	
	template<typename genType>
	 inline genType refract(genType const& I, genType const& N, genType eta)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
		genType const dotValue(dot(N, I));
		genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
		return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
	}
}



#line 244 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_geometric.inl"
#line 117 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\geometric.hpp"
#line 2 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_matrix.inl"


namespace glm{
namespace detail
{
	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_matrixCompMult
	{
		 inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
		{
			mat<C, R, T, Q> Result(1);
			for(length_t i = 0; i < Result.length(); ++i)
				Result[i] = x[i] * y[i];
			return Result;
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
	struct compute_matrixCompMult_type {
		 inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.");
#line 25 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_matrix.inl"
			return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
		}
	};

	template<length_t DA, length_t DB, typename T, qualifier Q>
	struct compute_outerProduct {
		 inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
		{
			typename detail::outerProduct_trait<DA, DB, T, Q>::type m(0);
			for(length_t i = 0; i < m.length(); ++i)
				m[i] = c * r[i];
			return m;
		}
	};

	template<length_t DA, length_t DB, typename T, qualifier Q, bool IsFloat>
	struct compute_outerProduct_type {
		 inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.");
#line 46 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_matrix.inl"

			return detail::compute_outerProduct<DA, DB, T, Q>::call(c, r);
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_transpose{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 2, T, Q, Aligned>
	{
		 inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
		{
			mat<2, 2, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 3, T, Q, Aligned>
	{
		 inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
		{
			mat<3,2, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<2, 4, T, Q, Aligned>
	{
		 inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
		{
			mat<4, 2, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 2, T, Q, Aligned>
	{
		 inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
		{
			mat<2, 3, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 3, T, Q, Aligned>
	{
		 inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
		{
			mat<3, 3, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];

			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];

			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<3, 4, T, Q, Aligned>
	{
		 inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
		{
			mat<4, 3, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 2, T, Q, Aligned>
	{
		 inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
		{
			mat<2, 4, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 3, T, Q, Aligned>
	{
		 inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
		{
			mat<3, 4, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];
			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];
			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];
			return Result;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_transpose<4, 4, T, Q, Aligned>
	{
		 inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
		{
			mat<4, 4, T, Q> Result(1);
			Result[0][0] = m[0][0];
			Result[0][1] = m[1][0];
			Result[0][2] = m[2][0];
			Result[0][3] = m[3][0];

			Result[1][0] = m[0][1];
			Result[1][1] = m[1][1];
			Result[1][2] = m[2][1];
			Result[1][3] = m[3][1];

			Result[2][0] = m[0][2];
			Result[2][1] = m[1][2];
			Result[2][2] = m[2][2];
			Result[2][3] = m[3][2];

			Result[3][0] = m[0][3];
			Result[3][1] = m[1][3];
			Result[3][2] = m[2][3];
			Result[3][3] = m[3][3];
			return Result;
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
	struct compute_transpose_type {
		 inline static mat<R, C, T, Q> call(mat<C, R, T, Q> const& m)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.");
#line 236 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_matrix.inl"
			return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_determinant{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<2, 2, T, Q, Aligned>
	{
		 inline static T call(mat<2, 2, T, Q> const& m)
		{
			return m[0][0] * m[1][1] - m[1][0] * m[0][1];
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<3, 3, T, Q, Aligned>
	{
		 inline static T call(mat<3, 3, T, Q> const& m)
		{
			return
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_determinant<4, 4, T, Q, Aligned>
	{
		 inline static T call(mat<4, 4, T, Q> const& m)
		{
			T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

			vec<4, T, Q> DetCof(
				+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
				- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
				+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
				- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

			return
				m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
				m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
	struct compute_determinant_type{
	
		 inline static T call(mat<C, R, T, Q> const& m)
		{
			static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.");
#line 295 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_matrix.inl"
			return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
		}
	};

	template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
	struct compute_inverse{};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<2, 2, T, Q, Aligned>
	{
		 inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * m[1][1]
				- m[1][0] * m[0][1]);

			mat<2, 2, T, Q> Inverse(
				+ m[1][1] * OneOverDeterminant,
				- m[0][1] * OneOverDeterminant,
				- m[1][0] * OneOverDeterminant,
				+ m[0][0] * OneOverDeterminant);

			return Inverse;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<3, 3, T, Q, Aligned>
	{
		 inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
		{
			T OneOverDeterminant = static_cast<T>(1) / (
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

			mat<3, 3, T, Q> Inverse;
			Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
			Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
			Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
			Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
			Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
			Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
			Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

			return Inverse;
		}
	};

	template<typename T, qualifier Q, bool Aligned>
	struct compute_inverse<4, 4, T, Q, Aligned>
	{
		 inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
		{
			T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
			T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

			T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
			T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

			T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
			T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

			T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
			T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

			T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
			T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

			T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
			T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
			T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

			vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
			vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
			vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
			vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
			vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
			vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);

			vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
			vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
			vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
			vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

			vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
			vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
			vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
			vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

			vec<4, T, Q> SignA(+1, -1, +1, -1);
			vec<4, T, Q> SignB(-1, +1, -1, +1);
			mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

			vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

			vec<4, T, Q> Dot0(m[0] * Row0);
			T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

			T OneOverDeterminant = static_cast<T>(1) / Dot1;

			return Inverse * OneOverDeterminant;
		}
	};
}

	template<length_t C, length_t R, typename T, qualifier Q>
	 inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
	{
		return detail::compute_matrixCompMult_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x, y);
	}

	template<length_t DA, length_t DB, typename T, qualifier Q>
	 inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
	{
		return detail::compute_outerProduct_type<DA, DB, T, Q, std::numeric_limits<T>::is_iec559>::call(c, r);
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	 inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
	{
		return detail::compute_transpose_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	 inline T determinant(mat<C, R, T, Q> const& m)
	{
		return detail::compute_determinant_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
	}

	template<length_t C, length_t R, typename T, qualifier Q>
	 inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
		return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
	}
}



#line 443 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_matrix.inl"

#line 162 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\matrix.hpp"
#line 2 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"

namespace glm
{
	













#line 20 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"

	template<typename T, qualifier Q>
	template<qualifier P>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 27 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 32 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(T scalar)

			: value{col_type(scalar, 0), col_type(0, scalar)}
#line 39 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 44 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat
	(
		T const& x0, T const& y0,
		T const& x1, T const& y1
	)

			: value{col_type(x0, y0), col_type(x1, y1)}
#line 55 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 60 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)

			: value{v0, v1}
#line 67 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 72 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename X1, typename Y1, typename X2, typename Y2>
	 inline constexpr mat<2, 2, T, Q>::mat
	(
		X1 const& x1, Y1 const& y1,
		X2 const& x2, Y2 const& y2
	)

			: value{col_type(static_cast<T>(x1), value_type(y1)), col_type(static_cast<T>(x2), value_type(y2)) }
#line 86 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 91 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	template<typename V1, typename V2>
	 inline constexpr mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

			: value{col_type(v1), col_type(v2)}
#line 99 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 104 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T, qualifier Q>
	template<typename U, qualifier P>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 114 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 119 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 126 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 131 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 138 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 143 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 150 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 155 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 162 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 167 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 174 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 179 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 186 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 191 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 198 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 203 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

			: value{col_type(m[0]), col_type(m[1])}
#line 210 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	{



#line 215 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl"
	}

	

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl", (unsigned)(222)), 0)) ));
		return this->value[i];
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const noexcept
	{
		(((void)( (!!((i) >= 0 && (i) < (this->length()))) || (_wassert(L"(i) >= 0 && (i) < (this->length())", L"C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.inl", (unsigned)(229)), 0)) ));
		return this->value[i];
	}

	

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
	{
		this->value[0] += scalar;
		this->value[1] += scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
	{
		this->value[0] -= scalar;
		this->value[1] -= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
	{
		this->value[0] *= scalar;
		this->value[1] *= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
	{
		return (*this = *this * m);
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
	{
		this->value[0] /= scalar;
		this->value[1] /= scalar;
		return *this;
	}

	template<typename T, qualifier Q>
	template<typename U>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
	{
		return *this *= inverse(m);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
	{
		mat<2, 2, T, Q> Result(*this);
		++*this;
		return Result;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
	{
		mat<2, 2, T, Q> Result(*this);
		--*this;
		return Result;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
	{
		return m;
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			-m[0],
			-m[1]);
	}

	

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			m[0] + scalar,
			m[1] + scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] - scalar,
			m[1] - scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			scalar - m[0],
			scalar - m[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			m[0] * scalar,
			m[1] * scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 2, T, Q>::col_type operator*
	(
		mat<2, 2, T, Q> const& m,
		typename mat<2, 2, T, Q>::row_type const& v
	)
	{
		return vec<2, T, Q>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 2, T, Q>::row_type operator*
	(
		typename mat<2, 2, T, Q>::col_type const& v,
		mat<2, 2, T, Q> const& m
	)
	{
		return vec<2, T, Q>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return mat<2, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
	{
		return mat<3, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
	{
		return mat<4, 2, T, Q>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
	{
		return mat<2, 2, T, Q>(
			m[0] / scalar,
			m[1] / scalar);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
	{
		return mat<2, 2, T, Q>(
			scalar / m[0],
			scalar / m[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
	{
		return inverse(m) * v;
	}

	template<typename T, qualifier Q>
	 inline constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
	{
		return v *  inverse(m);
	}

	template<typename T, qualifier Q>
	 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		mat<2, 2, T, Q> m1_copy(m1);
		return m1_copy /= m2;
	}

	

	template<typename T, qualifier Q>
	 inline constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template<typename T, qualifier Q>
	 inline constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 177 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.hpp"
#line 178 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_mat2x2.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x2.hpp"

namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, double, defaultp>		dmat2x2;

	
	
	
	typedef mat<2, 2, double, defaultp>		dmat2;

	
}
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_double2x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 2, double, lowp>		lowp_dmat2;

	
	
	
	
	typedef mat<2, 2, double, mediump>	mediump_dmat2;

	
	
	
	
	typedef mat<2, 2, double, highp>	highp_dmat2;

	
	
	
	
	typedef mat<2, 2, double, lowp>		lowp_dmat2x2;

	
	
	
	
	typedef mat<2, 2, double, mediump>	mediump_dmat2x2;

	
	
	
	
	typedef mat<2, 2, double, highp>	highp_dmat2x2;

	
}
#line 7 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float2x2.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	typedef mat<2, 2, float, defaultp>		mat2x2;

	
	
	
	typedef mat<2, 2, float, defaultp>		mat2;

	
}
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x2.hpp"
#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\ext\\matrix_float2x2_precision.hpp"



#pragma once


namespace glm
{
	
	

	
	
	
	
	typedef mat<2, 2, float, lowp>		lowp_mat2;

	
	
	
	
	typedef mat<2, 2, float, mediump>	mediump_mat2;

	
	
	
	
	typedef mat<2, 2, float, highp>		highp_mat2;

	
	
	
	
	typedef mat<2, 2, float, lowp>		lowp_mat2x2;

	
	
	
	
	typedef mat<2, 2, float, mediump>	mediump_mat2x2;

	
	
	
	
	typedef mat<2, 2, float, highp>		highp_mat2x2;

	
}
#line 9 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\mat2x2.hpp"

#line 121 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"









#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\trigonometric.hpp"


















#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 22 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\trigonometric.hpp"


namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> radians(vec<L, T, Q> const& degrees);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& radians);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> sin(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> cos(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> tan(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> asin(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> acos(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> sinh(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> cosh(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> tanh(vec<L, T, Q> const& angle);

	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> asinh(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> acosh(vec<L, T, Q> const& x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> atanh(vec<L, T, Q> const& x);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_trigonometric.inl"




namespace glm
{
	
	template<typename genType>
	 inline constexpr genType radians(genType degrees)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'radians' only accept floating-point input");

		return degrees * static_cast<genType>(0.01745329251994329576923690768489);
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> radians(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(radians, v);
	}

	
	template<typename genType>
	 inline constexpr genType degrees(genType radians)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'degrees' only accept floating-point input");

		return radians * static_cast<genType>(57.295779513082320876798154814105);
	}

	template<length_t L, typename T, qualifier Q>
	 inline constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(degrees, v);
	}

	
	using ::std::sin;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(sin, v);
	}

	
	using std::cos;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(cos, v);
	}

	
	using std::tan;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(tan, v);
	}

	
	using std::asin;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(asin, v);
	}

	
	using std::acos;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(acos, v);
	}

	
	template<typename genType>
	 inline genType atan(genType y, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'atan' only accept floating-point input");

		return ::std::atan2(y, x);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x)
	{
		return detail::functor2<vec, L, T, Q>::call(::std::atan2, y, x);
	}

	using std::atan;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(atan, v);
	}

	
	using std::sinh;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(sinh, v);
	}

	
	using std::cosh;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(cosh, v);
	}

	
	using std::tanh;

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(tanh, v);
	}

	

		using std::asinh;








#line 144 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_trigonometric.inl"

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(asinh, v);
	}

	

		using std::acosh;










#line 165 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_trigonometric.inl"

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(acosh, v);
	}

	

		using std::atanh;










#line 186 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_trigonometric.inl"

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
	{
		return detail::functor1<vec, L, T, T, Q>::call(atanh, v);
	}
}



#line 197 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_trigonometric.inl"

#line 211 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\trigonometric.hpp"
#line 131 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"


#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\packing.hpp"















#pragma once





namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	  uint packUnorm2x16(vec2 const& v);

	
	
	
	
	
	
	
	
	
	
	
	  uint packSnorm2x16(vec2 const& v);

	
	
	
	
	
	
	
	
	
	
	
	  uint packUnorm4x8(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	  uint packSnorm4x8(vec4 const& v);

	
	
	
	
	
	
	
	
	
	
	
	  vec2 unpackUnorm2x16(uint p);

	
	
	
	
	
	
	
	
	
	
	
	  vec2 unpackSnorm2x16(uint p);

	
	
	
	
	
	
	
	
	
	
	
	  vec4 unpackUnorm4x8(uint p);

	
	
	
	
	
	
	
	
	
	
	
	  vec4 unpackSnorm4x8(uint p);

	
	
	
	
	
	
	
	
	  double packDouble2x32(uvec2 const& v);

	
	
	
	
	
	
	
	  uvec2 unpackDouble2x32(double v);

	
	
	
	
	
	
	
	
	  uint packHalf2x16(vec2 const& v);

	
	
	
	
	
	
	
	
	  vec2 unpackHalf2x16(uint v);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_packing.inl"




#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_half.hpp"
#pragma once

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 970 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
























































































































































































































#line 1187 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"

#line 1189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\setup.hpp"
#line 4 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_half.hpp"

namespace glm{
namespace detail
{
	typedef short hdata;

	  float toFloat32(hdata value);
	  hdata toFloat16(float const& value);

}
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_half.inl"
namespace glm{
namespace detail
{
	 inline float overflow()
	{
		volatile float f = 1e10;

		for(int i = 0; i < 10; ++i)
			f = f * f; 
		return f;
	}

	union uif32
	{
		 inline uif32() :
			i(0)
		{}

		 inline uif32(float f_) :
			f(f_)
		{}

		 inline uif32(unsigned int i_) :
			i(i_)
		{}

		float f;
		unsigned int i;
	};

	 inline float toFloat32(hdata value)
	{
		int s = (value >> 15) & 0x00000001;
		int e = (value >> 10) & 0x0000001f;
		int m =  value        & 0x000003ff;

		if(e == 0)
		{
			if(m == 0)
			{
				
				
				

				detail::uif32 result;
				result.i = static_cast<unsigned int>(s << 31);
				return result.f;
			}
			else
			{
				
				
				

				while(!(m & 0x00000400))
				{
					m <<= 1;
					e -=  1;
				}

				e += 1;
				m &= ~0x00000400;
			}
		}
		else if(e == 31)
		{
			if(m == 0)
			{
				
				
				

				uif32 result;
				result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
				return result.f;
			}
			else
			{
				
				
				

				uif32 result;
				result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
				return result.f;
			}
		}

		
		
		

		e = e + (127 - 15);
		m = m << 13;

		
		
		

		uif32 Result;
		Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
		return Result.f;
	}

	 inline hdata toFloat16(float const& f)
	{
		uif32 Entry;
		Entry.f = f;
		int i = static_cast<int>(Entry.i);

		
		
		
		
		
		
		
		
		

		int s =  (i >> 16) & 0x00008000;
		int e = ((i >> 23) & 0x000000ff) - (127 - 15);
		int m =   i        & 0x007fffff;

		
		
		

		if(e <= 0)
		{
			if(e < -10)
			{
				
				
				
				
				
				
				

				return hdata(s);
			}

			
			
			
			
			
			

			m = (m | 0x00800000) >> (1 - e);

			
			
			
			
			
			
			
			

			if(m & 0x00001000)
				m += 0x00002000;

			
			
			

			return hdata(s | (m >> 13));
		}
		else if(e == 0xff - (127 - 15))
		{
			if(m == 0)
			{
				
				
				
				

				return hdata(s | 0x7c00);
			}
			else
			{
				
				
				
				
				
				
				
				

				m >>= 13;

				return hdata(s | 0x7c00 | m | (m == 0));
			}
		}
		else
		{
			
			
			
			

			
			
			

			if(m &  0x00001000)
			{
				m += 0x00002000;

				if(m & 0x00800000)
				{
					m =  0;     
					e += 1;     
				}
			}

			
			
			

			if (e > 30)
			{
				overflow();        

				return hdata(s | 0x7c00);
				
			}   

			
			
			

			return hdata(s | (e << 10) | (m >> 13));
		}
	}

}
}
#line 17 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\type_half.hpp"
#line 6 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_packing.inl"

namespace glm
{
	 inline uint packUnorm2x16(vec2 const& v)
	{
		union
		{
			unsigned short in[2];
			uint out;
		} u;

		vec<2, unsigned short, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	 inline vec2 unpackUnorm2x16(uint p)
	{
		union
		{
			uint in;
			unsigned short out[2];
		} u;

		u.in = p;

		return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
	}

	 inline uint packSnorm2x16(vec2 const& v)
	{
		union
		{
			signed short in[2];
			uint out;
		} u;
 
		vec<2, short, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];

		return u.out;
	}

	 inline vec2 unpackSnorm2x16(uint p)
	{
		union
		{
			uint in;
			signed short out[2];
		} u;

		u.in = p;

		return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
	}

	 inline uint packUnorm4x8(vec4 const& v)
	{
		union
		{
			unsigned char in[4];
			uint out;
		} u;

		vec<4, unsigned char, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}

	 inline vec4 unpackUnorm4x8(uint p)
	{
		union
		{
			uint in;
			unsigned char out[4];
		} u;

		u.in = p;

		return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
	}

	 inline uint packSnorm4x8(vec4 const& v)
	{
		union
		{
			signed char in[4];
			uint out;
		} u;

		vec<4, signed char, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

		u.in[0] = result[0];
		u.in[1] = result[1];
		u.in[2] = result[2];
		u.in[3] = result[3];

		return u.out;
	}

	 inline glm::vec4 unpackSnorm4x8(uint p)
	{
		union
		{
			uint in;
			signed char out[4];
		} u;

		u.in = p;

		return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
	}

	 inline double packDouble2x32(uvec2 const& v)
	{
		union
		{
			uint   in[2];
			double out;
		} u;

		u.in[0] = v[0];
		u.in[1] = v[1];

		return u.out;
	}

	 inline uvec2 unpackDouble2x32(double v)
	{
		union
		{
			double in;
			uint   out[2];
		} u;

		u.in = v;

		return uvec2(u.out[0], u.out[1]);
	}

	 inline uint packHalf2x16(vec2 const& v)
	{
		union
		{
			signed short in[2];
			uint out;
		} u;

		u.in[0] = detail::toFloat16(v.x);
		u.in[1] = detail::toFloat16(v.y);

		return u.out;
	}

	 inline vec2 unpackHalf2x16(uint v)
	{
		union
		{
			uint in;
			signed short out[2];
		} u;

		u.in = v;

		return vec2(
			detail::toFloat32(u.out[0]),
			detail::toFloat32(u.out[1]));
	}
}



#line 189 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_packing.inl"

#line 174 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\packing.hpp"
#line 134 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"



#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\integer.hpp"
















#pragma once





namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  vec<L, uint, Q> uaddCarry(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & carry);

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	  vec<L, uint, Q> usubBorrow(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & borrow);

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	 void umulExtended(
		vec<L, uint, Q> const& x,
		vec<L, uint, Q> const& y,
		vec<L, uint, Q> & msb,
		vec<L, uint, Q> & lsb);

	
	
	
	
	
	
	
	
	template<length_t L, qualifier Q>
	 void imulExtended(
		vec<L, int, Q> const& x,
		vec<L, int, Q> const& y,
		vec<L, int, Q> & msb,
		vec<L, int, Q> & lsb);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> bitfieldExtract(
		vec<L, T, Q> const& Value,
		int Offset,
		int Bits);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> bitfieldInsert(
		vec<L, T, Q> const& Base,
		vec<L, T, Q> const& Insert,
		int Offset,
		int Bits);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);

	
	
	
	
	
	
	template<typename genType>
	  int bitCount(genType v);

	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, int, Q> bitCount(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	template<typename genIUType>
	  int findLSB(genIUType x);

	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, int, Q> findLSB(vec<L, T, Q> const& v);

	
	
	
	
	
	
	
	
	
	template<typename genIUType>
	  int findMSB(genIUType x);

	
	
	
	
	
	
	
	
	
	
	template<length_t L, typename T, qualifier Q>
	  vec<L, int, Q> findMSB(vec<L, T, Q> const& v);

	
}

#line 1 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"





#pragma intrinsic(_BitScanReverse)
#line 8 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"











#line 20 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"

namespace glm{
namespace detail
{
	template<typename T>
	 inline T mask(T Bits)
	{
		return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
	}

	template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
	struct compute_bitfieldReverseStep
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
		{
			return v;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
		{
			return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
	struct compute_bitfieldBitCountStep
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
		{
			return v;
		}
	};

	template<length_t L, typename T, qualifier Q, bool Aligned>
	struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
		{
			return (v & Mask) + ((v >> Shift) & Mask);
		}
	};

	template<typename genIUType, size_t Bits>
	struct compute_findLSB
	{
		 inline static int call(genIUType Value)
		{
			if(Value == 0)
				return -1;

			return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
		}
	};

























#line 103 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"

	template<length_t L, typename T, qualifier Q, bool EXEC = true>
	struct compute_findMSB_step_vec
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
		{
			return x | (x >> Shift);
		}
	};

	template<length_t L, typename T, qualifier Q>
	struct compute_findMSB_step_vec<L, T, Q, false>
	{
		 inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
		{
			return x;
		}
	};

	template<length_t L, typename T, qualifier Q, int>
	struct compute_findMSB_vec
	{
		 inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
		{
			vec<L, T, Q> x(v);
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 1));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 2));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >=  8>::call(x, static_cast<T>( 4));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
			x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
			return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
		}
	};





































#line 175 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"
}

	
	 inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
	{
		detail::uint64 const Value64(static_cast<detail::uint64>(x) + static_cast<detail::uint64>(y));
		detail::uint64 const Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
		Carry = Value64 > Max32 ? 1u : 0u;
		return static_cast<uint>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
	}

	template<length_t L, qualifier Q>
	 inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
	{
		vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) + vec<L, detail::uint64, Q>(y));
		vec<L, detail::uint64, Q> Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
		Carry = mix(vec<L, uint, Q>(0), vec<L, uint, Q>(1), greaterThan(Value64, Max32));
		return vec<L, uint, Q>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
	}

	
	 inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
	{
		Borrow = x >= y ? static_cast<uint>(0) : static_cast<uint>(1);
		if(y >= x)
			return y - x;
		else
			return static_cast<uint>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (static_cast<detail::int64>(y) - static_cast<detail::int64>(x)));
	}

	template<length_t L, qualifier Q>
	 inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
	{
		Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
		vec<L, uint, Q> const YgeX(y - x);
		vec<L, uint, Q> const XgeY(vec<L, uint, Q>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (vec<L, detail::int64, Q>(y) - vec<L, detail::int64, Q>(x))));
		return mix(XgeY, YgeX, greaterThanEqual(y, x));
	}

	
	 inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
	{
		detail::uint64 Value64 = static_cast<detail::uint64>(x) * static_cast<detail::uint64>(y);
		msb = static_cast<uint>(Value64 >> static_cast<detail::uint64>(32));
		lsb = static_cast<uint>(Value64);
	}

	template<length_t L, qualifier Q>
	 inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
	{
		vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) * vec<L, detail::uint64, Q>(y));
		msb = vec<L, uint, Q>(Value64 >> static_cast<detail::uint64>(32));
		lsb = vec<L, uint, Q>(Value64);
	}

	
	 inline void imulExtended(int x, int y, int& msb, int& lsb)
	{
		detail::int64 Value64 = static_cast<detail::int64>(x) * static_cast<detail::int64>(y);
		msb = static_cast<int>(Value64 >> static_cast<detail::int64>(32));
		lsb = static_cast<int>(Value64);
	}

	template<length_t L, qualifier Q>
	 inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
	{
		vec<L, detail::int64, Q> Value64(vec<L, detail::int64, Q>(x) * vec<L, detail::int64, Q>(y));
		lsb = vec<L, int, Q>(Value64 & static_cast<detail::int64>(0xFFFFFFFF));
		msb = vec<L, int, Q>((Value64 >> static_cast<detail::int64>(32)) & static_cast<detail::int64>(0xFFFFFFFF));
	}

	
	template<typename genIUType>
	 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
	{
		return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");

		return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
	}

	
	template<typename genIUType>
	 inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldInsert' only accept integer values");

		return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");

		T const Mask = detail::mask(static_cast<T>(Bits)) << Offset;
		return (Base & ~Mask) | ((Insert << static_cast<T>(Offset)) & Mask);
	}


#pragma warning(push)
#pragma warning(disable : 4309)
#line 283 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"

	
	template<typename genIUType>
	 inline genIUType bitfieldReverse(genIUType x)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldReverse' only accept integer values");

		return bitfieldReverse(glm::vec<1, genIUType, glm::defaultp>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitfieldReverse' only accept integer values");

		vec<L, T, Q> x(v);
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
		x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
		return x;
	}


#pragma warning(pop)
#line 311 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"

	
	template<typename genIUType>
	 inline int bitCount(genIUType x)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'bitCount' only accept integer values");

		return bitCount(glm::vec<1, genIUType, glm::defaultp>(x)).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'bitCount' only accept integer values");


#pragma warning(push)
#pragma warning(disable : 4310) 
#line 330 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"

		vec<L, typename detail::make_unsigned<T>::type, Q> x(v);
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>=  8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
		x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
		return vec<L, int, Q>(x);


#pragma warning(pop)
#line 343 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"
	}

	
	template<typename genIUType>
	 inline int findLSB(genIUType Value)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");

		return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");

		return detail::functor1<vec, L, int, T, Q>::call(findLSB, x);
	}

	
	template<typename genIUType>
	 inline int findMSB(genIUType v)
	{
		static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

		return findMSB(vec<1, genIUType>(v)).x;
	}

	template<length_t L, typename T, qualifier Q>
	 inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
	{
		static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");

		return detail::compute_findMSB_vec<L, T, Q, static_cast<int>(sizeof(T) * 8)>::call(v);
	}
}








#line 388 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"



#line 392 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\detail\\func_integer.inl"

#line 213 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\integer.hpp"
#line 138 "C:\\Users\\rapul\\FYSM\\Impi\\includes\\glm\\glm.hpp"
#line 5 "C:\\Users\\rapul\\FYSM\\Impi\\Impi\\headers\\rendering\\assets\\SphereMesh.h"






 

struct SphereMesh {

	std::vector<glm::vec3> vertices;
	std::vector<glm::vec3> normals;
	std::vector<glm::vec2> texCoords;
	std::vector<unsigned int> indices;


	unsigned int vao = 0;
	unsigned int vbo = 0;
	unsigned int ebo = 0;
	unsigned int indexCount = 0;


	void createMesh(float radius = 1.0f, unsigned int sectorCount = 36, unsigned int stackCount = 24);

	std::vector<float> flatten() const;

	void uploadToGPU();

	void draw() const;

	void destroySphereMesh();

	void drawSphereMesh();

};
#line 2 "C:\\Users\\rapul\\FYSM\\Impi\\Impi\\src\\rendering\\assets\\SphereMesh.cpp"



void SphereMesh::createMesh(float radius, unsigned int sectorCount, unsigned int stackCount)
{
	vertices.clear();
	normals.clear();
	texCoords.clear();
	indices.clear();

	const float PI = 3.14159265358979323846f;

	float x, y, z, xy; 
	float nx, ny, nz, lengthInv = 1.0f / radius; 
	float s, t; 

	float sectorStep = 2 * PI / sectorCount;
	float stackStep = PI / stackCount;
	float sectorAngle, stackAngle;

	for (unsigned int i=0; i <= stackCount; ++i)
	{
		
		stackAngle = PI / 2 - i * stackStep;
		xy = radius * cosf(stackAngle); 
		z = radius * sinf(stackAngle);

		

		for (unsigned int j=0; j <= sectorCount; ++j)
		{
			sectorAngle = j * sectorStep;

			x = xy * cosf(sectorAngle);
			y = xy * sinf(sectorAngle);
			
			
			vertices.push_back(glm::vec3(x,y,z));

			nx = x * lengthInv;
			ny = y * lengthInv;
			nz = z * lengthInv;
			normals.push_back(glm::vec3(nx, ny, nz));
			s = (float)j / sectorCount;
			t = (float)i / stackCount;
			texCoords.push_back(glm::vec2(s, t));

		}

	}


	
	
	
	
	for (unsigned int i=0; i < stackCount; ++i)
	{
		unsigned int k1 = i * (sectorCount + 1);
		unsigned int k2 = k1 + sectorCount + 1;

		for (unsigned int j=0; j < sectorCount; ++j, ++k1, ++k2)
		{
			if (i != 0)
			{
				indices.push_back(k1);
				indices.push_back(k2);
				indices.push_back(k1 + 1);
			}
			if (i != stackCount - 1)
			{
				indices.push_back(k1 + 1);
				indices.push_back(k2);
				indices.push_back(k2 + 1);
			}
		}
	}
	indexCount = (unsigned int)indices.size();

}






std::vector<float> SphereMesh::flatten() const
{
	std::vector<float> flatdata;
	flatdata.reserve(vertices.size() * 8);

	for (size_t i = 0; i < vertices.size(); ++i)
	{
		const glm::vec3& v = vertices[i];
		const glm::vec3& n = normals[i];
		const glm::vec2& uv = texCoords[i];

		flatdata.push_back(v.x);
		flatdata.push_back(v.y);
		flatdata.push_back(v.z);

		flatdata.push_back(n.x);
		flatdata.push_back(n.y);
		flatdata.push_back(n.z);

		flatdata.push_back(uv.x);
		flatdata.push_back(uv.y);

	}

	return flatdata;
}

void SphereMesh::uploadToGPU()
{

	std::vector<float> flatdata = flatten();

	glad_glGenVertexArrays(1, &vao);
	glad_glGenBuffers(1, &vbo);
	glad_glGenBuffers(1, &ebo);

	glad_glBindVertexArray(vao);
	glad_glBindBuffer(0x8892, vbo);
	glad_glBufferData(0x8892, flatdata.size() * sizeof(float), flatdata.data(), 0x88E4);

	glad_glBindBuffer(0x8893, ebo);
	glad_glBufferData(0x8893, indices.size() * sizeof(unsigned int), indices.data(), 0x88E4);

	GLsizei stride_ptr = (3 + 3 + 2) * sizeof(float);

	glad_glVertexAttribPointer(0, 3, 0x1406, 0, stride_ptr, (void*)0);
	glad_glEnableVertexAttribArray(0);

	glad_glVertexAttribPointer(1, 3, 0x1406, 0, stride_ptr, (void*)3);
	glad_glEnableVertexAttribArray(1);

	glad_glVertexAttribPointer(2, 2, 0x1406, 0, stride_ptr, (void*)6);
	glad_glEnableVertexAttribArray(2);

	glad_glBindVertexArray(0);
}

void SphereMesh::destroySphereMesh()
{
	if (ebo) glad_glDeleteBuffers(1, &ebo);
	if (vbo) glad_glDeleteBuffers(1, &vbo);
	if (vao) glad_glDeleteBuffers(1, &vao);
	vao = vbo = ebo = 0;
}

void SphereMesh::draw() const
{
	glad_glBindVertexArray(vao);
	glad_glDrawElements(0x0004, indexCount, 0x1405, 0);
	glad_glBindVertexArray(0);
}
